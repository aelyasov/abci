{-# LANGUAGE Rank2Types, GADTs #-}
{-# LANGUAGE ScopedTypeVariables #-}

{-# LANGUAGE EmptyDataDecls, TypeFamilies #-}
module DeadCodeRemoval(removeDeadCode) where


import Fixpoint


import qualified Data.Map as Map
import Data.Map(Map)
import qualified Data.IntMap as IntMap
import Data.IntMap(IntMap)
import Data.Set(Set)
import qualified Data.Set as Set
import Data.Maybe
import ProgInfo
-- WP, adding this import; this ag turns out to need it:
import ByteCodeSupport


-- These are typical imports
import Data.ByteString.Lazy(ByteString)
import qualified Data.ByteString.Lazy as B
import Data.Map(Map)
import qualified Data.Map as Map
import Data.Set(Set)
import Data.IntMap(IntMap)
import Data.IntSet(IntSet)
import qualified Data.IntMap as IntMap
import qualified Data.Set as Set
import qualified Data.IntSet as IntSet
import Data.Word
import Data.Monoid  (mappend, mconcat, mempty)
import ByteCode
import ByteCodeSupport
import Debug.Trace
import Control.Monad.Identity (Identity)
import qualified Control.Monad.Identity

removeDeadCode :: SwfFile -> SwfFile
removeDeadCode m = out where
  inh = Inh_SwfFile {}
  sem = sem_SwfFile m
  syn = wrap_SwfFile sem inh
  out = output_Syn_SwfFile syn


data TDead
type DeadGraph = FixGraph TDead
type DeadSem   = FixSem TDead
type instance EdgeVal TDead = Bool  -- is predecessor reachable?
type instance NodeVal TDead = Bool  -- is the node reachable?
type instance NodeId  TDead = Int
type instance SolveState TDead = ()

propagate :: NodeFunIn TDead -> NodeFunOut TDead
propagate (NodeFunIn inps mbNode mbPrev sh) = NodeFunOut mbNode mbOut sh where
  out     = or inps
  outPrev = maybe False id mbPrev
  mbOut   = if out == outPrev then Nothing else Just out
  mbNode  = Just out


  superSource :: Int
superSource = -1
{-
-}
-- AbcFile -----------------------------------------------------
-- data
data AbcFile 
  = AbcFile_File {minorVersion_AbcFile_File :: (Word16), majorVersion_AbcFile_File :: (Word16), constantPool_AbcFile_File :: (PoolInfo), methods_AbcFile_File :: (MethodInfos), metadatas_AbcFile_File :: (MetaInfos), instances_AbcFile_File :: (InstanceInfos), classes_AbcFile_File :: (ClassInfos), scripts_AbcFile_File :: (ScriptInfos), bodies_AbcFile_File :: (BodyInfos)}

-- cata
{-# INLINE sem_AbcFile #-}
sem_AbcFile :: AbcFile  -> T_AbcFile 
sem_AbcFile ( AbcFile_File minorVersion_ majorVersion_ constantPool_ methods_ metadatas_ instances_ classes_ scripts_ bodies_ ) = sem_AbcFile_File minorVersion_ majorVersion_ ( sem_PoolInfo constantPool_ ) ( sem_MethodInfos methods_ ) ( sem_MetaInfos metadatas_ ) ( sem_InstanceInfos instances_ ) ( sem_ClassInfos classes_ ) ( sem_ScriptInfos scripts_ ) ( sem_BodyInfos bodies_ )

-- semantic domain
newtype T_AbcFile  = T_AbcFile {
                               attach_T_AbcFile :: Identity (T_AbcFile_s2 )
                               }
newtype T_AbcFile_s2  = C_AbcFile_s2 {
                                     inv_AbcFile_s2 :: (T_AbcFile_v1 )
                                     }
data T_AbcFile_s3  = C_AbcFile_s3
type T_AbcFile_v1  = (T_AbcFile_vIn1 ) -> (T_AbcFile_vOut1 )
data T_AbcFile_vIn1  = T_AbcFile_vIn1 
data T_AbcFile_vOut1  = T_AbcFile_vOut1 (AbcFile)
{-# NOINLINE sem_AbcFile_File #-}
sem_AbcFile_File :: (Word16) -> (Word16) -> T_PoolInfo  -> T_MethodInfos  -> T_MetaInfos  -> T_InstanceInfos  -> T_ClassInfos  -> T_ScriptInfos  -> T_BodyInfos  -> T_AbcFile 
sem_AbcFile_File minorVersion_ majorVersion_ constantPool_ methods_ metadatas_ instances_ classes_ scripts_ bodies_ = T_AbcFile (return st2) where
   {-# NOINLINE st2 #-}
   st2 = let
      v1 :: T_AbcFile_v1 
      v1 = \ (T_AbcFile_vIn1 ) -> ( let
         _constantPoolX122 = Control.Monad.Identity.runIdentity (attach_T_PoolInfo (constantPool_))
         _methodsX83 = Control.Monad.Identity.runIdentity (attach_T_MethodInfos (methods_))
         _metadatasX65 = Control.Monad.Identity.runIdentity (attach_T_MetaInfos (metadatas_))
         _instancesX44 = Control.Monad.Identity.runIdentity (attach_T_InstanceInfos (instances_))
         _classesX23 = Control.Monad.Identity.runIdentity (attach_T_ClassInfos (classes_))
         _scriptsX140 = Control.Monad.Identity.runIdentity (attach_T_ScriptInfos (scripts_))
         _bodiesX14 = Control.Monad.Identity.runIdentity (attach_T_BodyInfos (bodies_))
         (T_PoolInfo_vOut121 _constantPoolIoutput) = inv_PoolInfo_s122 _constantPoolX122 (T_PoolInfo_vIn121 )
         (T_MethodInfos_vOut82 _methodsIoutput) = inv_MethodInfos_s83 _methodsX83 (T_MethodInfos_vIn82 )
         (T_MetaInfos_vOut64 _metadatasIoutput) = inv_MetaInfos_s65 _metadatasX65 (T_MetaInfos_vIn64 )
         (T_InstanceInfos_vOut43 _instancesIoutput) = inv_InstanceInfos_s44 _instancesX44 (T_InstanceInfos_vIn43 )
         (T_ClassInfos_vOut22 _classesIoutput) = inv_ClassInfos_s23 _classesX23 (T_ClassInfos_vIn22 )
         (T_ScriptInfos_vOut139 _scriptsIoutput) = inv_ScriptInfos_s140 _scriptsX140 (T_ScriptInfos_vIn139 )
         (T_BodyInfos_vOut13 _bodiesIoutput) = inv_BodyInfos_s14 _bodiesX14 (T_BodyInfos_vIn13 _bodiesObodyId)
         _bodiesObodyId = rule0  ()
         _output = rule1 _bodiesIoutput _classesIoutput _constantPoolIoutput _instancesIoutput _metadatasIoutput _methodsIoutput _scriptsIoutput majorVersion_ minorVersion_
         _lhsOoutput :: AbcFile
         _lhsOoutput = rule2 _output
         __result_ = T_AbcFile_vOut1 _lhsOoutput
         in __result_ )
     in C_AbcFile_s2 v1
   {-# INLINE rule0 #-}
   rule0 = \  (_ :: ()) ->
                                        0
   {-# INLINE rule1 #-}
   rule1 = \ ((_bodiesIoutput) :: BodyInfos) ((_classesIoutput) :: ClassInfos) ((_constantPoolIoutput) :: PoolInfo) ((_instancesIoutput) :: InstanceInfos) ((_metadatasIoutput) :: MetaInfos) ((_methodsIoutput) :: MethodInfos) ((_scriptsIoutput) :: ScriptInfos) majorVersion_ minorVersion_ ->
     AbcFile_File minorVersion_ majorVersion_ _constantPoolIoutput _methodsIoutput _metadatasIoutput _instancesIoutput _classesIoutput _scriptsIoutput _bodiesIoutput
   {-# INLINE rule2 #-}
   rule2 = \ _output ->
     _output

-- AbcFlag -----------------------------------------------------
-- data
data AbcFlag 
  = AbcFlag_LazyInit {}

-- cata
{-# INLINE sem_AbcFlag #-}
sem_AbcFlag :: AbcFlag  -> T_AbcFlag 
sem_AbcFlag ( AbcFlag_LazyInit  ) = sem_AbcFlag_LazyInit 

-- semantic domain
newtype T_AbcFlag  = T_AbcFlag {
                               attach_T_AbcFlag :: Identity (T_AbcFlag_s5 )
                               }
newtype T_AbcFlag_s5  = C_AbcFlag_s5 {
                                     inv_AbcFlag_s5 :: (T_AbcFlag_v4 )
                                     }
data T_AbcFlag_s6  = C_AbcFlag_s6
type T_AbcFlag_v4  = (T_AbcFlag_vIn4 ) -> (T_AbcFlag_vOut4 )
data T_AbcFlag_vIn4  = T_AbcFlag_vIn4 
data T_AbcFlag_vOut4  = T_AbcFlag_vOut4 (AbcFlag)
{-# NOINLINE sem_AbcFlag_LazyInit #-}
sem_AbcFlag_LazyInit ::  T_AbcFlag 
sem_AbcFlag_LazyInit  = T_AbcFlag (return st5) where
   {-# NOINLINE st5 #-}
   st5 = let
      v4 :: T_AbcFlag_v4 
      v4 = \ (T_AbcFlag_vIn4 ) -> ( let
         _output = rule3  ()
         _lhsOoutput :: AbcFlag
         _lhsOoutput = rule4 _output
         __result_ = T_AbcFlag_vOut4 _lhsOoutput
         in __result_ )
     in C_AbcFlag_s5 v4
   {-# INLINE rule3 #-}
   rule3 = \  (_ :: ()) ->
     AbcFlag_LazyInit
   {-# INLINE rule4 #-}
   rule4 = \ _output ->
     _output

-- AbcFlags ----------------------------------------------------
-- data
type AbcFlags  = [ AbcFlag ]

-- cata
{-# NOINLINE sem_AbcFlags #-}
sem_AbcFlags :: AbcFlags  -> T_AbcFlags 
sem_AbcFlags list = Prelude.foldr sem_AbcFlags_Cons sem_AbcFlags_Nil (Prelude.map sem_AbcFlag list)

-- semantic domain
newtype T_AbcFlags  = T_AbcFlags {
                                 attach_T_AbcFlags :: Identity (T_AbcFlags_s8 )
                                 }
newtype T_AbcFlags_s8  = C_AbcFlags_s8 {
                                       inv_AbcFlags_s8 :: (T_AbcFlags_v7 )
                                       }
data T_AbcFlags_s9  = C_AbcFlags_s9
type T_AbcFlags_v7  = (T_AbcFlags_vIn7 ) -> (T_AbcFlags_vOut7 )
data T_AbcFlags_vIn7  = T_AbcFlags_vIn7 
data T_AbcFlags_vOut7  = T_AbcFlags_vOut7 (AbcFlags)
{-# NOINLINE sem_AbcFlags_Cons #-}
sem_AbcFlags_Cons :: T_AbcFlag  -> T_AbcFlags  -> T_AbcFlags 
sem_AbcFlags_Cons hd_ tl_ = T_AbcFlags (return st8) where
   {-# NOINLINE st8 #-}
   st8 = let
      v7 :: T_AbcFlags_v7 
      v7 = \ (T_AbcFlags_vIn7 ) -> ( let
         _hdX5 = Control.Monad.Identity.runIdentity (attach_T_AbcFlag (hd_))
         _tlX8 = Control.Monad.Identity.runIdentity (attach_T_AbcFlags (tl_))
         (T_AbcFlag_vOut4 _hdIoutput) = inv_AbcFlag_s5 _hdX5 (T_AbcFlag_vIn4 )
         (T_AbcFlags_vOut7 _tlIoutput) = inv_AbcFlags_s8 _tlX8 (T_AbcFlags_vIn7 )
         _output = rule5 _hdIoutput _tlIoutput
         _lhsOoutput :: AbcFlags
         _lhsOoutput = rule6 _output
         __result_ = T_AbcFlags_vOut7 _lhsOoutput
         in __result_ )
     in C_AbcFlags_s8 v7
   {-# INLINE rule5 #-}
   rule5 = \ ((_hdIoutput) :: AbcFlag) ((_tlIoutput) :: AbcFlags) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule6 #-}
   rule6 = \ _output ->
     _output
{-# NOINLINE sem_AbcFlags_Nil #-}
sem_AbcFlags_Nil ::  T_AbcFlags 
sem_AbcFlags_Nil  = T_AbcFlags (return st8) where
   {-# NOINLINE st8 #-}
   st8 = let
      v7 :: T_AbcFlags_v7 
      v7 = \ (T_AbcFlags_vIn7 ) -> ( let
         _output = rule7  ()
         _lhsOoutput :: AbcFlags
         _lhsOoutput = rule8 _output
         __result_ = T_AbcFlags_vOut7 _lhsOoutput
         in __result_ )
     in C_AbcFlags_s8 v7
   {-# INLINE rule7 #-}
   rule7 = \  (_ :: ()) ->
     []
   {-# INLINE rule8 #-}
   rule8 = \ _output ->
     _output

-- BodyInfo ----------------------------------------------------
-- data
data BodyInfo 
  = BodyInfo_Info {method_BodyInfo_Info :: (Word32), maxStack_BodyInfo_Info :: (Word32), localCount_BodyInfo_Info :: (Word32), initScopeDepth_BodyInfo_Info :: (Word32), maxScopeDepth_BodyInfo_Info :: (Word32), instructions_BodyInfo_Info :: (InstructionsTop), exceptions_BodyInfo_Info :: (Exceptions), traits_BodyInfo_Info :: (Traits)}

-- cata
{-# INLINE sem_BodyInfo #-}
sem_BodyInfo :: BodyInfo  -> T_BodyInfo 
sem_BodyInfo ( BodyInfo_Info method_ maxStack_ localCount_ initScopeDepth_ maxScopeDepth_ instructions_ exceptions_ traits_ ) = sem_BodyInfo_Info method_ maxStack_ localCount_ initScopeDepth_ maxScopeDepth_ ( sem_InstructionsTop instructions_ ) ( sem_Exceptions exceptions_ ) ( sem_Traits traits_ )

-- semantic domain
newtype T_BodyInfo  = T_BodyInfo {
                                 attach_T_BodyInfo :: Identity (T_BodyInfo_s11 )
                                 }
newtype T_BodyInfo_s11  = C_BodyInfo_s11 {
                                         inv_BodyInfo_s11 :: (T_BodyInfo_v10 )
                                         }
data T_BodyInfo_s12  = C_BodyInfo_s12
type T_BodyInfo_v10  = (T_BodyInfo_vIn10 ) -> (T_BodyInfo_vOut10 )
data T_BodyInfo_vIn10  = T_BodyInfo_vIn10 (Int)
data T_BodyInfo_vOut10  = T_BodyInfo_vOut10 (BodyInfo)
{-# NOINLINE sem_BodyInfo_Info #-}
sem_BodyInfo_Info :: (Word32) -> (Word32) -> (Word32) -> (Word32) -> (Word32) -> T_InstructionsTop  -> T_Exceptions  -> T_Traits  -> T_BodyInfo 
sem_BodyInfo_Info method_ maxStack_ localCount_ initScopeDepth_ maxScopeDepth_ instructions_ exceptions_ traits_ = T_BodyInfo (return st11) where
   {-# NOINLINE st11 #-}
   st11 = let
      v10 :: T_BodyInfo_v10 
      v10 = \ (T_BodyInfo_vIn10 _lhsIbodyId) -> ( let
         _instructionsX53 = Control.Monad.Identity.runIdentity (attach_T_InstructionsTop (instructions_))
         _exceptionsX32 = Control.Monad.Identity.runIdentity (attach_T_Exceptions (exceptions_))
         _traitsX179 = Control.Monad.Identity.runIdentity (attach_T_Traits (traits_))
         (T_InstructionsTop_vOut52 _instructionsIfollowup _instructionsIgathEdges _instructionsIgathNodes _instructionsIgathSources _instructionsIoutput) = inv_InstructionsTop_s53 _instructionsX53 (T_InstructionsTop_vIn52 _instructionsOdistSources _instructionsOmethodId _instructionsOreachRes)
         (T_Exceptions_vOut31 _exceptionsIgathSources _exceptionsIoutput _exceptionsIroots) = inv_Exceptions_s32 _exceptionsX32 (T_Exceptions_vIn31 _exceptionsOindex)
         (T_Traits_vOut178 _traitsIoutput) = inv_Traits_s179 _traitsX179 (T_Traits_vIn178 )
         _instructionsOmethodId = rule9 method_
         _rootEdges = rule10 _roots
         _allEdges = rule11 _instructionsIgathEdges _rootEdges
         _roots = rule12 _exceptionsIroots _instructionsIfollowup
         _reachInit = rule13  ()
         _reachOut = rule14 _allEdges _instructionsIgathNodes _reachInit
         _reachRes = rule15 _reachOut
         _exceptionsOindex = rule16  ()
         _source = rule17  ()
         _startSource = rule18 _source
         _allSources = rule19 _exceptionsIgathSources _instructionsIgathSources _startSource
         _instructionsOdistSources = rule20 _allSources
         _output = rule21 _exceptionsIoutput _instructionsIoutput _traitsIoutput initScopeDepth_ localCount_ maxScopeDepth_ maxStack_ method_
         _lhsOoutput :: BodyInfo
         _lhsOoutput = rule22 _output
         _instructionsOreachRes = rule23 _reachRes
         __result_ = T_BodyInfo_vOut10 _lhsOoutput
         in __result_ )
     in C_BodyInfo_s11 v10
   {-# INLINE rule9 #-}
   rule9 = \ method_ ->
                                               method_
   {-# INLINE rule10 #-}
   rule10 = \ _roots ->
                      mconcat [ edge superSource r | r <- _roots     ]
   {-# INLINE rule11 #-}
   rule11 = \ ((_instructionsIgathEdges) :: DeadGraph) _rootEdges ->
                      _rootEdges     `mappend` _instructionsIgathEdges
   {-# INLINE rule12 #-}
   rule12 = \ ((_exceptionsIroots) :: [Int]) ((_instructionsIfollowup) :: Maybe Int) ->
                      maybe 0 id _instructionsIfollowup : _exceptionsIroots
   {-# INLINE rule13 #-}
   rule13 = \  (_ :: ()) ->
                      Map.singleton superSource True
   {-# INLINE rule14 #-}
   rule14 = \ _allEdges ((_instructionsIgathNodes) :: DeadSem) _reachInit ->
                      solve' _allEdges     _instructionsIgathNodes _reachInit     Map.empty
   {-# INLINE rule15 #-}
   rule15 = \ _reachOut ->
                      IntMap.fromAscList $ Map.assocs _reachOut
   {-# INLINE rule16 #-}
   rule16 = \  (_ :: ()) ->
                                            0
   {-# INLINE rule17 #-}
   rule17 = \  (_ :: ()) ->
                      SourceStart
   {-# INLINE rule18 #-}
   rule18 = \ _source ->
                      Map.singleton _source     [0]
   {-# INLINE rule19 #-}
   rule19 = \ ((_exceptionsIgathSources) :: Map BranchSource [Int]) ((_instructionsIgathSources) :: Map BranchSource [Int]) _startSource ->
                      _startSource     `m'mappend` _exceptionsIgathSources `m'mappend` _instructionsIgathSources
   {-# INLINE rule20 #-}
   rule20 = \ _allSources ->
                               IntMap.fromListWith (++) [ (k,[s]) | (s,ks) <- Map.assocs _allSources    , k <- ks ]
   {-# INLINE rule21 #-}
   rule21 = \ ((_exceptionsIoutput) :: Exceptions) ((_instructionsIoutput) :: InstructionsTop) ((_traitsIoutput) :: Traits) initScopeDepth_ localCount_ maxScopeDepth_ maxStack_ method_ ->
     BodyInfo_Info method_ maxStack_ localCount_ initScopeDepth_ maxScopeDepth_ _instructionsIoutput _exceptionsIoutput _traitsIoutput
   {-# INLINE rule22 #-}
   rule22 = \ _output ->
     _output
   {-# INLINE rule23 #-}
   rule23 = \ _reachRes ->
     _reachRes

-- BodyInfos ---------------------------------------------------
-- data
type BodyInfos  = [ BodyInfo ]

-- cata
{-# NOINLINE sem_BodyInfos #-}
sem_BodyInfos :: BodyInfos  -> T_BodyInfos 
sem_BodyInfos list = Prelude.foldr sem_BodyInfos_Cons sem_BodyInfos_Nil (Prelude.map sem_BodyInfo list)

-- semantic domain
newtype T_BodyInfos  = T_BodyInfos {
                                   attach_T_BodyInfos :: Identity (T_BodyInfos_s14 )
                                   }
newtype T_BodyInfos_s14  = C_BodyInfos_s14 {
                                           inv_BodyInfos_s14 :: (T_BodyInfos_v13 )
                                           }
data T_BodyInfos_s15  = C_BodyInfos_s15
type T_BodyInfos_v13  = (T_BodyInfos_vIn13 ) -> (T_BodyInfos_vOut13 )
data T_BodyInfos_vIn13  = T_BodyInfos_vIn13 (Int)
data T_BodyInfos_vOut13  = T_BodyInfos_vOut13 (BodyInfos)
{-# NOINLINE sem_BodyInfos_Cons #-}
sem_BodyInfos_Cons :: T_BodyInfo  -> T_BodyInfos  -> T_BodyInfos 
sem_BodyInfos_Cons hd_ tl_ = T_BodyInfos (return st14) where
   {-# NOINLINE st14 #-}
   st14 = let
      v13 :: T_BodyInfos_v13 
      v13 = \ (T_BodyInfos_vIn13 _lhsIbodyId) -> ( let
         _hdX11 = Control.Monad.Identity.runIdentity (attach_T_BodyInfo (hd_))
         _tlX14 = Control.Monad.Identity.runIdentity (attach_T_BodyInfos (tl_))
         (T_BodyInfo_vOut10 _hdIoutput) = inv_BodyInfo_s11 _hdX11 (T_BodyInfo_vIn10 _hdObodyId)
         (T_BodyInfos_vOut13 _tlIoutput) = inv_BodyInfos_s14 _tlX14 (T_BodyInfos_vIn13 _tlObodyId)
         _tlObodyId = rule24 _lhsIbodyId
         _output = rule25 _hdIoutput _tlIoutput
         _lhsOoutput :: BodyInfos
         _lhsOoutput = rule26 _output
         _hdObodyId = rule27 _lhsIbodyId
         __result_ = T_BodyInfos_vOut13 _lhsOoutput
         in __result_ )
     in C_BodyInfos_s14 v13
   {-# INLINE rule24 #-}
   rule24 = \ ((_lhsIbodyId) :: Int) ->
                                    1 + _lhsIbodyId
   {-# INLINE rule25 #-}
   rule25 = \ ((_hdIoutput) :: BodyInfo) ((_tlIoutput) :: BodyInfos) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule26 #-}
   rule26 = \ _output ->
     _output
   {-# INLINE rule27 #-}
   rule27 = \ ((_lhsIbodyId) :: Int) ->
     _lhsIbodyId
{-# NOINLINE sem_BodyInfos_Nil #-}
sem_BodyInfos_Nil ::  T_BodyInfos 
sem_BodyInfos_Nil  = T_BodyInfos (return st14) where
   {-# NOINLINE st14 #-}
   st14 = let
      v13 :: T_BodyInfos_v13 
      v13 = \ (T_BodyInfos_vIn13 _lhsIbodyId) -> ( let
         _output = rule28  ()
         _lhsOoutput :: BodyInfos
         _lhsOoutput = rule29 _output
         __result_ = T_BodyInfos_vOut13 _lhsOoutput
         in __result_ )
     in C_BodyInfos_s14 v13
   {-# INLINE rule28 #-}
   rule28 = \  (_ :: ()) ->
     []
   {-# INLINE rule29 #-}
   rule29 = \ _output ->
     _output

-- CaseOffsets -------------------------------------------------
-- data
type CaseOffsets  = [ Word32 ]

-- cata
{-# NOINLINE sem_CaseOffsets #-}
sem_CaseOffsets :: CaseOffsets  -> T_CaseOffsets 
sem_CaseOffsets list = Prelude.foldr sem_CaseOffsets_Cons sem_CaseOffsets_Nil list

-- semantic domain
newtype T_CaseOffsets  = T_CaseOffsets {
                                       attach_T_CaseOffsets :: Identity (T_CaseOffsets_s17 )
                                       }
newtype T_CaseOffsets_s17  = C_CaseOffsets_s17 {
                                               inv_CaseOffsets_s17 :: (T_CaseOffsets_v16 )
                                               }
data T_CaseOffsets_s18  = C_CaseOffsets_s18
type T_CaseOffsets_v16  = (T_CaseOffsets_vIn16 ) -> (T_CaseOffsets_vOut16 )
data T_CaseOffsets_vIn16  = T_CaseOffsets_vIn16 
data T_CaseOffsets_vOut16  = T_CaseOffsets_vOut16 (BranchingInfo) (CaseOffsets)
{-# NOINLINE sem_CaseOffsets_Cons #-}
sem_CaseOffsets_Cons :: (Word32) -> T_CaseOffsets  -> T_CaseOffsets 
sem_CaseOffsets_Cons hd_ tl_ = T_CaseOffsets (return st17) where
   {-# NOINLINE st17 #-}
   st17 = let
      v16 :: T_CaseOffsets_v16 
      v16 = \ (T_CaseOffsets_vIn16 ) -> ( let
         _tlX17 = Control.Monad.Identity.runIdentity (attach_T_CaseOffsets (tl_))
         (T_CaseOffsets_vOut16 _tlIbranching _tlIoutput) = inv_CaseOffsets_s17 _tlX17 (T_CaseOffsets_vIn16 )
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule30 _tlIbranching hd_
         _output = rule31 _tlIoutput hd_
         _lhsOoutput :: CaseOffsets
         _lhsOoutput = rule32 _output
         __result_ = T_CaseOffsets_vOut16 _lhsObranching _lhsOoutput
         in __result_ )
     in C_CaseOffsets_s17 v16
   {-# INLINE rule30 #-}
   rule30 = \ ((_tlIbranching) :: BranchingInfo) hd_ ->
                            extraBranch hd_ `mappend` _tlIbranching
   {-# INLINE rule31 #-}
   rule31 = \ ((_tlIoutput) :: CaseOffsets) hd_ ->
     (:) hd_ _tlIoutput
   {-# INLINE rule32 #-}
   rule32 = \ _output ->
     _output
{-# NOINLINE sem_CaseOffsets_Nil #-}
sem_CaseOffsets_Nil ::  T_CaseOffsets 
sem_CaseOffsets_Nil  = T_CaseOffsets (return st17) where
   {-# NOINLINE st17 #-}
   st17 = let
      v16 :: T_CaseOffsets_v16 
      v16 = \ (T_CaseOffsets_vIn16 ) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule33  ()
         _output = rule34  ()
         _lhsOoutput :: CaseOffsets
         _lhsOoutput = rule35 _output
         __result_ = T_CaseOffsets_vOut16 _lhsObranching _lhsOoutput
         in __result_ )
     in C_CaseOffsets_s17 v16
   {-# INLINE rule33 #-}
   rule33 = \  (_ :: ()) ->
                            dfltBranch
   {-# INLINE rule34 #-}
   rule34 = \  (_ :: ()) ->
     []
   {-# INLINE rule35 #-}
   rule35 = \ _output ->
     _output

-- ClassInfo ---------------------------------------------------
-- data
data ClassInfo 
  = ClassInfo_Info {constructor_ClassInfo_Info :: (Word32), traits_ClassInfo_Info :: (Traits)}

-- cata
{-# INLINE sem_ClassInfo #-}
sem_ClassInfo :: ClassInfo  -> T_ClassInfo 
sem_ClassInfo ( ClassInfo_Info constructor_ traits_ ) = sem_ClassInfo_Info constructor_ ( sem_Traits traits_ )

-- semantic domain
newtype T_ClassInfo  = T_ClassInfo {
                                   attach_T_ClassInfo :: Identity (T_ClassInfo_s20 )
                                   }
newtype T_ClassInfo_s20  = C_ClassInfo_s20 {
                                           inv_ClassInfo_s20 :: (T_ClassInfo_v19 )
                                           }
data T_ClassInfo_s21  = C_ClassInfo_s21
type T_ClassInfo_v19  = (T_ClassInfo_vIn19 ) -> (T_ClassInfo_vOut19 )
data T_ClassInfo_vIn19  = T_ClassInfo_vIn19 
data T_ClassInfo_vOut19  = T_ClassInfo_vOut19 (ClassInfo)
{-# NOINLINE sem_ClassInfo_Info #-}
sem_ClassInfo_Info :: (Word32) -> T_Traits  -> T_ClassInfo 
sem_ClassInfo_Info constructor_ traits_ = T_ClassInfo (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_ClassInfo_v19 
      v19 = \ (T_ClassInfo_vIn19 ) -> ( let
         _traitsX179 = Control.Monad.Identity.runIdentity (attach_T_Traits (traits_))
         (T_Traits_vOut178 _traitsIoutput) = inv_Traits_s179 _traitsX179 (T_Traits_vIn178 )
         _output = rule36 _traitsIoutput constructor_
         _lhsOoutput :: ClassInfo
         _lhsOoutput = rule37 _output
         __result_ = T_ClassInfo_vOut19 _lhsOoutput
         in __result_ )
     in C_ClassInfo_s20 v19
   {-# INLINE rule36 #-}
   rule36 = \ ((_traitsIoutput) :: Traits) constructor_ ->
     ClassInfo_Info constructor_ _traitsIoutput
   {-# INLINE rule37 #-}
   rule37 = \ _output ->
     _output

-- ClassInfos --------------------------------------------------
-- data
type ClassInfos  = [ ClassInfo ]

-- cata
{-# NOINLINE sem_ClassInfos #-}
sem_ClassInfos :: ClassInfos  -> T_ClassInfos 
sem_ClassInfos list = Prelude.foldr sem_ClassInfos_Cons sem_ClassInfos_Nil (Prelude.map sem_ClassInfo list)

-- semantic domain
newtype T_ClassInfos  = T_ClassInfos {
                                     attach_T_ClassInfos :: Identity (T_ClassInfos_s23 )
                                     }
newtype T_ClassInfos_s23  = C_ClassInfos_s23 {
                                             inv_ClassInfos_s23 :: (T_ClassInfos_v22 )
                                             }
data T_ClassInfos_s24  = C_ClassInfos_s24
type T_ClassInfos_v22  = (T_ClassInfos_vIn22 ) -> (T_ClassInfos_vOut22 )
data T_ClassInfos_vIn22  = T_ClassInfos_vIn22 
data T_ClassInfos_vOut22  = T_ClassInfos_vOut22 (ClassInfos)
{-# NOINLINE sem_ClassInfos_Cons #-}
sem_ClassInfos_Cons :: T_ClassInfo  -> T_ClassInfos  -> T_ClassInfos 
sem_ClassInfos_Cons hd_ tl_ = T_ClassInfos (return st23) where
   {-# NOINLINE st23 #-}
   st23 = let
      v22 :: T_ClassInfos_v22 
      v22 = \ (T_ClassInfos_vIn22 ) -> ( let
         _hdX20 = Control.Monad.Identity.runIdentity (attach_T_ClassInfo (hd_))
         _tlX23 = Control.Monad.Identity.runIdentity (attach_T_ClassInfos (tl_))
         (T_ClassInfo_vOut19 _hdIoutput) = inv_ClassInfo_s20 _hdX20 (T_ClassInfo_vIn19 )
         (T_ClassInfos_vOut22 _tlIoutput) = inv_ClassInfos_s23 _tlX23 (T_ClassInfos_vIn22 )
         _output = rule38 _hdIoutput _tlIoutput
         _lhsOoutput :: ClassInfos
         _lhsOoutput = rule39 _output
         __result_ = T_ClassInfos_vOut22 _lhsOoutput
         in __result_ )
     in C_ClassInfos_s23 v22
   {-# INLINE rule38 #-}
   rule38 = \ ((_hdIoutput) :: ClassInfo) ((_tlIoutput) :: ClassInfos) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule39 #-}
   rule39 = \ _output ->
     _output
{-# NOINLINE sem_ClassInfos_Nil #-}
sem_ClassInfos_Nil ::  T_ClassInfos 
sem_ClassInfos_Nil  = T_ClassInfos (return st23) where
   {-# NOINLINE st23 #-}
   st23 = let
      v22 :: T_ClassInfos_v22 
      v22 = \ (T_ClassInfos_vIn22 ) -> ( let
         _output = rule40  ()
         _lhsOoutput :: ClassInfos
         _lhsOoutput = rule41 _output
         __result_ = T_ClassInfos_vOut22 _lhsOoutput
         in __result_ )
     in C_ClassInfos_s23 v22
   {-# INLINE rule40 #-}
   rule40 = \  (_ :: ()) ->
     []
   {-# INLINE rule41 #-}
   rule41 = \ _output ->
     _output

-- DebugType ---------------------------------------------------
-- data
data DebugType 
  = DebugType_Local {}

-- cata
{-# INLINE sem_DebugType #-}
sem_DebugType :: DebugType  -> T_DebugType 
sem_DebugType ( DebugType_Local  ) = sem_DebugType_Local 

-- semantic domain
newtype T_DebugType  = T_DebugType {
                                   attach_T_DebugType :: Identity (T_DebugType_s26 )
                                   }
newtype T_DebugType_s26  = C_DebugType_s26 {
                                           inv_DebugType_s26 :: (T_DebugType_v25 )
                                           }
data T_DebugType_s27  = C_DebugType_s27
type T_DebugType_v25  = (T_DebugType_vIn25 ) -> (T_DebugType_vOut25 )
data T_DebugType_vIn25  = T_DebugType_vIn25 
data T_DebugType_vOut25  = T_DebugType_vOut25 (DebugType)
{-# NOINLINE sem_DebugType_Local #-}
sem_DebugType_Local ::  T_DebugType 
sem_DebugType_Local  = T_DebugType (return st26) where
   {-# NOINLINE st26 #-}
   st26 = let
      v25 :: T_DebugType_v25 
      v25 = \ (T_DebugType_vIn25 ) -> ( let
         _output = rule42  ()
         _lhsOoutput :: DebugType
         _lhsOoutput = rule43 _output
         __result_ = T_DebugType_vOut25 _lhsOoutput
         in __result_ )
     in C_DebugType_s26 v25
   {-# INLINE rule42 #-}
   rule42 = \  (_ :: ()) ->
     DebugType_Local
   {-# INLINE rule43 #-}
   rule43 = \ _output ->
     _output

-- Exception ---------------------------------------------------
-- data
data Exception 
  = Exception_Info {from_Exception_Info :: (Word32), to_Exception_Info :: (Word32), target_Exception_Info :: (Word32), tp_Exception_Info :: (Word32), name_Exception_Info :: (Word32)}

-- cata
{-# INLINE sem_Exception #-}
sem_Exception :: Exception  -> T_Exception 
sem_Exception ( Exception_Info from_ to_ target_ tp_ name_ ) = sem_Exception_Info from_ to_ target_ tp_ name_

-- semantic domain
newtype T_Exception  = T_Exception {
                                   attach_T_Exception :: Identity (T_Exception_s29 )
                                   }
newtype T_Exception_s29  = C_Exception_s29 {
                                           inv_Exception_s29 :: (T_Exception_v28 )
                                           }
data T_Exception_s30  = C_Exception_s30
type T_Exception_v28  = (T_Exception_vIn28 ) -> (T_Exception_vOut28 )
data T_Exception_vIn28  = T_Exception_vIn28 (Word32)
data T_Exception_vOut28  = T_Exception_vOut28 (Map BranchSource [Int]) (Exception) ([Int])
{-# NOINLINE sem_Exception_Info #-}
sem_Exception_Info :: (Word32) -> (Word32) -> (Word32) -> (Word32) -> (Word32) -> T_Exception 
sem_Exception_Info from_ to_ target_ tp_ name_ = T_Exception (return st29) where
   {-# NOINLINE st29 #-}
   st29 = let
      v28 :: T_Exception_v28 
      v28 = \ (T_Exception_vIn28 _lhsIindex) -> ( let
         _lhsOroots :: [Int]
         _lhsOroots = rule44 target_
         _source = rule45 _lhsIindex
         _lhsOgathSources :: Map BranchSource [Int]
         _lhsOgathSources = rule46 _source target_
         _output = rule47 from_ name_ target_ to_ tp_
         _lhsOoutput :: Exception
         _lhsOoutput = rule48 _output
         __result_ = T_Exception_vOut28 _lhsOgathSources _lhsOoutput _lhsOroots
         in __result_ )
     in C_Exception_s29 v28
   {-# INLINE rule44 #-}
   rule44 = \ target_ ->
                                    [fromIntegral target_]
   {-# INLINE rule45 #-}
   rule45 = \ ((_lhsIindex) :: Word32) ->
                      SourceException _lhsIindex
   {-# INLINE rule46 #-}
   rule46 = \ _source target_ ->
                      Map.singleton _source     [fromIntegral target_]
   {-# INLINE rule47 #-}
   rule47 = \ from_ name_ target_ to_ tp_ ->
     Exception_Info from_ to_ target_ tp_ name_
   {-# INLINE rule48 #-}
   rule48 = \ _output ->
     _output

-- Exceptions --------------------------------------------------
-- data
type Exceptions  = [ Exception ]

-- cata
{-# NOINLINE sem_Exceptions #-}
sem_Exceptions :: Exceptions  -> T_Exceptions 
sem_Exceptions list = Prelude.foldr sem_Exceptions_Cons sem_Exceptions_Nil (Prelude.map sem_Exception list)

-- semantic domain
newtype T_Exceptions  = T_Exceptions {
                                     attach_T_Exceptions :: Identity (T_Exceptions_s32 )
                                     }
newtype T_Exceptions_s32  = C_Exceptions_s32 {
                                             inv_Exceptions_s32 :: (T_Exceptions_v31 )
                                             }
data T_Exceptions_s33  = C_Exceptions_s33
type T_Exceptions_v31  = (T_Exceptions_vIn31 ) -> (T_Exceptions_vOut31 )
data T_Exceptions_vIn31  = T_Exceptions_vIn31 (Word32)
data T_Exceptions_vOut31  = T_Exceptions_vOut31 (Map BranchSource [Int]) (Exceptions) ([Int])
{-# NOINLINE sem_Exceptions_Cons #-}
sem_Exceptions_Cons :: T_Exception  -> T_Exceptions  -> T_Exceptions 
sem_Exceptions_Cons hd_ tl_ = T_Exceptions (return st32) where
   {-# NOINLINE st32 #-}
   st32 = let
      v31 :: T_Exceptions_v31 
      v31 = \ (T_Exceptions_vIn31 _lhsIindex) -> ( let
         _hdX29 = Control.Monad.Identity.runIdentity (attach_T_Exception (hd_))
         _tlX32 = Control.Monad.Identity.runIdentity (attach_T_Exceptions (tl_))
         (T_Exception_vOut28 _hdIgathSources _hdIoutput _hdIroots) = inv_Exception_s29 _hdX29 (T_Exception_vIn28 _hdOindex)
         (T_Exceptions_vOut31 _tlIgathSources _tlIoutput _tlIroots) = inv_Exceptions_s32 _tlX32 (T_Exceptions_vIn31 _tlOindex)
         _tlOindex = rule49 _lhsIindex
         _lhsOgathSources :: Map BranchSource [Int]
         _lhsOgathSources = rule50 _hdIgathSources _tlIgathSources
         _lhsOroots :: [Int]
         _lhsOroots = rule51 _hdIroots _tlIroots
         _output = rule52 _hdIoutput _tlIoutput
         _lhsOoutput :: Exceptions
         _lhsOoutput = rule53 _output
         _hdOindex = rule54 _lhsIindex
         __result_ = T_Exceptions_vOut31 _lhsOgathSources _lhsOoutput _lhsOroots
         in __result_ )
     in C_Exceptions_s32 v31
   {-# INLINE rule49 #-}
   rule49 = \ ((_lhsIindex) :: Word32) ->
                                    1 + _lhsIindex
   {-# INLINE rule50 #-}
   rule50 = \ ((_hdIgathSources) :: Map BranchSource [Int]) ((_tlIgathSources) :: Map BranchSource [Int]) ->
     _hdIgathSources `m'mappend` _tlIgathSources
   {-# INLINE rule51 #-}
   rule51 = \ ((_hdIroots) :: [Int]) ((_tlIroots) :: [Int]) ->
     _hdIroots ++ _tlIroots
   {-# INLINE rule52 #-}
   rule52 = \ ((_hdIoutput) :: Exception) ((_tlIoutput) :: Exceptions) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule53 #-}
   rule53 = \ _output ->
     _output
   {-# INLINE rule54 #-}
   rule54 = \ ((_lhsIindex) :: Word32) ->
     _lhsIindex
{-# NOINLINE sem_Exceptions_Nil #-}
sem_Exceptions_Nil ::  T_Exceptions 
sem_Exceptions_Nil  = T_Exceptions (return st32) where
   {-# NOINLINE st32 #-}
   st32 = let
      v31 :: T_Exceptions_v31 
      v31 = \ (T_Exceptions_vIn31 _lhsIindex) -> ( let
         _lhsOgathSources :: Map BranchSource [Int]
         _lhsOgathSources = rule55  ()
         _lhsOroots :: [Int]
         _lhsOroots = rule56  ()
         _output = rule57  ()
         _lhsOoutput :: Exceptions
         _lhsOoutput = rule58 _output
         __result_ = T_Exceptions_vOut31 _lhsOgathSources _lhsOoutput _lhsOroots
         in __result_ )
     in C_Exceptions_s32 v31
   {-# INLINE rule55 #-}
   rule55 = \  (_ :: ()) ->
     mempty
   {-# INLINE rule56 #-}
   rule56 = \  (_ :: ()) ->
     []
   {-# INLINE rule57 #-}
   rule57 = \  (_ :: ()) ->
     []
   {-# INLINE rule58 #-}
   rule58 = \ _output ->
     _output

-- InstanceFlag ------------------------------------------------
-- data
data InstanceFlag 
  = InstanceFlag_ClassSealed {}
  | InstanceFlag_ClassFinal {}
  | InstanceFlag_ClassInterface {}
  | InstanceFlag_ClassProtected {}

-- cata
{-# NOINLINE sem_InstanceFlag #-}
sem_InstanceFlag :: InstanceFlag  -> T_InstanceFlag 
sem_InstanceFlag ( InstanceFlag_ClassSealed  ) = sem_InstanceFlag_ClassSealed 
sem_InstanceFlag ( InstanceFlag_ClassFinal  ) = sem_InstanceFlag_ClassFinal 
sem_InstanceFlag ( InstanceFlag_ClassInterface  ) = sem_InstanceFlag_ClassInterface 
sem_InstanceFlag ( InstanceFlag_ClassProtected  ) = sem_InstanceFlag_ClassProtected 

-- semantic domain
newtype T_InstanceFlag  = T_InstanceFlag {
                                         attach_T_InstanceFlag :: Identity (T_InstanceFlag_s35 )
                                         }
newtype T_InstanceFlag_s35  = C_InstanceFlag_s35 {
                                                 inv_InstanceFlag_s35 :: (T_InstanceFlag_v34 )
                                                 }
data T_InstanceFlag_s36  = C_InstanceFlag_s36
type T_InstanceFlag_v34  = (T_InstanceFlag_vIn34 ) -> (T_InstanceFlag_vOut34 )
data T_InstanceFlag_vIn34  = T_InstanceFlag_vIn34 
data T_InstanceFlag_vOut34  = T_InstanceFlag_vOut34 (InstanceFlag)
{-# NOINLINE sem_InstanceFlag_ClassSealed #-}
sem_InstanceFlag_ClassSealed ::  T_InstanceFlag 
sem_InstanceFlag_ClassSealed  = T_InstanceFlag (return st35) where
   {-# NOINLINE st35 #-}
   st35 = let
      v34 :: T_InstanceFlag_v34 
      v34 = \ (T_InstanceFlag_vIn34 ) -> ( let
         _output = rule59  ()
         _lhsOoutput :: InstanceFlag
         _lhsOoutput = rule60 _output
         __result_ = T_InstanceFlag_vOut34 _lhsOoutput
         in __result_ )
     in C_InstanceFlag_s35 v34
   {-# INLINE rule59 #-}
   rule59 = \  (_ :: ()) ->
     InstanceFlag_ClassSealed
   {-# INLINE rule60 #-}
   rule60 = \ _output ->
     _output
{-# NOINLINE sem_InstanceFlag_ClassFinal #-}
sem_InstanceFlag_ClassFinal ::  T_InstanceFlag 
sem_InstanceFlag_ClassFinal  = T_InstanceFlag (return st35) where
   {-# NOINLINE st35 #-}
   st35 = let
      v34 :: T_InstanceFlag_v34 
      v34 = \ (T_InstanceFlag_vIn34 ) -> ( let
         _output = rule61  ()
         _lhsOoutput :: InstanceFlag
         _lhsOoutput = rule62 _output
         __result_ = T_InstanceFlag_vOut34 _lhsOoutput
         in __result_ )
     in C_InstanceFlag_s35 v34
   {-# INLINE rule61 #-}
   rule61 = \  (_ :: ()) ->
     InstanceFlag_ClassFinal
   {-# INLINE rule62 #-}
   rule62 = \ _output ->
     _output
{-# NOINLINE sem_InstanceFlag_ClassInterface #-}
sem_InstanceFlag_ClassInterface ::  T_InstanceFlag 
sem_InstanceFlag_ClassInterface  = T_InstanceFlag (return st35) where
   {-# NOINLINE st35 #-}
   st35 = let
      v34 :: T_InstanceFlag_v34 
      v34 = \ (T_InstanceFlag_vIn34 ) -> ( let
         _output = rule63  ()
         _lhsOoutput :: InstanceFlag
         _lhsOoutput = rule64 _output
         __result_ = T_InstanceFlag_vOut34 _lhsOoutput
         in __result_ )
     in C_InstanceFlag_s35 v34
   {-# INLINE rule63 #-}
   rule63 = \  (_ :: ()) ->
     InstanceFlag_ClassInterface
   {-# INLINE rule64 #-}
   rule64 = \ _output ->
     _output
{-# NOINLINE sem_InstanceFlag_ClassProtected #-}
sem_InstanceFlag_ClassProtected ::  T_InstanceFlag 
sem_InstanceFlag_ClassProtected  = T_InstanceFlag (return st35) where
   {-# NOINLINE st35 #-}
   st35 = let
      v34 :: T_InstanceFlag_v34 
      v34 = \ (T_InstanceFlag_vIn34 ) -> ( let
         _output = rule65  ()
         _lhsOoutput :: InstanceFlag
         _lhsOoutput = rule66 _output
         __result_ = T_InstanceFlag_vOut34 _lhsOoutput
         in __result_ )
     in C_InstanceFlag_s35 v34
   {-# INLINE rule65 #-}
   rule65 = \  (_ :: ()) ->
     InstanceFlag_ClassProtected
   {-# INLINE rule66 #-}
   rule66 = \ _output ->
     _output

-- InstanceFlags -----------------------------------------------
-- data
type InstanceFlags  = [ InstanceFlag ]

-- cata
{-# NOINLINE sem_InstanceFlags #-}
sem_InstanceFlags :: InstanceFlags  -> T_InstanceFlags 
sem_InstanceFlags list = Prelude.foldr sem_InstanceFlags_Cons sem_InstanceFlags_Nil (Prelude.map sem_InstanceFlag list)

-- semantic domain
newtype T_InstanceFlags  = T_InstanceFlags {
                                           attach_T_InstanceFlags :: Identity (T_InstanceFlags_s38 )
                                           }
newtype T_InstanceFlags_s38  = C_InstanceFlags_s38 {
                                                   inv_InstanceFlags_s38 :: (T_InstanceFlags_v37 )
                                                   }
data T_InstanceFlags_s39  = C_InstanceFlags_s39
type T_InstanceFlags_v37  = (T_InstanceFlags_vIn37 ) -> (T_InstanceFlags_vOut37 )
data T_InstanceFlags_vIn37  = T_InstanceFlags_vIn37 
data T_InstanceFlags_vOut37  = T_InstanceFlags_vOut37 (InstanceFlags)
{-# NOINLINE sem_InstanceFlags_Cons #-}
sem_InstanceFlags_Cons :: T_InstanceFlag  -> T_InstanceFlags  -> T_InstanceFlags 
sem_InstanceFlags_Cons hd_ tl_ = T_InstanceFlags (return st38) where
   {-# NOINLINE st38 #-}
   st38 = let
      v37 :: T_InstanceFlags_v37 
      v37 = \ (T_InstanceFlags_vIn37 ) -> ( let
         _hdX35 = Control.Monad.Identity.runIdentity (attach_T_InstanceFlag (hd_))
         _tlX38 = Control.Monad.Identity.runIdentity (attach_T_InstanceFlags (tl_))
         (T_InstanceFlag_vOut34 _hdIoutput) = inv_InstanceFlag_s35 _hdX35 (T_InstanceFlag_vIn34 )
         (T_InstanceFlags_vOut37 _tlIoutput) = inv_InstanceFlags_s38 _tlX38 (T_InstanceFlags_vIn37 )
         _output = rule67 _hdIoutput _tlIoutput
         _lhsOoutput :: InstanceFlags
         _lhsOoutput = rule68 _output
         __result_ = T_InstanceFlags_vOut37 _lhsOoutput
         in __result_ )
     in C_InstanceFlags_s38 v37
   {-# INLINE rule67 #-}
   rule67 = \ ((_hdIoutput) :: InstanceFlag) ((_tlIoutput) :: InstanceFlags) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule68 #-}
   rule68 = \ _output ->
     _output
{-# NOINLINE sem_InstanceFlags_Nil #-}
sem_InstanceFlags_Nil ::  T_InstanceFlags 
sem_InstanceFlags_Nil  = T_InstanceFlags (return st38) where
   {-# NOINLINE st38 #-}
   st38 = let
      v37 :: T_InstanceFlags_v37 
      v37 = \ (T_InstanceFlags_vIn37 ) -> ( let
         _output = rule69  ()
         _lhsOoutput :: InstanceFlags
         _lhsOoutput = rule70 _output
         __result_ = T_InstanceFlags_vOut37 _lhsOoutput
         in __result_ )
     in C_InstanceFlags_s38 v37
   {-# INLINE rule69 #-}
   rule69 = \  (_ :: ()) ->
     []
   {-# INLINE rule70 #-}
   rule70 = \ _output ->
     _output

-- InstanceInfo ------------------------------------------------
-- data
data InstanceInfo 
  = InstanceInfo_Info {name_InstanceInfo_Info :: (Word32), super_InstanceInfo_Info :: (Word32), flags_InstanceInfo_Info :: (InstanceFlags), protectedNs_InstanceInfo_Info :: (Word32), interfaces_InstanceInfo_Info :: (Interfaces), constructor_InstanceInfo_Info :: (Word32), traits_InstanceInfo_Info :: (Traits)}

-- cata
{-# INLINE sem_InstanceInfo #-}
sem_InstanceInfo :: InstanceInfo  -> T_InstanceInfo 
sem_InstanceInfo ( InstanceInfo_Info name_ super_ flags_ protectedNs_ interfaces_ constructor_ traits_ ) = sem_InstanceInfo_Info name_ super_ ( sem_InstanceFlags flags_ ) protectedNs_ ( sem_Interfaces interfaces_ ) constructor_ ( sem_Traits traits_ )

-- semantic domain
newtype T_InstanceInfo  = T_InstanceInfo {
                                         attach_T_InstanceInfo :: Identity (T_InstanceInfo_s41 )
                                         }
newtype T_InstanceInfo_s41  = C_InstanceInfo_s41 {
                                                 inv_InstanceInfo_s41 :: (T_InstanceInfo_v40 )
                                                 }
data T_InstanceInfo_s42  = C_InstanceInfo_s42
type T_InstanceInfo_v40  = (T_InstanceInfo_vIn40 ) -> (T_InstanceInfo_vOut40 )
data T_InstanceInfo_vIn40  = T_InstanceInfo_vIn40 
data T_InstanceInfo_vOut40  = T_InstanceInfo_vOut40 (InstanceInfo)
{-# NOINLINE sem_InstanceInfo_Info #-}
sem_InstanceInfo_Info :: (Word32) -> (Word32) -> T_InstanceFlags  -> (Word32) -> T_Interfaces  -> (Word32) -> T_Traits  -> T_InstanceInfo 
sem_InstanceInfo_Info name_ super_ flags_ protectedNs_ interfaces_ constructor_ traits_ = T_InstanceInfo (return st41) where
   {-# NOINLINE st41 #-}
   st41 = let
      v40 :: T_InstanceInfo_v40 
      v40 = \ (T_InstanceInfo_vIn40 ) -> ( let
         _flagsX38 = Control.Monad.Identity.runIdentity (attach_T_InstanceFlags (flags_))
         _interfacesX56 = Control.Monad.Identity.runIdentity (attach_T_Interfaces (interfaces_))
         _traitsX179 = Control.Monad.Identity.runIdentity (attach_T_Traits (traits_))
         (T_InstanceFlags_vOut37 _flagsIoutput) = inv_InstanceFlags_s38 _flagsX38 (T_InstanceFlags_vIn37 )
         (T_Interfaces_vOut55 _interfacesIoutput) = inv_Interfaces_s56 _interfacesX56 (T_Interfaces_vIn55 )
         (T_Traits_vOut178 _traitsIoutput) = inv_Traits_s179 _traitsX179 (T_Traits_vIn178 )
         _output = rule71 _flagsIoutput _interfacesIoutput _traitsIoutput constructor_ name_ protectedNs_ super_
         _lhsOoutput :: InstanceInfo
         _lhsOoutput = rule72 _output
         __result_ = T_InstanceInfo_vOut40 _lhsOoutput
         in __result_ )
     in C_InstanceInfo_s41 v40
   {-# INLINE rule71 #-}
   rule71 = \ ((_flagsIoutput) :: InstanceFlags) ((_interfacesIoutput) :: Interfaces) ((_traitsIoutput) :: Traits) constructor_ name_ protectedNs_ super_ ->
     InstanceInfo_Info name_ super_ _flagsIoutput protectedNs_ _interfacesIoutput constructor_ _traitsIoutput
   {-# INLINE rule72 #-}
   rule72 = \ _output ->
     _output

-- InstanceInfos -----------------------------------------------
-- data
type InstanceInfos  = [ InstanceInfo ]

-- cata
{-# NOINLINE sem_InstanceInfos #-}
sem_InstanceInfos :: InstanceInfos  -> T_InstanceInfos 
sem_InstanceInfos list = Prelude.foldr sem_InstanceInfos_Cons sem_InstanceInfos_Nil (Prelude.map sem_InstanceInfo list)

-- semantic domain
newtype T_InstanceInfos  = T_InstanceInfos {
                                           attach_T_InstanceInfos :: Identity (T_InstanceInfos_s44 )
                                           }
newtype T_InstanceInfos_s44  = C_InstanceInfos_s44 {
                                                   inv_InstanceInfos_s44 :: (T_InstanceInfos_v43 )
                                                   }
data T_InstanceInfos_s45  = C_InstanceInfos_s45
type T_InstanceInfos_v43  = (T_InstanceInfos_vIn43 ) -> (T_InstanceInfos_vOut43 )
data T_InstanceInfos_vIn43  = T_InstanceInfos_vIn43 
data T_InstanceInfos_vOut43  = T_InstanceInfos_vOut43 (InstanceInfos)
{-# NOINLINE sem_InstanceInfos_Cons #-}
sem_InstanceInfos_Cons :: T_InstanceInfo  -> T_InstanceInfos  -> T_InstanceInfos 
sem_InstanceInfos_Cons hd_ tl_ = T_InstanceInfos (return st44) where
   {-# NOINLINE st44 #-}
   st44 = let
      v43 :: T_InstanceInfos_v43 
      v43 = \ (T_InstanceInfos_vIn43 ) -> ( let
         _hdX41 = Control.Monad.Identity.runIdentity (attach_T_InstanceInfo (hd_))
         _tlX44 = Control.Monad.Identity.runIdentity (attach_T_InstanceInfos (tl_))
         (T_InstanceInfo_vOut40 _hdIoutput) = inv_InstanceInfo_s41 _hdX41 (T_InstanceInfo_vIn40 )
         (T_InstanceInfos_vOut43 _tlIoutput) = inv_InstanceInfos_s44 _tlX44 (T_InstanceInfos_vIn43 )
         _output = rule73 _hdIoutput _tlIoutput
         _lhsOoutput :: InstanceInfos
         _lhsOoutput = rule74 _output
         __result_ = T_InstanceInfos_vOut43 _lhsOoutput
         in __result_ )
     in C_InstanceInfos_s44 v43
   {-# INLINE rule73 #-}
   rule73 = \ ((_hdIoutput) :: InstanceInfo) ((_tlIoutput) :: InstanceInfos) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule74 #-}
   rule74 = \ _output ->
     _output
{-# NOINLINE sem_InstanceInfos_Nil #-}
sem_InstanceInfos_Nil ::  T_InstanceInfos 
sem_InstanceInfos_Nil  = T_InstanceInfos (return st44) where
   {-# NOINLINE st44 #-}
   st44 = let
      v43 :: T_InstanceInfos_v43 
      v43 = \ (T_InstanceInfos_vIn43 ) -> ( let
         _output = rule75  ()
         _lhsOoutput :: InstanceInfos
         _lhsOoutput = rule76 _output
         __result_ = T_InstanceInfos_vOut43 _lhsOoutput
         in __result_ )
     in C_InstanceInfos_s44 v43
   {-# INLINE rule75 #-}
   rule75 = \  (_ :: ()) ->
     []
   {-# INLINE rule76 #-}
   rule76 = \ _output ->
     _output

-- Instruction -------------------------------------------------
-- data
data Instruction 
  = Instruction_Add {}
  | Instruction_Add_i {}
  | Instruction_Add_d {}
  | Instruction_ApplyType {argCount_Instruction_ApplyType :: (Word32)}
  | Instruction_AsType {name_Instruction_AsType :: (Word32)}
  | Instruction_AsTypeLate {}
  | Instruction_Breakpoint {}
  | Instruction_BreakLine {line_Instruction_BreakLine :: (Word32)}
  | Instruction_BitAnd {}
  | Instruction_BitNot {}
  | Instruction_BitOr {}
  | Instruction_BitXor {}
  | Instruction_Call {argCount_Instruction_Call :: (Word32)}
  | Instruction_CallInterface {name_Instruction_CallInterface :: (Word32), argCount_Instruction_CallInterface :: (Word32)}
  | Instruction_CallMethod {index_Instruction_CallMethod :: (Word32), argCount_Instruction_CallMethod :: (Word32)}
  | Instruction_CallProp {name_Instruction_CallProp :: (Word32), argCount_Instruction_CallProp :: (Word32)}
  | Instruction_CallPropLex {name_Instruction_CallPropLex :: (Word32), argCount_Instruction_CallPropLex :: (Word32)}
  | Instruction_CallPropVoid {name_Instruction_CallPropVoid :: (Word32), argCount_Instruction_CallPropVoid :: (Word32)}
  | Instruction_CallStatic {method_Instruction_CallStatic :: (Word32), argCount_Instruction_CallStatic :: (Word32)}
  | Instruction_CallSuper {name_Instruction_CallSuper :: (Word32), argCount_Instruction_CallSuper :: (Word32)}
  | Instruction_CallSuperId {}
  | Instruction_CallSuperVoid {name_Instruction_CallSuperVoid :: (Word32), argCount_Instruction_CallSuperVoid :: (Word32)}
  | Instruction_CheckFilter {}
  | Instruction_Coerce {name_Instruction_Coerce :: (Word32)}
  | Instruction_Coerce_a {}
  | Instruction_Coerce_b {}
  | Instruction_Coerce_d {}
  | Instruction_Coerce_i {}
  | Instruction_Coerce_o {}
  | Instruction_Coerce_s {}
  | Instruction_Coerce_u {}
  | Instruction_Concat {}
  | Instruction_Construct {argCount_Instruction_Construct :: (Word32)}
  | Instruction_ConstructProp {name_Instruction_ConstructProp :: (Word32), argCount_Instruction_ConstructProp :: (Word32)}
  | Instruction_ConstructSuper {argCount_Instruction_ConstructSuper :: (Word32)}
  | Instruction_Convert_b {}
  | Instruction_Convert_i {}
  | Instruction_Convert_d {}
  | Instruction_Convert_o {}
  | Instruction_Convert_u {}
  | Instruction_Convert_s {}
  | Instruction_Debug {tp_Instruction_Debug :: (DebugType), name_Instruction_Debug :: (Word32), reg_Instruction_Debug :: (Word8), extra_Instruction_Debug :: (Word32)}
  | Instruction_DebugFile {name_Instruction_DebugFile :: (Word32)}
  | Instruction_DebugLine {line_Instruction_DebugLine :: (Word32)}
  | Instruction_DecLocal {reg_Instruction_DecLocal :: (Word32)}
  | Instruction_DecLocal_i {reg_Instruction_DecLocal_i :: (Word32)}
  | Instruction_Decrement {}
  | Instruction_Decrement_i {}
  | Instruction_DeleteProperty {name_Instruction_DeleteProperty :: (Word32)}
  | Instruction_DeletePropertyLate {}
  | Instruction_Divide {}
  | Instruction_Dup {}
  | Instruction_Dxns {name_Instruction_Dxns :: (Word32)}
  | Instruction_DxnsLate {}
  | Instruction_Equals {}
  | Instruction_EscXAttr {}
  | Instruction_EscXElem {}
  | Instruction_FindDef {name_Instruction_FindDef :: (Word32)}
  | Instruction_FindPropertyGlobalStrict {name_Instruction_FindPropertyGlobalStrict :: (Word32)}
  | Instruction_FindPropertyGlobal {name_Instruction_FindPropertyGlobal :: (Word32)}
  | Instruction_FindProperty {name_Instruction_FindProperty :: (Word32)}
  | Instruction_FindPropStrict {name_Instruction_FindPropStrict :: (Word32)}
  | Instruction_GetDescendants {name_Instruction_GetDescendants :: (Word32)}
  | Instruction_GetGlobalScope {}
  | Instruction_GetGlobalSlot {slot_Instruction_GetGlobalSlot :: (Word32)}
  | Instruction_GetLex {name_Instruction_GetLex :: (Word32)}
  | Instruction_GetLocal {reg_Instruction_GetLocal :: (Word32)}
  | Instruction_GetLocal0 {}
  | Instruction_GetLocal1 {}
  | Instruction_GetLocal2 {}
  | Instruction_GetLocal3 {}
  | Instruction_GetOuterScope {name_Instruction_GetOuterScope :: (Word32)}
  | Instruction_GetProperty {name_Instruction_GetProperty :: (Word32)}
  | Instruction_GetScopeObject {index_Instruction_GetScopeObject :: (Word8)}
  | Instruction_GetSlot {slot_Instruction_GetSlot :: (Word32)}
  | Instruction_GetSuper {name_Instruction_GetSuper :: (Word32)}
  | Instruction_GreaterEquals {}
  | Instruction_GreaterThan {}
  | Instruction_HasNext {}
  | Instruction_HasNext2 {objectReg_Instruction_HasNext2 :: (Word32), indexReg_Instruction_HasNext2 :: (Word32)}
  | Instruction_IfEq {offset_Instruction_IfEq :: (Word32)}
  | Instruction_IfFalse {offset_Instruction_IfFalse :: (Word32)}
  | Instruction_IfGe {offset_Instruction_IfGe :: (Word32)}
  | Instruction_IfGt {offset_Instruction_IfGt :: (Word32)}
  | Instruction_IfLe {offset_Instruction_IfLe :: (Word32)}
  | Instruction_IfLt {offset_Instruction_IfLt :: (Word32)}
  | Instruction_IfNGe {offset_Instruction_IfNGe :: (Word32)}
  | Instruction_IfNGt {offset_Instruction_IfNGt :: (Word32)}
  | Instruction_IfNLe {offset_Instruction_IfNLe :: (Word32)}
  | Instruction_IfNLt {offset_Instruction_IfNLt :: (Word32)}
  | Instruction_IfNe {offset_Instruction_IfNe :: (Word32)}
  | Instruction_IfStrictEq {offset_Instruction_IfStrictEq :: (Word32)}
  | Instruction_IfStrictNe {offset_Instruction_IfStrictNe :: (Word32)}
  | Instruction_IfTrue {offset_Instruction_IfTrue :: (Word32)}
  | Instruction_In {}
  | Instruction_IncLocal {reg_Instruction_IncLocal :: (Word32)}
  | Instruction_IncLocal_i {reg_Instruction_IncLocal_i :: (Word32)}
  | Instruction_Increment {}
  | Instruction_Increment_i {}
  | Instruction_InitProperty {name_Instruction_InitProperty :: (Word32)}
  | Instruction_InstanceOf {}
  | Instruction_IsType {name_Instruction_IsType :: (Word32)}
  | Instruction_IsTypeLate {}
  | Instruction_Jump {offset_Instruction_Jump :: (Word32)}
  | Instruction_Kill {reg_Instruction_Kill :: (Word32)}
  | Instruction_Label {}
  | Instruction_LessEquals {}
  | Instruction_LessThan {}
  | Instruction_LoadFloat32 {}
  | Instruction_LoadFloat64 {}
  | Instruction_LoadIndirect8 {}
  | Instruction_LoadIndirect16 {}
  | Instruction_LoadIndirect32 {}
  | Instruction_LookupSwitch {defaultOffset_Instruction_LookupSwitch :: (Word32), caseOffsets_Instruction_LookupSwitch :: (CaseOffsets)}
  | Instruction_Lshift {}
  | Instruction_Modulo {}
  | Instruction_Multiply {}
  | Instruction_Multiply_i {}
  | Instruction_Negate {}
  | Instruction_Negate_i {}
  | Instruction_NewActivation {}
  | Instruction_NewArray {argCount_Instruction_NewArray :: (Word32)}
  | Instruction_NewCatch {exception_Instruction_NewCatch :: (Word32)}
  | Instruction_NewClass {class_Instruction_NewClass :: (Word32)}
  | Instruction_NewFunction {method_Instruction_NewFunction :: (Word32)}
  | Instruction_NewObject {argCount_Instruction_NewObject :: (Word32)}
  | Instruction_NextName {}
  | Instruction_NextValue {}
  | Instruction_Nop {}
  | Instruction_Not {}
  | Instruction_Pop {}
  | Instruction_PopScope {}
  | Instruction_PushByte {val_Instruction_PushByte :: (Word8)}
  | Instruction_PushDouble {name_Instruction_PushDouble :: (Word32)}
  | Instruction_PushFalse {}
  | Instruction_PushInt {name_Instruction_PushInt :: (Word32)}
  | Instruction_PushNamespace {name_Instruction_PushNamespace :: (Word32)}
  | Instruction_PushNaN {}
  | Instruction_PushNull {}
  | Instruction_PushScope {}
  | Instruction_PushShort {val_Instruction_PushShort :: (Word32)}
  | Instruction_PushString {name_Instruction_PushString :: (Word32)}
  | Instruction_PushTrue {}
  | Instruction_PushUInt {name_Instruction_PushUInt :: (Word32)}
  | Instruction_PushUndefined {}
  | Instruction_PushWith {}
  | Instruction_ReturnValue {}
  | Instruction_ReturnVoid {}
  | Instruction_Rshift {}
  | Instruction_SetLocal {reg_Instruction_SetLocal :: (Word32)}
  | Instruction_SetLocal0 {}
  | Instruction_SetLocal1 {}
  | Instruction_SetLocal2 {}
  | Instruction_SetLocal3 {}
  | Instruction_SetGlobalSlot {slot_Instruction_SetGlobalSlot :: (Word32)}
  | Instruction_SetProperty {name_Instruction_SetProperty :: (Word32)}
  | Instruction_SetPropertyLate {}
  | Instruction_SetSlot {slot_Instruction_SetSlot :: (Word32)}
  | Instruction_SetSuper {name_Instruction_SetSuper :: (Word32)}
  | Instruction_SignExtend1 {}
  | Instruction_SignExtend8 {}
  | Instruction_SignExtend16 {}
  | Instruction_StoreFloat32 {}
  | Instruction_StoreFloat64 {}
  | Instruction_StoreIndirect32 {}
  | Instruction_StoreIndirect16 {}
  | Instruction_StoreIndirect8 {}
  | Instruction_StrictEquals {}
  | Instruction_Substract {}
  | Instruction_Substract_i {}
  | Instruction_Swap {}
  | Instruction_Throw {}
  | Instruction_Timestamp {}
  | Instruction_TypeOf {}
  | Instruction_Urshift {}
  | Instruction_Virtual {vid_Instruction_Virtual :: (Int), kind_Instruction_Virtual :: (VirtKind)}

-- cata
{-# NOINLINE sem_Instruction #-}
sem_Instruction :: Instruction  -> T_Instruction 
sem_Instruction ( Instruction_Add  ) = sem_Instruction_Add 
sem_Instruction ( Instruction_Add_i  ) = sem_Instruction_Add_i 
sem_Instruction ( Instruction_Add_d  ) = sem_Instruction_Add_d 
sem_Instruction ( Instruction_ApplyType argCount_ ) = sem_Instruction_ApplyType argCount_
sem_Instruction ( Instruction_AsType name_ ) = sem_Instruction_AsType name_
sem_Instruction ( Instruction_AsTypeLate  ) = sem_Instruction_AsTypeLate 
sem_Instruction ( Instruction_Breakpoint  ) = sem_Instruction_Breakpoint 
sem_Instruction ( Instruction_BreakLine line_ ) = sem_Instruction_BreakLine line_
sem_Instruction ( Instruction_BitAnd  ) = sem_Instruction_BitAnd 
sem_Instruction ( Instruction_BitNot  ) = sem_Instruction_BitNot 
sem_Instruction ( Instruction_BitOr  ) = sem_Instruction_BitOr 
sem_Instruction ( Instruction_BitXor  ) = sem_Instruction_BitXor 
sem_Instruction ( Instruction_Call argCount_ ) = sem_Instruction_Call argCount_
sem_Instruction ( Instruction_CallInterface name_ argCount_ ) = sem_Instruction_CallInterface name_ argCount_
sem_Instruction ( Instruction_CallMethod index_ argCount_ ) = sem_Instruction_CallMethod index_ argCount_
sem_Instruction ( Instruction_CallProp name_ argCount_ ) = sem_Instruction_CallProp name_ argCount_
sem_Instruction ( Instruction_CallPropLex name_ argCount_ ) = sem_Instruction_CallPropLex name_ argCount_
sem_Instruction ( Instruction_CallPropVoid name_ argCount_ ) = sem_Instruction_CallPropVoid name_ argCount_
sem_Instruction ( Instruction_CallStatic method_ argCount_ ) = sem_Instruction_CallStatic method_ argCount_
sem_Instruction ( Instruction_CallSuper name_ argCount_ ) = sem_Instruction_CallSuper name_ argCount_
sem_Instruction ( Instruction_CallSuperId  ) = sem_Instruction_CallSuperId 
sem_Instruction ( Instruction_CallSuperVoid name_ argCount_ ) = sem_Instruction_CallSuperVoid name_ argCount_
sem_Instruction ( Instruction_CheckFilter  ) = sem_Instruction_CheckFilter 
sem_Instruction ( Instruction_Coerce name_ ) = sem_Instruction_Coerce name_
sem_Instruction ( Instruction_Coerce_a  ) = sem_Instruction_Coerce_a 
sem_Instruction ( Instruction_Coerce_b  ) = sem_Instruction_Coerce_b 
sem_Instruction ( Instruction_Coerce_d  ) = sem_Instruction_Coerce_d 
sem_Instruction ( Instruction_Coerce_i  ) = sem_Instruction_Coerce_i 
sem_Instruction ( Instruction_Coerce_o  ) = sem_Instruction_Coerce_o 
sem_Instruction ( Instruction_Coerce_s  ) = sem_Instruction_Coerce_s 
sem_Instruction ( Instruction_Coerce_u  ) = sem_Instruction_Coerce_u 
sem_Instruction ( Instruction_Concat  ) = sem_Instruction_Concat 
sem_Instruction ( Instruction_Construct argCount_ ) = sem_Instruction_Construct argCount_
sem_Instruction ( Instruction_ConstructProp name_ argCount_ ) = sem_Instruction_ConstructProp name_ argCount_
sem_Instruction ( Instruction_ConstructSuper argCount_ ) = sem_Instruction_ConstructSuper argCount_
sem_Instruction ( Instruction_Convert_b  ) = sem_Instruction_Convert_b 
sem_Instruction ( Instruction_Convert_i  ) = sem_Instruction_Convert_i 
sem_Instruction ( Instruction_Convert_d  ) = sem_Instruction_Convert_d 
sem_Instruction ( Instruction_Convert_o  ) = sem_Instruction_Convert_o 
sem_Instruction ( Instruction_Convert_u  ) = sem_Instruction_Convert_u 
sem_Instruction ( Instruction_Convert_s  ) = sem_Instruction_Convert_s 
sem_Instruction ( Instruction_Debug tp_ name_ reg_ extra_ ) = sem_Instruction_Debug ( sem_DebugType tp_ ) name_ reg_ extra_
sem_Instruction ( Instruction_DebugFile name_ ) = sem_Instruction_DebugFile name_
sem_Instruction ( Instruction_DebugLine line_ ) = sem_Instruction_DebugLine line_
sem_Instruction ( Instruction_DecLocal reg_ ) = sem_Instruction_DecLocal reg_
sem_Instruction ( Instruction_DecLocal_i reg_ ) = sem_Instruction_DecLocal_i reg_
sem_Instruction ( Instruction_Decrement  ) = sem_Instruction_Decrement 
sem_Instruction ( Instruction_Decrement_i  ) = sem_Instruction_Decrement_i 
sem_Instruction ( Instruction_DeleteProperty name_ ) = sem_Instruction_DeleteProperty name_
sem_Instruction ( Instruction_DeletePropertyLate  ) = sem_Instruction_DeletePropertyLate 
sem_Instruction ( Instruction_Divide  ) = sem_Instruction_Divide 
sem_Instruction ( Instruction_Dup  ) = sem_Instruction_Dup 
sem_Instruction ( Instruction_Dxns name_ ) = sem_Instruction_Dxns name_
sem_Instruction ( Instruction_DxnsLate  ) = sem_Instruction_DxnsLate 
sem_Instruction ( Instruction_Equals  ) = sem_Instruction_Equals 
sem_Instruction ( Instruction_EscXAttr  ) = sem_Instruction_EscXAttr 
sem_Instruction ( Instruction_EscXElem  ) = sem_Instruction_EscXElem 
sem_Instruction ( Instruction_FindDef name_ ) = sem_Instruction_FindDef name_
sem_Instruction ( Instruction_FindPropertyGlobalStrict name_ ) = sem_Instruction_FindPropertyGlobalStrict name_
sem_Instruction ( Instruction_FindPropertyGlobal name_ ) = sem_Instruction_FindPropertyGlobal name_
sem_Instruction ( Instruction_FindProperty name_ ) = sem_Instruction_FindProperty name_
sem_Instruction ( Instruction_FindPropStrict name_ ) = sem_Instruction_FindPropStrict name_
sem_Instruction ( Instruction_GetDescendants name_ ) = sem_Instruction_GetDescendants name_
sem_Instruction ( Instruction_GetGlobalScope  ) = sem_Instruction_GetGlobalScope 
sem_Instruction ( Instruction_GetGlobalSlot slot_ ) = sem_Instruction_GetGlobalSlot slot_
sem_Instruction ( Instruction_GetLex name_ ) = sem_Instruction_GetLex name_
sem_Instruction ( Instruction_GetLocal reg_ ) = sem_Instruction_GetLocal reg_
sem_Instruction ( Instruction_GetLocal0  ) = sem_Instruction_GetLocal0 
sem_Instruction ( Instruction_GetLocal1  ) = sem_Instruction_GetLocal1 
sem_Instruction ( Instruction_GetLocal2  ) = sem_Instruction_GetLocal2 
sem_Instruction ( Instruction_GetLocal3  ) = sem_Instruction_GetLocal3 
sem_Instruction ( Instruction_GetOuterScope name_ ) = sem_Instruction_GetOuterScope name_
sem_Instruction ( Instruction_GetProperty name_ ) = sem_Instruction_GetProperty name_
sem_Instruction ( Instruction_GetScopeObject index_ ) = sem_Instruction_GetScopeObject index_
sem_Instruction ( Instruction_GetSlot slot_ ) = sem_Instruction_GetSlot slot_
sem_Instruction ( Instruction_GetSuper name_ ) = sem_Instruction_GetSuper name_
sem_Instruction ( Instruction_GreaterEquals  ) = sem_Instruction_GreaterEquals 
sem_Instruction ( Instruction_GreaterThan  ) = sem_Instruction_GreaterThan 
sem_Instruction ( Instruction_HasNext  ) = sem_Instruction_HasNext 
sem_Instruction ( Instruction_HasNext2 objectReg_ indexReg_ ) = sem_Instruction_HasNext2 objectReg_ indexReg_
sem_Instruction ( Instruction_IfEq offset_ ) = sem_Instruction_IfEq offset_
sem_Instruction ( Instruction_IfFalse offset_ ) = sem_Instruction_IfFalse offset_
sem_Instruction ( Instruction_IfGe offset_ ) = sem_Instruction_IfGe offset_
sem_Instruction ( Instruction_IfGt offset_ ) = sem_Instruction_IfGt offset_
sem_Instruction ( Instruction_IfLe offset_ ) = sem_Instruction_IfLe offset_
sem_Instruction ( Instruction_IfLt offset_ ) = sem_Instruction_IfLt offset_
sem_Instruction ( Instruction_IfNGe offset_ ) = sem_Instruction_IfNGe offset_
sem_Instruction ( Instruction_IfNGt offset_ ) = sem_Instruction_IfNGt offset_
sem_Instruction ( Instruction_IfNLe offset_ ) = sem_Instruction_IfNLe offset_
sem_Instruction ( Instruction_IfNLt offset_ ) = sem_Instruction_IfNLt offset_
sem_Instruction ( Instruction_IfNe offset_ ) = sem_Instruction_IfNe offset_
sem_Instruction ( Instruction_IfStrictEq offset_ ) = sem_Instruction_IfStrictEq offset_
sem_Instruction ( Instruction_IfStrictNe offset_ ) = sem_Instruction_IfStrictNe offset_
sem_Instruction ( Instruction_IfTrue offset_ ) = sem_Instruction_IfTrue offset_
sem_Instruction ( Instruction_In  ) = sem_Instruction_In 
sem_Instruction ( Instruction_IncLocal reg_ ) = sem_Instruction_IncLocal reg_
sem_Instruction ( Instruction_IncLocal_i reg_ ) = sem_Instruction_IncLocal_i reg_
sem_Instruction ( Instruction_Increment  ) = sem_Instruction_Increment 
sem_Instruction ( Instruction_Increment_i  ) = sem_Instruction_Increment_i 
sem_Instruction ( Instruction_InitProperty name_ ) = sem_Instruction_InitProperty name_
sem_Instruction ( Instruction_InstanceOf  ) = sem_Instruction_InstanceOf 
sem_Instruction ( Instruction_IsType name_ ) = sem_Instruction_IsType name_
sem_Instruction ( Instruction_IsTypeLate  ) = sem_Instruction_IsTypeLate 
sem_Instruction ( Instruction_Jump offset_ ) = sem_Instruction_Jump offset_
sem_Instruction ( Instruction_Kill reg_ ) = sem_Instruction_Kill reg_
sem_Instruction ( Instruction_Label  ) = sem_Instruction_Label 
sem_Instruction ( Instruction_LessEquals  ) = sem_Instruction_LessEquals 
sem_Instruction ( Instruction_LessThan  ) = sem_Instruction_LessThan 
sem_Instruction ( Instruction_LoadFloat32  ) = sem_Instruction_LoadFloat32 
sem_Instruction ( Instruction_LoadFloat64  ) = sem_Instruction_LoadFloat64 
sem_Instruction ( Instruction_LoadIndirect8  ) = sem_Instruction_LoadIndirect8 
sem_Instruction ( Instruction_LoadIndirect16  ) = sem_Instruction_LoadIndirect16 
sem_Instruction ( Instruction_LoadIndirect32  ) = sem_Instruction_LoadIndirect32 
sem_Instruction ( Instruction_LookupSwitch defaultOffset_ caseOffsets_ ) = sem_Instruction_LookupSwitch defaultOffset_ ( sem_CaseOffsets caseOffsets_ )
sem_Instruction ( Instruction_Lshift  ) = sem_Instruction_Lshift 
sem_Instruction ( Instruction_Modulo  ) = sem_Instruction_Modulo 
sem_Instruction ( Instruction_Multiply  ) = sem_Instruction_Multiply 
sem_Instruction ( Instruction_Multiply_i  ) = sem_Instruction_Multiply_i 
sem_Instruction ( Instruction_Negate  ) = sem_Instruction_Negate 
sem_Instruction ( Instruction_Negate_i  ) = sem_Instruction_Negate_i 
sem_Instruction ( Instruction_NewActivation  ) = sem_Instruction_NewActivation 
sem_Instruction ( Instruction_NewArray argCount_ ) = sem_Instruction_NewArray argCount_
sem_Instruction ( Instruction_NewCatch exception_ ) = sem_Instruction_NewCatch exception_
sem_Instruction ( Instruction_NewClass class_ ) = sem_Instruction_NewClass class_
sem_Instruction ( Instruction_NewFunction method_ ) = sem_Instruction_NewFunction method_
sem_Instruction ( Instruction_NewObject argCount_ ) = sem_Instruction_NewObject argCount_
sem_Instruction ( Instruction_NextName  ) = sem_Instruction_NextName 
sem_Instruction ( Instruction_NextValue  ) = sem_Instruction_NextValue 
sem_Instruction ( Instruction_Nop  ) = sem_Instruction_Nop 
sem_Instruction ( Instruction_Not  ) = sem_Instruction_Not 
sem_Instruction ( Instruction_Pop  ) = sem_Instruction_Pop 
sem_Instruction ( Instruction_PopScope  ) = sem_Instruction_PopScope 
sem_Instruction ( Instruction_PushByte val_ ) = sem_Instruction_PushByte val_
sem_Instruction ( Instruction_PushDouble name_ ) = sem_Instruction_PushDouble name_
sem_Instruction ( Instruction_PushFalse  ) = sem_Instruction_PushFalse 
sem_Instruction ( Instruction_PushInt name_ ) = sem_Instruction_PushInt name_
sem_Instruction ( Instruction_PushNamespace name_ ) = sem_Instruction_PushNamespace name_
sem_Instruction ( Instruction_PushNaN  ) = sem_Instruction_PushNaN 
sem_Instruction ( Instruction_PushNull  ) = sem_Instruction_PushNull 
sem_Instruction ( Instruction_PushScope  ) = sem_Instruction_PushScope 
sem_Instruction ( Instruction_PushShort val_ ) = sem_Instruction_PushShort val_
sem_Instruction ( Instruction_PushString name_ ) = sem_Instruction_PushString name_
sem_Instruction ( Instruction_PushTrue  ) = sem_Instruction_PushTrue 
sem_Instruction ( Instruction_PushUInt name_ ) = sem_Instruction_PushUInt name_
sem_Instruction ( Instruction_PushUndefined  ) = sem_Instruction_PushUndefined 
sem_Instruction ( Instruction_PushWith  ) = sem_Instruction_PushWith 
sem_Instruction ( Instruction_ReturnValue  ) = sem_Instruction_ReturnValue 
sem_Instruction ( Instruction_ReturnVoid  ) = sem_Instruction_ReturnVoid 
sem_Instruction ( Instruction_Rshift  ) = sem_Instruction_Rshift 
sem_Instruction ( Instruction_SetLocal reg_ ) = sem_Instruction_SetLocal reg_
sem_Instruction ( Instruction_SetLocal0  ) = sem_Instruction_SetLocal0 
sem_Instruction ( Instruction_SetLocal1  ) = sem_Instruction_SetLocal1 
sem_Instruction ( Instruction_SetLocal2  ) = sem_Instruction_SetLocal2 
sem_Instruction ( Instruction_SetLocal3  ) = sem_Instruction_SetLocal3 
sem_Instruction ( Instruction_SetGlobalSlot slot_ ) = sem_Instruction_SetGlobalSlot slot_
sem_Instruction ( Instruction_SetProperty name_ ) = sem_Instruction_SetProperty name_
sem_Instruction ( Instruction_SetPropertyLate  ) = sem_Instruction_SetPropertyLate 
sem_Instruction ( Instruction_SetSlot slot_ ) = sem_Instruction_SetSlot slot_
sem_Instruction ( Instruction_SetSuper name_ ) = sem_Instruction_SetSuper name_
sem_Instruction ( Instruction_SignExtend1  ) = sem_Instruction_SignExtend1 
sem_Instruction ( Instruction_SignExtend8  ) = sem_Instruction_SignExtend8 
sem_Instruction ( Instruction_SignExtend16  ) = sem_Instruction_SignExtend16 
sem_Instruction ( Instruction_StoreFloat32  ) = sem_Instruction_StoreFloat32 
sem_Instruction ( Instruction_StoreFloat64  ) = sem_Instruction_StoreFloat64 
sem_Instruction ( Instruction_StoreIndirect32  ) = sem_Instruction_StoreIndirect32 
sem_Instruction ( Instruction_StoreIndirect16  ) = sem_Instruction_StoreIndirect16 
sem_Instruction ( Instruction_StoreIndirect8  ) = sem_Instruction_StoreIndirect8 
sem_Instruction ( Instruction_StrictEquals  ) = sem_Instruction_StrictEquals 
sem_Instruction ( Instruction_Substract  ) = sem_Instruction_Substract 
sem_Instruction ( Instruction_Substract_i  ) = sem_Instruction_Substract_i 
sem_Instruction ( Instruction_Swap  ) = sem_Instruction_Swap 
sem_Instruction ( Instruction_Throw  ) = sem_Instruction_Throw 
sem_Instruction ( Instruction_Timestamp  ) = sem_Instruction_Timestamp 
sem_Instruction ( Instruction_TypeOf  ) = sem_Instruction_TypeOf 
sem_Instruction ( Instruction_Urshift  ) = sem_Instruction_Urshift 
sem_Instruction ( Instruction_Virtual vid_ kind_ ) = sem_Instruction_Virtual vid_ ( sem_VirtKind kind_ )

-- semantic domain
newtype T_Instruction  = T_Instruction {
                                       attach_T_Instruction :: Identity (T_Instruction_s47 )
                                       }
newtype T_Instruction_s47  = C_Instruction_s47 {
                                               inv_Instruction_s47 :: (T_Instruction_v46 )
                                               }
data T_Instruction_s48  = C_Instruction_s48
type T_Instruction_v46  = (T_Instruction_vIn46 ) -> (T_Instruction_vOut46 )
data T_Instruction_vIn46  = T_Instruction_vIn46 (Maybe (ExceptionRef)) ([BranchSource])
data T_Instruction_vOut46  = T_Instruction_vOut46 (BranchingInfo) (Bool) (Instruction)
{-# NOINLINE sem_Instruction_Add #-}
sem_Instruction_Add ::  T_Instruction 
sem_Instruction_Add  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule77  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule78  ()
         _output = rule79  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule80 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule77 #-}
   rule77 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule78 #-}
   rule78 = \  (_ :: ()) ->
     False
   {-# INLINE rule79 #-}
   rule79 = \  (_ :: ()) ->
     Instruction_Add
   {-# INLINE rule80 #-}
   rule80 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Add_i #-}
sem_Instruction_Add_i ::  T_Instruction 
sem_Instruction_Add_i  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule81  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule82  ()
         _output = rule83  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule84 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule81 #-}
   rule81 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule82 #-}
   rule82 = \  (_ :: ()) ->
     False
   {-# INLINE rule83 #-}
   rule83 = \  (_ :: ()) ->
     Instruction_Add_i
   {-# INLINE rule84 #-}
   rule84 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Add_d #-}
sem_Instruction_Add_d ::  T_Instruction 
sem_Instruction_Add_d  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule85  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule86  ()
         _output = rule87  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule88 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule85 #-}
   rule85 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule86 #-}
   rule86 = \  (_ :: ()) ->
     False
   {-# INLINE rule87 #-}
   rule87 = \  (_ :: ()) ->
     Instruction_Add_d
   {-# INLINE rule88 #-}
   rule88 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_ApplyType #-}
sem_Instruction_ApplyType :: (Word32) -> T_Instruction 
sem_Instruction_ApplyType argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule89  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule90  ()
         _output = rule91 argCount_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule92 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule89 #-}
   rule89 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule90 #-}
   rule90 = \  (_ :: ()) ->
     False
   {-# INLINE rule91 #-}
   rule91 = \ argCount_ ->
     Instruction_ApplyType argCount_
   {-# INLINE rule92 #-}
   rule92 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_AsType #-}
sem_Instruction_AsType :: (Word32) -> T_Instruction 
sem_Instruction_AsType name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule93  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule94  ()
         _output = rule95 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule96 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule93 #-}
   rule93 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule94 #-}
   rule94 = \  (_ :: ()) ->
     False
   {-# INLINE rule95 #-}
   rule95 = \ name_ ->
     Instruction_AsType name_
   {-# INLINE rule96 #-}
   rule96 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_AsTypeLate #-}
sem_Instruction_AsTypeLate ::  T_Instruction 
sem_Instruction_AsTypeLate  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule97  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule98  ()
         _output = rule99  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule100 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule97 #-}
   rule97 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule98 #-}
   rule98 = \  (_ :: ()) ->
     False
   {-# INLINE rule99 #-}
   rule99 = \  (_ :: ()) ->
     Instruction_AsTypeLate
   {-# INLINE rule100 #-}
   rule100 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Breakpoint #-}
sem_Instruction_Breakpoint ::  T_Instruction 
sem_Instruction_Breakpoint  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule101  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule102  ()
         _output = rule103  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule104 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule101 #-}
   rule101 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule102 #-}
   rule102 = \  (_ :: ()) ->
     False
   {-# INLINE rule103 #-}
   rule103 = \  (_ :: ()) ->
     Instruction_Breakpoint
   {-# INLINE rule104 #-}
   rule104 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_BreakLine #-}
sem_Instruction_BreakLine :: (Word32) -> T_Instruction 
sem_Instruction_BreakLine line_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule105  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule106  ()
         _output = rule107 line_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule108 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule105 #-}
   rule105 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule106 #-}
   rule106 = \  (_ :: ()) ->
     False
   {-# INLINE rule107 #-}
   rule107 = \ line_ ->
     Instruction_BreakLine line_
   {-# INLINE rule108 #-}
   rule108 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_BitAnd #-}
sem_Instruction_BitAnd ::  T_Instruction 
sem_Instruction_BitAnd  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule109  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule110  ()
         _output = rule111  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule112 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule109 #-}
   rule109 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule110 #-}
   rule110 = \  (_ :: ()) ->
     False
   {-# INLINE rule111 #-}
   rule111 = \  (_ :: ()) ->
     Instruction_BitAnd
   {-# INLINE rule112 #-}
   rule112 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_BitNot #-}
sem_Instruction_BitNot ::  T_Instruction 
sem_Instruction_BitNot  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule113  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule114  ()
         _output = rule115  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule116 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule113 #-}
   rule113 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule114 #-}
   rule114 = \  (_ :: ()) ->
     False
   {-# INLINE rule115 #-}
   rule115 = \  (_ :: ()) ->
     Instruction_BitNot
   {-# INLINE rule116 #-}
   rule116 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_BitOr #-}
sem_Instruction_BitOr ::  T_Instruction 
sem_Instruction_BitOr  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule117  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule118  ()
         _output = rule119  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule120 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule117 #-}
   rule117 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule118 #-}
   rule118 = \  (_ :: ()) ->
     False
   {-# INLINE rule119 #-}
   rule119 = \  (_ :: ()) ->
     Instruction_BitOr
   {-# INLINE rule120 #-}
   rule120 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_BitXor #-}
sem_Instruction_BitXor ::  T_Instruction 
sem_Instruction_BitXor  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule121  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule122  ()
         _output = rule123  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule124 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule121 #-}
   rule121 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule122 #-}
   rule122 = \  (_ :: ()) ->
     False
   {-# INLINE rule123 #-}
   rule123 = \  (_ :: ()) ->
     Instruction_BitXor
   {-# INLINE rule124 #-}
   rule124 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Call #-}
sem_Instruction_Call :: (Word32) -> T_Instruction 
sem_Instruction_Call argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule125  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule126  ()
         _output = rule127 argCount_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule128 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule125 #-}
   rule125 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule126 #-}
   rule126 = \  (_ :: ()) ->
     False
   {-# INLINE rule127 #-}
   rule127 = \ argCount_ ->
     Instruction_Call argCount_
   {-# INLINE rule128 #-}
   rule128 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_CallInterface #-}
sem_Instruction_CallInterface :: (Word32) -> (Word32) -> T_Instruction 
sem_Instruction_CallInterface name_ argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule129  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule130  ()
         _output = rule131 argCount_ name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule132 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule129 #-}
   rule129 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule130 #-}
   rule130 = \  (_ :: ()) ->
     False
   {-# INLINE rule131 #-}
   rule131 = \ argCount_ name_ ->
     Instruction_CallInterface name_ argCount_
   {-# INLINE rule132 #-}
   rule132 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_CallMethod #-}
sem_Instruction_CallMethod :: (Word32) -> (Word32) -> T_Instruction 
sem_Instruction_CallMethod index_ argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule133  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule134  ()
         _output = rule135 argCount_ index_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule136 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule133 #-}
   rule133 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule134 #-}
   rule134 = \  (_ :: ()) ->
     False
   {-# INLINE rule135 #-}
   rule135 = \ argCount_ index_ ->
     Instruction_CallMethod index_ argCount_
   {-# INLINE rule136 #-}
   rule136 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_CallProp #-}
sem_Instruction_CallProp :: (Word32) -> (Word32) -> T_Instruction 
sem_Instruction_CallProp name_ argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule137  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule138  ()
         _output = rule139 argCount_ name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule140 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule137 #-}
   rule137 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule138 #-}
   rule138 = \  (_ :: ()) ->
     False
   {-# INLINE rule139 #-}
   rule139 = \ argCount_ name_ ->
     Instruction_CallProp name_ argCount_
   {-# INLINE rule140 #-}
   rule140 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_CallPropLex #-}
sem_Instruction_CallPropLex :: (Word32) -> (Word32) -> T_Instruction 
sem_Instruction_CallPropLex name_ argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule141  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule142  ()
         _output = rule143 argCount_ name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule144 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule141 #-}
   rule141 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule142 #-}
   rule142 = \  (_ :: ()) ->
     False
   {-# INLINE rule143 #-}
   rule143 = \ argCount_ name_ ->
     Instruction_CallPropLex name_ argCount_
   {-# INLINE rule144 #-}
   rule144 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_CallPropVoid #-}
sem_Instruction_CallPropVoid :: (Word32) -> (Word32) -> T_Instruction 
sem_Instruction_CallPropVoid name_ argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule145  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule146  ()
         _output = rule147 argCount_ name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule148 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule145 #-}
   rule145 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule146 #-}
   rule146 = \  (_ :: ()) ->
     False
   {-# INLINE rule147 #-}
   rule147 = \ argCount_ name_ ->
     Instruction_CallPropVoid name_ argCount_
   {-# INLINE rule148 #-}
   rule148 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_CallStatic #-}
sem_Instruction_CallStatic :: (Word32) -> (Word32) -> T_Instruction 
sem_Instruction_CallStatic method_ argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule149  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule150  ()
         _output = rule151 argCount_ method_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule152 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule149 #-}
   rule149 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule150 #-}
   rule150 = \  (_ :: ()) ->
     False
   {-# INLINE rule151 #-}
   rule151 = \ argCount_ method_ ->
     Instruction_CallStatic method_ argCount_
   {-# INLINE rule152 #-}
   rule152 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_CallSuper #-}
sem_Instruction_CallSuper :: (Word32) -> (Word32) -> T_Instruction 
sem_Instruction_CallSuper name_ argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule153  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule154  ()
         _output = rule155 argCount_ name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule156 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule153 #-}
   rule153 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule154 #-}
   rule154 = \  (_ :: ()) ->
     False
   {-# INLINE rule155 #-}
   rule155 = \ argCount_ name_ ->
     Instruction_CallSuper name_ argCount_
   {-# INLINE rule156 #-}
   rule156 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_CallSuperId #-}
sem_Instruction_CallSuperId ::  T_Instruction 
sem_Instruction_CallSuperId  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule157  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule158  ()
         _output = rule159  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule160 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule157 #-}
   rule157 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule158 #-}
   rule158 = \  (_ :: ()) ->
     False
   {-# INLINE rule159 #-}
   rule159 = \  (_ :: ()) ->
     Instruction_CallSuperId
   {-# INLINE rule160 #-}
   rule160 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_CallSuperVoid #-}
sem_Instruction_CallSuperVoid :: (Word32) -> (Word32) -> T_Instruction 
sem_Instruction_CallSuperVoid name_ argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule161  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule162  ()
         _output = rule163 argCount_ name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule164 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule161 #-}
   rule161 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule162 #-}
   rule162 = \  (_ :: ()) ->
     False
   {-# INLINE rule163 #-}
   rule163 = \ argCount_ name_ ->
     Instruction_CallSuperVoid name_ argCount_
   {-# INLINE rule164 #-}
   rule164 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_CheckFilter #-}
sem_Instruction_CheckFilter ::  T_Instruction 
sem_Instruction_CheckFilter  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule165  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule166  ()
         _output = rule167  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule168 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule165 #-}
   rule165 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule166 #-}
   rule166 = \  (_ :: ()) ->
     False
   {-# INLINE rule167 #-}
   rule167 = \  (_ :: ()) ->
     Instruction_CheckFilter
   {-# INLINE rule168 #-}
   rule168 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Coerce #-}
sem_Instruction_Coerce :: (Word32) -> T_Instruction 
sem_Instruction_Coerce name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule169  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule170  ()
         _output = rule171 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule172 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule169 #-}
   rule169 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule170 #-}
   rule170 = \  (_ :: ()) ->
     False
   {-# INLINE rule171 #-}
   rule171 = \ name_ ->
     Instruction_Coerce name_
   {-# INLINE rule172 #-}
   rule172 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Coerce_a #-}
sem_Instruction_Coerce_a ::  T_Instruction 
sem_Instruction_Coerce_a  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule173  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule174  ()
         _output = rule175  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule176 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule173 #-}
   rule173 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule174 #-}
   rule174 = \  (_ :: ()) ->
     False
   {-# INLINE rule175 #-}
   rule175 = \  (_ :: ()) ->
     Instruction_Coerce_a
   {-# INLINE rule176 #-}
   rule176 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Coerce_b #-}
sem_Instruction_Coerce_b ::  T_Instruction 
sem_Instruction_Coerce_b  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule177  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule178  ()
         _output = rule179  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule180 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule177 #-}
   rule177 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule178 #-}
   rule178 = \  (_ :: ()) ->
     False
   {-# INLINE rule179 #-}
   rule179 = \  (_ :: ()) ->
     Instruction_Coerce_b
   {-# INLINE rule180 #-}
   rule180 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Coerce_d #-}
sem_Instruction_Coerce_d ::  T_Instruction 
sem_Instruction_Coerce_d  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule181  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule182  ()
         _output = rule183  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule184 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule181 #-}
   rule181 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule182 #-}
   rule182 = \  (_ :: ()) ->
     False
   {-# INLINE rule183 #-}
   rule183 = \  (_ :: ()) ->
     Instruction_Coerce_d
   {-# INLINE rule184 #-}
   rule184 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Coerce_i #-}
sem_Instruction_Coerce_i ::  T_Instruction 
sem_Instruction_Coerce_i  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule185  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule186  ()
         _output = rule187  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule188 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule185 #-}
   rule185 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule186 #-}
   rule186 = \  (_ :: ()) ->
     False
   {-# INLINE rule187 #-}
   rule187 = \  (_ :: ()) ->
     Instruction_Coerce_i
   {-# INLINE rule188 #-}
   rule188 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Coerce_o #-}
sem_Instruction_Coerce_o ::  T_Instruction 
sem_Instruction_Coerce_o  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule189  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule190  ()
         _output = rule191  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule192 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule189 #-}
   rule189 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule190 #-}
   rule190 = \  (_ :: ()) ->
     False
   {-# INLINE rule191 #-}
   rule191 = \  (_ :: ()) ->
     Instruction_Coerce_o
   {-# INLINE rule192 #-}
   rule192 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Coerce_s #-}
sem_Instruction_Coerce_s ::  T_Instruction 
sem_Instruction_Coerce_s  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule193  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule194  ()
         _output = rule195  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule196 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule193 #-}
   rule193 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule194 #-}
   rule194 = \  (_ :: ()) ->
     False
   {-# INLINE rule195 #-}
   rule195 = \  (_ :: ()) ->
     Instruction_Coerce_s
   {-# INLINE rule196 #-}
   rule196 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Coerce_u #-}
sem_Instruction_Coerce_u ::  T_Instruction 
sem_Instruction_Coerce_u  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule197  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule198  ()
         _output = rule199  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule200 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule197 #-}
   rule197 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule198 #-}
   rule198 = \  (_ :: ()) ->
     False
   {-# INLINE rule199 #-}
   rule199 = \  (_ :: ()) ->
     Instruction_Coerce_u
   {-# INLINE rule200 #-}
   rule200 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Concat #-}
sem_Instruction_Concat ::  T_Instruction 
sem_Instruction_Concat  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule201  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule202  ()
         _output = rule203  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule204 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule201 #-}
   rule201 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule202 #-}
   rule202 = \  (_ :: ()) ->
     False
   {-# INLINE rule203 #-}
   rule203 = \  (_ :: ()) ->
     Instruction_Concat
   {-# INLINE rule204 #-}
   rule204 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Construct #-}
sem_Instruction_Construct :: (Word32) -> T_Instruction 
sem_Instruction_Construct argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule205  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule206  ()
         _output = rule207 argCount_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule208 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule205 #-}
   rule205 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule206 #-}
   rule206 = \  (_ :: ()) ->
     False
   {-# INLINE rule207 #-}
   rule207 = \ argCount_ ->
     Instruction_Construct argCount_
   {-# INLINE rule208 #-}
   rule208 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_ConstructProp #-}
sem_Instruction_ConstructProp :: (Word32) -> (Word32) -> T_Instruction 
sem_Instruction_ConstructProp name_ argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule209  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule210  ()
         _output = rule211 argCount_ name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule212 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule209 #-}
   rule209 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule210 #-}
   rule210 = \  (_ :: ()) ->
     False
   {-# INLINE rule211 #-}
   rule211 = \ argCount_ name_ ->
     Instruction_ConstructProp name_ argCount_
   {-# INLINE rule212 #-}
   rule212 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_ConstructSuper #-}
sem_Instruction_ConstructSuper :: (Word32) -> T_Instruction 
sem_Instruction_ConstructSuper argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule213  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule214  ()
         _output = rule215 argCount_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule216 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule213 #-}
   rule213 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule214 #-}
   rule214 = \  (_ :: ()) ->
     False
   {-# INLINE rule215 #-}
   rule215 = \ argCount_ ->
     Instruction_ConstructSuper argCount_
   {-# INLINE rule216 #-}
   rule216 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Convert_b #-}
sem_Instruction_Convert_b ::  T_Instruction 
sem_Instruction_Convert_b  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule217  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule218  ()
         _output = rule219  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule220 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule217 #-}
   rule217 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule218 #-}
   rule218 = \  (_ :: ()) ->
     False
   {-# INLINE rule219 #-}
   rule219 = \  (_ :: ()) ->
     Instruction_Convert_b
   {-# INLINE rule220 #-}
   rule220 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Convert_i #-}
sem_Instruction_Convert_i ::  T_Instruction 
sem_Instruction_Convert_i  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule221  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule222  ()
         _output = rule223  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule224 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule221 #-}
   rule221 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule222 #-}
   rule222 = \  (_ :: ()) ->
     False
   {-# INLINE rule223 #-}
   rule223 = \  (_ :: ()) ->
     Instruction_Convert_i
   {-# INLINE rule224 #-}
   rule224 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Convert_d #-}
sem_Instruction_Convert_d ::  T_Instruction 
sem_Instruction_Convert_d  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule225  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule226  ()
         _output = rule227  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule228 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule225 #-}
   rule225 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule226 #-}
   rule226 = \  (_ :: ()) ->
     False
   {-# INLINE rule227 #-}
   rule227 = \  (_ :: ()) ->
     Instruction_Convert_d
   {-# INLINE rule228 #-}
   rule228 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Convert_o #-}
sem_Instruction_Convert_o ::  T_Instruction 
sem_Instruction_Convert_o  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule229  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule230  ()
         _output = rule231  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule232 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule229 #-}
   rule229 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule230 #-}
   rule230 = \  (_ :: ()) ->
     False
   {-# INLINE rule231 #-}
   rule231 = \  (_ :: ()) ->
     Instruction_Convert_o
   {-# INLINE rule232 #-}
   rule232 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Convert_u #-}
sem_Instruction_Convert_u ::  T_Instruction 
sem_Instruction_Convert_u  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule233  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule234  ()
         _output = rule235  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule236 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule233 #-}
   rule233 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule234 #-}
   rule234 = \  (_ :: ()) ->
     False
   {-# INLINE rule235 #-}
   rule235 = \  (_ :: ()) ->
     Instruction_Convert_u
   {-# INLINE rule236 #-}
   rule236 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Convert_s #-}
sem_Instruction_Convert_s ::  T_Instruction 
sem_Instruction_Convert_s  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule237  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule238  ()
         _output = rule239  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule240 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule237 #-}
   rule237 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule238 #-}
   rule238 = \  (_ :: ()) ->
     False
   {-# INLINE rule239 #-}
   rule239 = \  (_ :: ()) ->
     Instruction_Convert_s
   {-# INLINE rule240 #-}
   rule240 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Debug #-}
sem_Instruction_Debug :: T_DebugType  -> (Word32) -> (Word8) -> (Word32) -> T_Instruction 
sem_Instruction_Debug tp_ name_ reg_ extra_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _tpX26 = Control.Monad.Identity.runIdentity (attach_T_DebugType (tp_))
         (T_DebugType_vOut25 _tpIoutput) = inv_DebugType_s26 _tpX26 (T_DebugType_vIn25 )
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule241  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule242  ()
         _output = rule243 _tpIoutput extra_ name_ reg_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule244 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule241 #-}
   rule241 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule242 #-}
   rule242 = \  (_ :: ()) ->
     False
   {-# INLINE rule243 #-}
   rule243 = \ ((_tpIoutput) :: DebugType) extra_ name_ reg_ ->
     Instruction_Debug _tpIoutput name_ reg_ extra_
   {-# INLINE rule244 #-}
   rule244 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_DebugFile #-}
sem_Instruction_DebugFile :: (Word32) -> T_Instruction 
sem_Instruction_DebugFile name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule245  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule246  ()
         _output = rule247 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule248 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule245 #-}
   rule245 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule246 #-}
   rule246 = \  (_ :: ()) ->
     False
   {-# INLINE rule247 #-}
   rule247 = \ name_ ->
     Instruction_DebugFile name_
   {-# INLINE rule248 #-}
   rule248 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_DebugLine #-}
sem_Instruction_DebugLine :: (Word32) -> T_Instruction 
sem_Instruction_DebugLine line_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule249  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule250  ()
         _output = rule251 line_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule252 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule249 #-}
   rule249 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule250 #-}
   rule250 = \  (_ :: ()) ->
     False
   {-# INLINE rule251 #-}
   rule251 = \ line_ ->
     Instruction_DebugLine line_
   {-# INLINE rule252 #-}
   rule252 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_DecLocal #-}
sem_Instruction_DecLocal :: (Word32) -> T_Instruction 
sem_Instruction_DecLocal reg_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule253  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule254  ()
         _output = rule255 reg_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule256 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule253 #-}
   rule253 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule254 #-}
   rule254 = \  (_ :: ()) ->
     False
   {-# INLINE rule255 #-}
   rule255 = \ reg_ ->
     Instruction_DecLocal reg_
   {-# INLINE rule256 #-}
   rule256 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_DecLocal_i #-}
sem_Instruction_DecLocal_i :: (Word32) -> T_Instruction 
sem_Instruction_DecLocal_i reg_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule257  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule258  ()
         _output = rule259 reg_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule260 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule257 #-}
   rule257 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule258 #-}
   rule258 = \  (_ :: ()) ->
     False
   {-# INLINE rule259 #-}
   rule259 = \ reg_ ->
     Instruction_DecLocal_i reg_
   {-# INLINE rule260 #-}
   rule260 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Decrement #-}
sem_Instruction_Decrement ::  T_Instruction 
sem_Instruction_Decrement  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule261  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule262  ()
         _output = rule263  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule264 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule261 #-}
   rule261 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule262 #-}
   rule262 = \  (_ :: ()) ->
     False
   {-# INLINE rule263 #-}
   rule263 = \  (_ :: ()) ->
     Instruction_Decrement
   {-# INLINE rule264 #-}
   rule264 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Decrement_i #-}
sem_Instruction_Decrement_i ::  T_Instruction 
sem_Instruction_Decrement_i  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule265  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule266  ()
         _output = rule267  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule268 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule265 #-}
   rule265 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule266 #-}
   rule266 = \  (_ :: ()) ->
     False
   {-# INLINE rule267 #-}
   rule267 = \  (_ :: ()) ->
     Instruction_Decrement_i
   {-# INLINE rule268 #-}
   rule268 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_DeleteProperty #-}
sem_Instruction_DeleteProperty :: (Word32) -> T_Instruction 
sem_Instruction_DeleteProperty name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule269  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule270  ()
         _output = rule271 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule272 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule269 #-}
   rule269 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule270 #-}
   rule270 = \  (_ :: ()) ->
     False
   {-# INLINE rule271 #-}
   rule271 = \ name_ ->
     Instruction_DeleteProperty name_
   {-# INLINE rule272 #-}
   rule272 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_DeletePropertyLate #-}
sem_Instruction_DeletePropertyLate ::  T_Instruction 
sem_Instruction_DeletePropertyLate  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule273  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule274  ()
         _output = rule275  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule276 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule273 #-}
   rule273 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule274 #-}
   rule274 = \  (_ :: ()) ->
     False
   {-# INLINE rule275 #-}
   rule275 = \  (_ :: ()) ->
     Instruction_DeletePropertyLate
   {-# INLINE rule276 #-}
   rule276 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Divide #-}
sem_Instruction_Divide ::  T_Instruction 
sem_Instruction_Divide  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule277  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule278  ()
         _output = rule279  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule280 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule277 #-}
   rule277 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule278 #-}
   rule278 = \  (_ :: ()) ->
     False
   {-# INLINE rule279 #-}
   rule279 = \  (_ :: ()) ->
     Instruction_Divide
   {-# INLINE rule280 #-}
   rule280 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Dup #-}
sem_Instruction_Dup ::  T_Instruction 
sem_Instruction_Dup  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule281  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule282  ()
         _output = rule283  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule284 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule281 #-}
   rule281 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule282 #-}
   rule282 = \  (_ :: ()) ->
     False
   {-# INLINE rule283 #-}
   rule283 = \  (_ :: ()) ->
     Instruction_Dup
   {-# INLINE rule284 #-}
   rule284 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Dxns #-}
sem_Instruction_Dxns :: (Word32) -> T_Instruction 
sem_Instruction_Dxns name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule285  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule286  ()
         _output = rule287 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule288 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule285 #-}
   rule285 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule286 #-}
   rule286 = \  (_ :: ()) ->
     False
   {-# INLINE rule287 #-}
   rule287 = \ name_ ->
     Instruction_Dxns name_
   {-# INLINE rule288 #-}
   rule288 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_DxnsLate #-}
sem_Instruction_DxnsLate ::  T_Instruction 
sem_Instruction_DxnsLate  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule289  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule290  ()
         _output = rule291  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule292 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule289 #-}
   rule289 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule290 #-}
   rule290 = \  (_ :: ()) ->
     False
   {-# INLINE rule291 #-}
   rule291 = \  (_ :: ()) ->
     Instruction_DxnsLate
   {-# INLINE rule292 #-}
   rule292 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Equals #-}
sem_Instruction_Equals ::  T_Instruction 
sem_Instruction_Equals  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule293  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule294  ()
         _output = rule295  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule296 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule293 #-}
   rule293 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule294 #-}
   rule294 = \  (_ :: ()) ->
     False
   {-# INLINE rule295 #-}
   rule295 = \  (_ :: ()) ->
     Instruction_Equals
   {-# INLINE rule296 #-}
   rule296 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_EscXAttr #-}
sem_Instruction_EscXAttr ::  T_Instruction 
sem_Instruction_EscXAttr  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule297  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule298  ()
         _output = rule299  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule300 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule297 #-}
   rule297 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule298 #-}
   rule298 = \  (_ :: ()) ->
     False
   {-# INLINE rule299 #-}
   rule299 = \  (_ :: ()) ->
     Instruction_EscXAttr
   {-# INLINE rule300 #-}
   rule300 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_EscXElem #-}
sem_Instruction_EscXElem ::  T_Instruction 
sem_Instruction_EscXElem  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule301  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule302  ()
         _output = rule303  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule304 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule301 #-}
   rule301 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule302 #-}
   rule302 = \  (_ :: ()) ->
     False
   {-# INLINE rule303 #-}
   rule303 = \  (_ :: ()) ->
     Instruction_EscXElem
   {-# INLINE rule304 #-}
   rule304 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_FindDef #-}
sem_Instruction_FindDef :: (Word32) -> T_Instruction 
sem_Instruction_FindDef name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule305  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule306  ()
         _output = rule307 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule308 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule305 #-}
   rule305 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule306 #-}
   rule306 = \  (_ :: ()) ->
     False
   {-# INLINE rule307 #-}
   rule307 = \ name_ ->
     Instruction_FindDef name_
   {-# INLINE rule308 #-}
   rule308 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_FindPropertyGlobalStrict #-}
sem_Instruction_FindPropertyGlobalStrict :: (Word32) -> T_Instruction 
sem_Instruction_FindPropertyGlobalStrict name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule309  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule310  ()
         _output = rule311 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule312 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule309 #-}
   rule309 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule310 #-}
   rule310 = \  (_ :: ()) ->
     False
   {-# INLINE rule311 #-}
   rule311 = \ name_ ->
     Instruction_FindPropertyGlobalStrict name_
   {-# INLINE rule312 #-}
   rule312 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_FindPropertyGlobal #-}
sem_Instruction_FindPropertyGlobal :: (Word32) -> T_Instruction 
sem_Instruction_FindPropertyGlobal name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule313  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule314  ()
         _output = rule315 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule316 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule313 #-}
   rule313 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule314 #-}
   rule314 = \  (_ :: ()) ->
     False
   {-# INLINE rule315 #-}
   rule315 = \ name_ ->
     Instruction_FindPropertyGlobal name_
   {-# INLINE rule316 #-}
   rule316 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_FindProperty #-}
sem_Instruction_FindProperty :: (Word32) -> T_Instruction 
sem_Instruction_FindProperty name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule317  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule318  ()
         _output = rule319 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule320 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule317 #-}
   rule317 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule318 #-}
   rule318 = \  (_ :: ()) ->
     False
   {-# INLINE rule319 #-}
   rule319 = \ name_ ->
     Instruction_FindProperty name_
   {-# INLINE rule320 #-}
   rule320 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_FindPropStrict #-}
sem_Instruction_FindPropStrict :: (Word32) -> T_Instruction 
sem_Instruction_FindPropStrict name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule321  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule322  ()
         _output = rule323 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule324 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule321 #-}
   rule321 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule322 #-}
   rule322 = \  (_ :: ()) ->
     False
   {-# INLINE rule323 #-}
   rule323 = \ name_ ->
     Instruction_FindPropStrict name_
   {-# INLINE rule324 #-}
   rule324 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetDescendants #-}
sem_Instruction_GetDescendants :: (Word32) -> T_Instruction 
sem_Instruction_GetDescendants name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule325  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule326  ()
         _output = rule327 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule328 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule325 #-}
   rule325 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule326 #-}
   rule326 = \  (_ :: ()) ->
     False
   {-# INLINE rule327 #-}
   rule327 = \ name_ ->
     Instruction_GetDescendants name_
   {-# INLINE rule328 #-}
   rule328 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetGlobalScope #-}
sem_Instruction_GetGlobalScope ::  T_Instruction 
sem_Instruction_GetGlobalScope  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule329  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule330  ()
         _output = rule331  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule332 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule329 #-}
   rule329 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule330 #-}
   rule330 = \  (_ :: ()) ->
     False
   {-# INLINE rule331 #-}
   rule331 = \  (_ :: ()) ->
     Instruction_GetGlobalScope
   {-# INLINE rule332 #-}
   rule332 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetGlobalSlot #-}
sem_Instruction_GetGlobalSlot :: (Word32) -> T_Instruction 
sem_Instruction_GetGlobalSlot slot_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule333  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule334  ()
         _output = rule335 slot_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule336 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule333 #-}
   rule333 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule334 #-}
   rule334 = \  (_ :: ()) ->
     False
   {-# INLINE rule335 #-}
   rule335 = \ slot_ ->
     Instruction_GetGlobalSlot slot_
   {-# INLINE rule336 #-}
   rule336 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetLex #-}
sem_Instruction_GetLex :: (Word32) -> T_Instruction 
sem_Instruction_GetLex name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule337  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule338  ()
         _output = rule339 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule340 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule337 #-}
   rule337 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule338 #-}
   rule338 = \  (_ :: ()) ->
     False
   {-# INLINE rule339 #-}
   rule339 = \ name_ ->
     Instruction_GetLex name_
   {-# INLINE rule340 #-}
   rule340 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetLocal #-}
sem_Instruction_GetLocal :: (Word32) -> T_Instruction 
sem_Instruction_GetLocal reg_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule341  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule342  ()
         _output = rule343 reg_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule344 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule341 #-}
   rule341 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule342 #-}
   rule342 = \  (_ :: ()) ->
     False
   {-# INLINE rule343 #-}
   rule343 = \ reg_ ->
     Instruction_GetLocal reg_
   {-# INLINE rule344 #-}
   rule344 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetLocal0 #-}
sem_Instruction_GetLocal0 ::  T_Instruction 
sem_Instruction_GetLocal0  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule345  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule346  ()
         _output = rule347  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule348 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule345 #-}
   rule345 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule346 #-}
   rule346 = \  (_ :: ()) ->
     False
   {-# INLINE rule347 #-}
   rule347 = \  (_ :: ()) ->
     Instruction_GetLocal0
   {-# INLINE rule348 #-}
   rule348 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetLocal1 #-}
sem_Instruction_GetLocal1 ::  T_Instruction 
sem_Instruction_GetLocal1  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule349  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule350  ()
         _output = rule351  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule352 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule349 #-}
   rule349 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule350 #-}
   rule350 = \  (_ :: ()) ->
     False
   {-# INLINE rule351 #-}
   rule351 = \  (_ :: ()) ->
     Instruction_GetLocal1
   {-# INLINE rule352 #-}
   rule352 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetLocal2 #-}
sem_Instruction_GetLocal2 ::  T_Instruction 
sem_Instruction_GetLocal2  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule353  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule354  ()
         _output = rule355  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule356 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule353 #-}
   rule353 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule354 #-}
   rule354 = \  (_ :: ()) ->
     False
   {-# INLINE rule355 #-}
   rule355 = \  (_ :: ()) ->
     Instruction_GetLocal2
   {-# INLINE rule356 #-}
   rule356 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetLocal3 #-}
sem_Instruction_GetLocal3 ::  T_Instruction 
sem_Instruction_GetLocal3  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule357  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule358  ()
         _output = rule359  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule360 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule357 #-}
   rule357 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule358 #-}
   rule358 = \  (_ :: ()) ->
     False
   {-# INLINE rule359 #-}
   rule359 = \  (_ :: ()) ->
     Instruction_GetLocal3
   {-# INLINE rule360 #-}
   rule360 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetOuterScope #-}
sem_Instruction_GetOuterScope :: (Word32) -> T_Instruction 
sem_Instruction_GetOuterScope name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule361  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule362  ()
         _output = rule363 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule364 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule361 #-}
   rule361 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule362 #-}
   rule362 = \  (_ :: ()) ->
     False
   {-# INLINE rule363 #-}
   rule363 = \ name_ ->
     Instruction_GetOuterScope name_
   {-# INLINE rule364 #-}
   rule364 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetProperty #-}
sem_Instruction_GetProperty :: (Word32) -> T_Instruction 
sem_Instruction_GetProperty name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule365  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule366  ()
         _output = rule367 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule368 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule365 #-}
   rule365 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule366 #-}
   rule366 = \  (_ :: ()) ->
     False
   {-# INLINE rule367 #-}
   rule367 = \ name_ ->
     Instruction_GetProperty name_
   {-# INLINE rule368 #-}
   rule368 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetScopeObject #-}
sem_Instruction_GetScopeObject :: (Word8) -> T_Instruction 
sem_Instruction_GetScopeObject index_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule369  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule370  ()
         _output = rule371 index_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule372 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule369 #-}
   rule369 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule370 #-}
   rule370 = \  (_ :: ()) ->
     False
   {-# INLINE rule371 #-}
   rule371 = \ index_ ->
     Instruction_GetScopeObject index_
   {-# INLINE rule372 #-}
   rule372 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetSlot #-}
sem_Instruction_GetSlot :: (Word32) -> T_Instruction 
sem_Instruction_GetSlot slot_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule373  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule374  ()
         _output = rule375 slot_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule376 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule373 #-}
   rule373 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule374 #-}
   rule374 = \  (_ :: ()) ->
     False
   {-# INLINE rule375 #-}
   rule375 = \ slot_ ->
     Instruction_GetSlot slot_
   {-# INLINE rule376 #-}
   rule376 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GetSuper #-}
sem_Instruction_GetSuper :: (Word32) -> T_Instruction 
sem_Instruction_GetSuper name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule377  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule378  ()
         _output = rule379 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule380 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule377 #-}
   rule377 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule378 #-}
   rule378 = \  (_ :: ()) ->
     False
   {-# INLINE rule379 #-}
   rule379 = \ name_ ->
     Instruction_GetSuper name_
   {-# INLINE rule380 #-}
   rule380 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GreaterEquals #-}
sem_Instruction_GreaterEquals ::  T_Instruction 
sem_Instruction_GreaterEquals  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule381  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule382  ()
         _output = rule383  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule384 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule381 #-}
   rule381 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule382 #-}
   rule382 = \  (_ :: ()) ->
     False
   {-# INLINE rule383 #-}
   rule383 = \  (_ :: ()) ->
     Instruction_GreaterEquals
   {-# INLINE rule384 #-}
   rule384 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_GreaterThan #-}
sem_Instruction_GreaterThan ::  T_Instruction 
sem_Instruction_GreaterThan  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule385  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule386  ()
         _output = rule387  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule388 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule385 #-}
   rule385 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule386 #-}
   rule386 = \  (_ :: ()) ->
     False
   {-# INLINE rule387 #-}
   rule387 = \  (_ :: ()) ->
     Instruction_GreaterThan
   {-# INLINE rule388 #-}
   rule388 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_HasNext #-}
sem_Instruction_HasNext ::  T_Instruction 
sem_Instruction_HasNext  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule389  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule390  ()
         _output = rule391  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule392 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule389 #-}
   rule389 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule390 #-}
   rule390 = \  (_ :: ()) ->
     False
   {-# INLINE rule391 #-}
   rule391 = \  (_ :: ()) ->
     Instruction_HasNext
   {-# INLINE rule392 #-}
   rule392 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_HasNext2 #-}
sem_Instruction_HasNext2 :: (Word32) -> (Word32) -> T_Instruction 
sem_Instruction_HasNext2 objectReg_ indexReg_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule393  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule394  ()
         _output = rule395 indexReg_ objectReg_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule396 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule393 #-}
   rule393 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule394 #-}
   rule394 = \  (_ :: ()) ->
     False
   {-# INLINE rule395 #-}
   rule395 = \ indexReg_ objectReg_ ->
     Instruction_HasNext2 objectReg_ indexReg_
   {-# INLINE rule396 #-}
   rule396 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfEq #-}
sem_Instruction_IfEq :: (Word32) -> T_Instruction 
sem_Instruction_IfEq offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule397 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule398  ()
         _output = rule399 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule400 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule397 #-}
   rule397 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule398 #-}
   rule398 = \  (_ :: ()) ->
     False
   {-# INLINE rule399 #-}
   rule399 = \ offset_ ->
     Instruction_IfEq offset_
   {-# INLINE rule400 #-}
   rule400 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfFalse #-}
sem_Instruction_IfFalse :: (Word32) -> T_Instruction 
sem_Instruction_IfFalse offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule401 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule402  ()
         _output = rule403 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule404 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule401 #-}
   rule401 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule402 #-}
   rule402 = \  (_ :: ()) ->
     False
   {-# INLINE rule403 #-}
   rule403 = \ offset_ ->
     Instruction_IfFalse offset_
   {-# INLINE rule404 #-}
   rule404 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfGe #-}
sem_Instruction_IfGe :: (Word32) -> T_Instruction 
sem_Instruction_IfGe offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule405 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule406  ()
         _output = rule407 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule408 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule405 #-}
   rule405 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule406 #-}
   rule406 = \  (_ :: ()) ->
     False
   {-# INLINE rule407 #-}
   rule407 = \ offset_ ->
     Instruction_IfGe offset_
   {-# INLINE rule408 #-}
   rule408 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfGt #-}
sem_Instruction_IfGt :: (Word32) -> T_Instruction 
sem_Instruction_IfGt offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule409 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule410  ()
         _output = rule411 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule412 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule409 #-}
   rule409 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule410 #-}
   rule410 = \  (_ :: ()) ->
     False
   {-# INLINE rule411 #-}
   rule411 = \ offset_ ->
     Instruction_IfGt offset_
   {-# INLINE rule412 #-}
   rule412 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfLe #-}
sem_Instruction_IfLe :: (Word32) -> T_Instruction 
sem_Instruction_IfLe offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule413 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule414  ()
         _output = rule415 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule416 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule413 #-}
   rule413 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule414 #-}
   rule414 = \  (_ :: ()) ->
     False
   {-# INLINE rule415 #-}
   rule415 = \ offset_ ->
     Instruction_IfLe offset_
   {-# INLINE rule416 #-}
   rule416 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfLt #-}
sem_Instruction_IfLt :: (Word32) -> T_Instruction 
sem_Instruction_IfLt offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule417 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule418  ()
         _output = rule419 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule420 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule417 #-}
   rule417 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule418 #-}
   rule418 = \  (_ :: ()) ->
     False
   {-# INLINE rule419 #-}
   rule419 = \ offset_ ->
     Instruction_IfLt offset_
   {-# INLINE rule420 #-}
   rule420 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfNGe #-}
sem_Instruction_IfNGe :: (Word32) -> T_Instruction 
sem_Instruction_IfNGe offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule421 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule422  ()
         _output = rule423 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule424 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule421 #-}
   rule421 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule422 #-}
   rule422 = \  (_ :: ()) ->
     False
   {-# INLINE rule423 #-}
   rule423 = \ offset_ ->
     Instruction_IfNGe offset_
   {-# INLINE rule424 #-}
   rule424 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfNGt #-}
sem_Instruction_IfNGt :: (Word32) -> T_Instruction 
sem_Instruction_IfNGt offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule425 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule426  ()
         _output = rule427 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule428 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule425 #-}
   rule425 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule426 #-}
   rule426 = \  (_ :: ()) ->
     False
   {-# INLINE rule427 #-}
   rule427 = \ offset_ ->
     Instruction_IfNGt offset_
   {-# INLINE rule428 #-}
   rule428 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfNLe #-}
sem_Instruction_IfNLe :: (Word32) -> T_Instruction 
sem_Instruction_IfNLe offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule429 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule430  ()
         _output = rule431 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule432 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule429 #-}
   rule429 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule430 #-}
   rule430 = \  (_ :: ()) ->
     False
   {-# INLINE rule431 #-}
   rule431 = \ offset_ ->
     Instruction_IfNLe offset_
   {-# INLINE rule432 #-}
   rule432 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfNLt #-}
sem_Instruction_IfNLt :: (Word32) -> T_Instruction 
sem_Instruction_IfNLt offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule433 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule434  ()
         _output = rule435 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule436 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule433 #-}
   rule433 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule434 #-}
   rule434 = \  (_ :: ()) ->
     False
   {-# INLINE rule435 #-}
   rule435 = \ offset_ ->
     Instruction_IfNLt offset_
   {-# INLINE rule436 #-}
   rule436 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfNe #-}
sem_Instruction_IfNe :: (Word32) -> T_Instruction 
sem_Instruction_IfNe offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule437 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule438  ()
         _output = rule439 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule440 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule437 #-}
   rule437 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule438 #-}
   rule438 = \  (_ :: ()) ->
     False
   {-# INLINE rule439 #-}
   rule439 = \ offset_ ->
     Instruction_IfNe offset_
   {-# INLINE rule440 #-}
   rule440 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfStrictEq #-}
sem_Instruction_IfStrictEq :: (Word32) -> T_Instruction 
sem_Instruction_IfStrictEq offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule441 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule442  ()
         _output = rule443 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule444 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule441 #-}
   rule441 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule442 #-}
   rule442 = \  (_ :: ()) ->
     False
   {-# INLINE rule443 #-}
   rule443 = \ offset_ ->
     Instruction_IfStrictEq offset_
   {-# INLINE rule444 #-}
   rule444 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfStrictNe #-}
sem_Instruction_IfStrictNe :: (Word32) -> T_Instruction 
sem_Instruction_IfStrictNe offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule445 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule446  ()
         _output = rule447 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule448 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule445 #-}
   rule445 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule446 #-}
   rule446 = \  (_ :: ()) ->
     False
   {-# INLINE rule447 #-}
   rule447 = \ offset_ ->
     Instruction_IfStrictNe offset_
   {-# INLINE rule448 #-}
   rule448 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IfTrue #-}
sem_Instruction_IfTrue :: (Word32) -> T_Instruction 
sem_Instruction_IfTrue offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule449 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule450  ()
         _output = rule451 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule452 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule449 #-}
   rule449 = \ offset_ ->
                                    extraBranch offset_
   {-# INLINE rule450 #-}
   rule450 = \  (_ :: ()) ->
     False
   {-# INLINE rule451 #-}
   rule451 = \ offset_ ->
     Instruction_IfTrue offset_
   {-# INLINE rule452 #-}
   rule452 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_In #-}
sem_Instruction_In ::  T_Instruction 
sem_Instruction_In  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule453  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule454  ()
         _output = rule455  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule456 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule453 #-}
   rule453 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule454 #-}
   rule454 = \  (_ :: ()) ->
     False
   {-# INLINE rule455 #-}
   rule455 = \  (_ :: ()) ->
     Instruction_In
   {-# INLINE rule456 #-}
   rule456 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IncLocal #-}
sem_Instruction_IncLocal :: (Word32) -> T_Instruction 
sem_Instruction_IncLocal reg_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule457  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule458  ()
         _output = rule459 reg_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule460 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule457 #-}
   rule457 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule458 #-}
   rule458 = \  (_ :: ()) ->
     False
   {-# INLINE rule459 #-}
   rule459 = \ reg_ ->
     Instruction_IncLocal reg_
   {-# INLINE rule460 #-}
   rule460 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IncLocal_i #-}
sem_Instruction_IncLocal_i :: (Word32) -> T_Instruction 
sem_Instruction_IncLocal_i reg_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule461  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule462  ()
         _output = rule463 reg_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule464 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule461 #-}
   rule461 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule462 #-}
   rule462 = \  (_ :: ()) ->
     False
   {-# INLINE rule463 #-}
   rule463 = \ reg_ ->
     Instruction_IncLocal_i reg_
   {-# INLINE rule464 #-}
   rule464 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Increment #-}
sem_Instruction_Increment ::  T_Instruction 
sem_Instruction_Increment  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule465  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule466  ()
         _output = rule467  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule468 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule465 #-}
   rule465 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule466 #-}
   rule466 = \  (_ :: ()) ->
     False
   {-# INLINE rule467 #-}
   rule467 = \  (_ :: ()) ->
     Instruction_Increment
   {-# INLINE rule468 #-}
   rule468 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Increment_i #-}
sem_Instruction_Increment_i ::  T_Instruction 
sem_Instruction_Increment_i  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule469  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule470  ()
         _output = rule471  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule472 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule469 #-}
   rule469 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule470 #-}
   rule470 = \  (_ :: ()) ->
     False
   {-# INLINE rule471 #-}
   rule471 = \  (_ :: ()) ->
     Instruction_Increment_i
   {-# INLINE rule472 #-}
   rule472 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_InitProperty #-}
sem_Instruction_InitProperty :: (Word32) -> T_Instruction 
sem_Instruction_InitProperty name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule473  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule474  ()
         _output = rule475 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule476 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule473 #-}
   rule473 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule474 #-}
   rule474 = \  (_ :: ()) ->
     False
   {-# INLINE rule475 #-}
   rule475 = \ name_ ->
     Instruction_InitProperty name_
   {-# INLINE rule476 #-}
   rule476 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_InstanceOf #-}
sem_Instruction_InstanceOf ::  T_Instruction 
sem_Instruction_InstanceOf  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule477  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule478  ()
         _output = rule479  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule480 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule477 #-}
   rule477 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule478 #-}
   rule478 = \  (_ :: ()) ->
     False
   {-# INLINE rule479 #-}
   rule479 = \  (_ :: ()) ->
     Instruction_InstanceOf
   {-# INLINE rule480 #-}
   rule480 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IsType #-}
sem_Instruction_IsType :: (Word32) -> T_Instruction 
sem_Instruction_IsType name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule481  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule482  ()
         _output = rule483 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule484 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule481 #-}
   rule481 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule482 #-}
   rule482 = \  (_ :: ()) ->
     False
   {-# INLINE rule483 #-}
   rule483 = \ name_ ->
     Instruction_IsType name_
   {-# INLINE rule484 #-}
   rule484 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_IsTypeLate #-}
sem_Instruction_IsTypeLate ::  T_Instruction 
sem_Instruction_IsTypeLate  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule485  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule486  ()
         _output = rule487  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule488 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule485 #-}
   rule485 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule486 #-}
   rule486 = \  (_ :: ()) ->
     False
   {-# INLINE rule487 #-}
   rule487 = \  (_ :: ()) ->
     Instruction_IsTypeLate
   {-# INLINE rule488 #-}
   rule488 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Jump #-}
sem_Instruction_Jump :: (Word32) -> T_Instruction 
sem_Instruction_Jump offset_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule489 offset_
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule490  ()
         _output = rule491 offset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule492 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule489 #-}
   rule489 = \ offset_ ->
                                    nextBranch offset_
   {-# INLINE rule490 #-}
   rule490 = \  (_ :: ()) ->
     False
   {-# INLINE rule491 #-}
   rule491 = \ offset_ ->
     Instruction_Jump offset_
   {-# INLINE rule492 #-}
   rule492 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Kill #-}
sem_Instruction_Kill :: (Word32) -> T_Instruction 
sem_Instruction_Kill reg_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule493  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule494  ()
         _output = rule495 reg_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule496 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule493 #-}
   rule493 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule494 #-}
   rule494 = \  (_ :: ()) ->
     False
   {-# INLINE rule495 #-}
   rule495 = \ reg_ ->
     Instruction_Kill reg_
   {-# INLINE rule496 #-}
   rule496 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Label #-}
sem_Instruction_Label ::  T_Instruction 
sem_Instruction_Label  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule497  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule498  ()
         _output = rule499  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule500 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule497 #-}
   rule497 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule498 #-}
   rule498 = \  (_ :: ()) ->
     False
   {-# INLINE rule499 #-}
   rule499 = \  (_ :: ()) ->
     Instruction_Label
   {-# INLINE rule500 #-}
   rule500 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_LessEquals #-}
sem_Instruction_LessEquals ::  T_Instruction 
sem_Instruction_LessEquals  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule501  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule502  ()
         _output = rule503  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule504 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule501 #-}
   rule501 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule502 #-}
   rule502 = \  (_ :: ()) ->
     False
   {-# INLINE rule503 #-}
   rule503 = \  (_ :: ()) ->
     Instruction_LessEquals
   {-# INLINE rule504 #-}
   rule504 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_LessThan #-}
sem_Instruction_LessThan ::  T_Instruction 
sem_Instruction_LessThan  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule505  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule506  ()
         _output = rule507  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule508 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule505 #-}
   rule505 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule506 #-}
   rule506 = \  (_ :: ()) ->
     False
   {-# INLINE rule507 #-}
   rule507 = \  (_ :: ()) ->
     Instruction_LessThan
   {-# INLINE rule508 #-}
   rule508 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_LoadFloat32 #-}
sem_Instruction_LoadFloat32 ::  T_Instruction 
sem_Instruction_LoadFloat32  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule509  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule510  ()
         _output = rule511  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule512 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule509 #-}
   rule509 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule510 #-}
   rule510 = \  (_ :: ()) ->
     False
   {-# INLINE rule511 #-}
   rule511 = \  (_ :: ()) ->
     Instruction_LoadFloat32
   {-# INLINE rule512 #-}
   rule512 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_LoadFloat64 #-}
sem_Instruction_LoadFloat64 ::  T_Instruction 
sem_Instruction_LoadFloat64  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule513  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule514  ()
         _output = rule515  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule516 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule513 #-}
   rule513 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule514 #-}
   rule514 = \  (_ :: ()) ->
     False
   {-# INLINE rule515 #-}
   rule515 = \  (_ :: ()) ->
     Instruction_LoadFloat64
   {-# INLINE rule516 #-}
   rule516 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_LoadIndirect8 #-}
sem_Instruction_LoadIndirect8 ::  T_Instruction 
sem_Instruction_LoadIndirect8  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule517  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule518  ()
         _output = rule519  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule520 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule517 #-}
   rule517 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule518 #-}
   rule518 = \  (_ :: ()) ->
     False
   {-# INLINE rule519 #-}
   rule519 = \  (_ :: ()) ->
     Instruction_LoadIndirect8
   {-# INLINE rule520 #-}
   rule520 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_LoadIndirect16 #-}
sem_Instruction_LoadIndirect16 ::  T_Instruction 
sem_Instruction_LoadIndirect16  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule521  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule522  ()
         _output = rule523  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule524 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule521 #-}
   rule521 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule522 #-}
   rule522 = \  (_ :: ()) ->
     False
   {-# INLINE rule523 #-}
   rule523 = \  (_ :: ()) ->
     Instruction_LoadIndirect16
   {-# INLINE rule524 #-}
   rule524 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_LoadIndirect32 #-}
sem_Instruction_LoadIndirect32 ::  T_Instruction 
sem_Instruction_LoadIndirect32  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule525  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule526  ()
         _output = rule527  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule528 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule525 #-}
   rule525 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule526 #-}
   rule526 = \  (_ :: ()) ->
     False
   {-# INLINE rule527 #-}
   rule527 = \  (_ :: ()) ->
     Instruction_LoadIndirect32
   {-# INLINE rule528 #-}
   rule528 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_LookupSwitch #-}
sem_Instruction_LookupSwitch :: (Word32) -> T_CaseOffsets  -> T_Instruction 
sem_Instruction_LookupSwitch defaultOffset_ caseOffsets_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _caseOffsetsX17 = Control.Monad.Identity.runIdentity (attach_T_CaseOffsets (caseOffsets_))
         (T_CaseOffsets_vOut16 _caseOffsetsIbranching _caseOffsetsIoutput) = inv_CaseOffsets_s17 _caseOffsetsX17 (T_CaseOffsets_vIn16 )
         _branch = rule529 defaultOffset_
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule530 _branch _caseOffsetsIbranching
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule531  ()
         _output = rule532 _caseOffsetsIoutput defaultOffset_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule533 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule529 #-}
   rule529 = \ defaultOffset_ ->
                                    nextBranch defaultOffset_
   {-# INLINE rule530 #-}
   rule530 = \ _branch ((_caseOffsetsIbranching) :: BranchingInfo) ->
                                    _branch     `mappend` _caseOffsetsIbranching
   {-# INLINE rule531 #-}
   rule531 = \  (_ :: ()) ->
     False
   {-# INLINE rule532 #-}
   rule532 = \ ((_caseOffsetsIoutput) :: CaseOffsets) defaultOffset_ ->
     Instruction_LookupSwitch defaultOffset_ _caseOffsetsIoutput
   {-# INLINE rule533 #-}
   rule533 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Lshift #-}
sem_Instruction_Lshift ::  T_Instruction 
sem_Instruction_Lshift  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule534  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule535  ()
         _output = rule536  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule537 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule534 #-}
   rule534 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule535 #-}
   rule535 = \  (_ :: ()) ->
     False
   {-# INLINE rule536 #-}
   rule536 = \  (_ :: ()) ->
     Instruction_Lshift
   {-# INLINE rule537 #-}
   rule537 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Modulo #-}
sem_Instruction_Modulo ::  T_Instruction 
sem_Instruction_Modulo  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule538  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule539  ()
         _output = rule540  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule541 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule538 #-}
   rule538 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule539 #-}
   rule539 = \  (_ :: ()) ->
     False
   {-# INLINE rule540 #-}
   rule540 = \  (_ :: ()) ->
     Instruction_Modulo
   {-# INLINE rule541 #-}
   rule541 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Multiply #-}
sem_Instruction_Multiply ::  T_Instruction 
sem_Instruction_Multiply  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule542  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule543  ()
         _output = rule544  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule545 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule542 #-}
   rule542 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule543 #-}
   rule543 = \  (_ :: ()) ->
     False
   {-# INLINE rule544 #-}
   rule544 = \  (_ :: ()) ->
     Instruction_Multiply
   {-# INLINE rule545 #-}
   rule545 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Multiply_i #-}
sem_Instruction_Multiply_i ::  T_Instruction 
sem_Instruction_Multiply_i  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule546  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule547  ()
         _output = rule548  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule549 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule546 #-}
   rule546 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule547 #-}
   rule547 = \  (_ :: ()) ->
     False
   {-# INLINE rule548 #-}
   rule548 = \  (_ :: ()) ->
     Instruction_Multiply_i
   {-# INLINE rule549 #-}
   rule549 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Negate #-}
sem_Instruction_Negate ::  T_Instruction 
sem_Instruction_Negate  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule550  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule551  ()
         _output = rule552  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule553 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule550 #-}
   rule550 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule551 #-}
   rule551 = \  (_ :: ()) ->
     False
   {-# INLINE rule552 #-}
   rule552 = \  (_ :: ()) ->
     Instruction_Negate
   {-# INLINE rule553 #-}
   rule553 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Negate_i #-}
sem_Instruction_Negate_i ::  T_Instruction 
sem_Instruction_Negate_i  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule554  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule555  ()
         _output = rule556  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule557 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule554 #-}
   rule554 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule555 #-}
   rule555 = \  (_ :: ()) ->
     False
   {-# INLINE rule556 #-}
   rule556 = \  (_ :: ()) ->
     Instruction_Negate_i
   {-# INLINE rule557 #-}
   rule557 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_NewActivation #-}
sem_Instruction_NewActivation ::  T_Instruction 
sem_Instruction_NewActivation  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule558  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule559  ()
         _output = rule560  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule561 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule558 #-}
   rule558 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule559 #-}
   rule559 = \  (_ :: ()) ->
     False
   {-# INLINE rule560 #-}
   rule560 = \  (_ :: ()) ->
     Instruction_NewActivation
   {-# INLINE rule561 #-}
   rule561 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_NewArray #-}
sem_Instruction_NewArray :: (Word32) -> T_Instruction 
sem_Instruction_NewArray argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule562  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule563  ()
         _output = rule564 argCount_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule565 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule562 #-}
   rule562 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule563 #-}
   rule563 = \  (_ :: ()) ->
     False
   {-# INLINE rule564 #-}
   rule564 = \ argCount_ ->
     Instruction_NewArray argCount_
   {-# INLINE rule565 #-}
   rule565 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_NewCatch #-}
sem_Instruction_NewCatch :: (Word32) -> T_Instruction 
sem_Instruction_NewCatch exception_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule566  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule567  ()
         _output = rule568 exception_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule569 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule566 #-}
   rule566 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule567 #-}
   rule567 = \  (_ :: ()) ->
     False
   {-# INLINE rule568 #-}
   rule568 = \ exception_ ->
     Instruction_NewCatch exception_
   {-# INLINE rule569 #-}
   rule569 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_NewClass #-}
sem_Instruction_NewClass :: (Word32) -> T_Instruction 
sem_Instruction_NewClass class_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule570  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule571  ()
         _output = rule572 class_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule573 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule570 #-}
   rule570 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule571 #-}
   rule571 = \  (_ :: ()) ->
     False
   {-# INLINE rule572 #-}
   rule572 = \ class_ ->
     Instruction_NewClass class_
   {-# INLINE rule573 #-}
   rule573 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_NewFunction #-}
sem_Instruction_NewFunction :: (Word32) -> T_Instruction 
sem_Instruction_NewFunction method_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule574  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule575  ()
         _output = rule576 method_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule577 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule574 #-}
   rule574 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule575 #-}
   rule575 = \  (_ :: ()) ->
     False
   {-# INLINE rule576 #-}
   rule576 = \ method_ ->
     Instruction_NewFunction method_
   {-# INLINE rule577 #-}
   rule577 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_NewObject #-}
sem_Instruction_NewObject :: (Word32) -> T_Instruction 
sem_Instruction_NewObject argCount_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule578  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule579  ()
         _output = rule580 argCount_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule581 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule578 #-}
   rule578 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule579 #-}
   rule579 = \  (_ :: ()) ->
     False
   {-# INLINE rule580 #-}
   rule580 = \ argCount_ ->
     Instruction_NewObject argCount_
   {-# INLINE rule581 #-}
   rule581 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_NextName #-}
sem_Instruction_NextName ::  T_Instruction 
sem_Instruction_NextName  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule582  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule583  ()
         _output = rule584  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule585 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule582 #-}
   rule582 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule583 #-}
   rule583 = \  (_ :: ()) ->
     False
   {-# INLINE rule584 #-}
   rule584 = \  (_ :: ()) ->
     Instruction_NextName
   {-# INLINE rule585 #-}
   rule585 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_NextValue #-}
sem_Instruction_NextValue ::  T_Instruction 
sem_Instruction_NextValue  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule586  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule587  ()
         _output = rule588  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule589 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule586 #-}
   rule586 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule587 #-}
   rule587 = \  (_ :: ()) ->
     False
   {-# INLINE rule588 #-}
   rule588 = \  (_ :: ()) ->
     Instruction_NextValue
   {-# INLINE rule589 #-}
   rule589 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Nop #-}
sem_Instruction_Nop ::  T_Instruction 
sem_Instruction_Nop  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule590  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule591  ()
         _output = rule592  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule593 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule590 #-}
   rule590 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule591 #-}
   rule591 = \  (_ :: ()) ->
     False
   {-# INLINE rule592 #-}
   rule592 = \  (_ :: ()) ->
     Instruction_Nop
   {-# INLINE rule593 #-}
   rule593 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Not #-}
sem_Instruction_Not ::  T_Instruction 
sem_Instruction_Not  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule594  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule595  ()
         _output = rule596  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule597 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule594 #-}
   rule594 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule595 #-}
   rule595 = \  (_ :: ()) ->
     False
   {-# INLINE rule596 #-}
   rule596 = \  (_ :: ()) ->
     Instruction_Not
   {-# INLINE rule597 #-}
   rule597 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Pop #-}
sem_Instruction_Pop ::  T_Instruction 
sem_Instruction_Pop  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule598  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule599  ()
         _output = rule600  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule601 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule598 #-}
   rule598 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule599 #-}
   rule599 = \  (_ :: ()) ->
     False
   {-# INLINE rule600 #-}
   rule600 = \  (_ :: ()) ->
     Instruction_Pop
   {-# INLINE rule601 #-}
   rule601 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PopScope #-}
sem_Instruction_PopScope ::  T_Instruction 
sem_Instruction_PopScope  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule602  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule603  ()
         _output = rule604  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule605 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule602 #-}
   rule602 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule603 #-}
   rule603 = \  (_ :: ()) ->
     False
   {-# INLINE rule604 #-}
   rule604 = \  (_ :: ()) ->
     Instruction_PopScope
   {-# INLINE rule605 #-}
   rule605 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushByte #-}
sem_Instruction_PushByte :: (Word8) -> T_Instruction 
sem_Instruction_PushByte val_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule606  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule607  ()
         _output = rule608 val_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule609 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule606 #-}
   rule606 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule607 #-}
   rule607 = \  (_ :: ()) ->
     False
   {-# INLINE rule608 #-}
   rule608 = \ val_ ->
     Instruction_PushByte val_
   {-# INLINE rule609 #-}
   rule609 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushDouble #-}
sem_Instruction_PushDouble :: (Word32) -> T_Instruction 
sem_Instruction_PushDouble name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule610  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule611  ()
         _output = rule612 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule613 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule610 #-}
   rule610 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule611 #-}
   rule611 = \  (_ :: ()) ->
     False
   {-# INLINE rule612 #-}
   rule612 = \ name_ ->
     Instruction_PushDouble name_
   {-# INLINE rule613 #-}
   rule613 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushFalse #-}
sem_Instruction_PushFalse ::  T_Instruction 
sem_Instruction_PushFalse  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule614  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule615  ()
         _output = rule616  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule617 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule614 #-}
   rule614 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule615 #-}
   rule615 = \  (_ :: ()) ->
     False
   {-# INLINE rule616 #-}
   rule616 = \  (_ :: ()) ->
     Instruction_PushFalse
   {-# INLINE rule617 #-}
   rule617 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushInt #-}
sem_Instruction_PushInt :: (Word32) -> T_Instruction 
sem_Instruction_PushInt name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule618  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule619  ()
         _output = rule620 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule621 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule618 #-}
   rule618 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule619 #-}
   rule619 = \  (_ :: ()) ->
     False
   {-# INLINE rule620 #-}
   rule620 = \ name_ ->
     Instruction_PushInt name_
   {-# INLINE rule621 #-}
   rule621 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushNamespace #-}
sem_Instruction_PushNamespace :: (Word32) -> T_Instruction 
sem_Instruction_PushNamespace name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule622  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule623  ()
         _output = rule624 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule625 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule622 #-}
   rule622 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule623 #-}
   rule623 = \  (_ :: ()) ->
     False
   {-# INLINE rule624 #-}
   rule624 = \ name_ ->
     Instruction_PushNamespace name_
   {-# INLINE rule625 #-}
   rule625 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushNaN #-}
sem_Instruction_PushNaN ::  T_Instruction 
sem_Instruction_PushNaN  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule626  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule627  ()
         _output = rule628  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule629 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule626 #-}
   rule626 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule627 #-}
   rule627 = \  (_ :: ()) ->
     False
   {-# INLINE rule628 #-}
   rule628 = \  (_ :: ()) ->
     Instruction_PushNaN
   {-# INLINE rule629 #-}
   rule629 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushNull #-}
sem_Instruction_PushNull ::  T_Instruction 
sem_Instruction_PushNull  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule630  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule631  ()
         _output = rule632  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule633 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule630 #-}
   rule630 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule631 #-}
   rule631 = \  (_ :: ()) ->
     False
   {-# INLINE rule632 #-}
   rule632 = \  (_ :: ()) ->
     Instruction_PushNull
   {-# INLINE rule633 #-}
   rule633 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushScope #-}
sem_Instruction_PushScope ::  T_Instruction 
sem_Instruction_PushScope  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule634  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule635  ()
         _output = rule636  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule637 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule634 #-}
   rule634 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule635 #-}
   rule635 = \  (_ :: ()) ->
     False
   {-# INLINE rule636 #-}
   rule636 = \  (_ :: ()) ->
     Instruction_PushScope
   {-# INLINE rule637 #-}
   rule637 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushShort #-}
sem_Instruction_PushShort :: (Word32) -> T_Instruction 
sem_Instruction_PushShort val_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule638  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule639  ()
         _output = rule640 val_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule641 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule638 #-}
   rule638 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule639 #-}
   rule639 = \  (_ :: ()) ->
     False
   {-# INLINE rule640 #-}
   rule640 = \ val_ ->
     Instruction_PushShort val_
   {-# INLINE rule641 #-}
   rule641 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushString #-}
sem_Instruction_PushString :: (Word32) -> T_Instruction 
sem_Instruction_PushString name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule642  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule643  ()
         _output = rule644 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule645 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule642 #-}
   rule642 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule643 #-}
   rule643 = \  (_ :: ()) ->
     False
   {-# INLINE rule644 #-}
   rule644 = \ name_ ->
     Instruction_PushString name_
   {-# INLINE rule645 #-}
   rule645 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushTrue #-}
sem_Instruction_PushTrue ::  T_Instruction 
sem_Instruction_PushTrue  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule646  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule647  ()
         _output = rule648  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule649 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule646 #-}
   rule646 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule647 #-}
   rule647 = \  (_ :: ()) ->
     False
   {-# INLINE rule648 #-}
   rule648 = \  (_ :: ()) ->
     Instruction_PushTrue
   {-# INLINE rule649 #-}
   rule649 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushUInt #-}
sem_Instruction_PushUInt :: (Word32) -> T_Instruction 
sem_Instruction_PushUInt name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule650  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule651  ()
         _output = rule652 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule653 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule650 #-}
   rule650 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule651 #-}
   rule651 = \  (_ :: ()) ->
     False
   {-# INLINE rule652 #-}
   rule652 = \ name_ ->
     Instruction_PushUInt name_
   {-# INLINE rule653 #-}
   rule653 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushUndefined #-}
sem_Instruction_PushUndefined ::  T_Instruction 
sem_Instruction_PushUndefined  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule654  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule655  ()
         _output = rule656  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule657 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule654 #-}
   rule654 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule655 #-}
   rule655 = \  (_ :: ()) ->
     False
   {-# INLINE rule656 #-}
   rule656 = \  (_ :: ()) ->
     Instruction_PushUndefined
   {-# INLINE rule657 #-}
   rule657 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_PushWith #-}
sem_Instruction_PushWith ::  T_Instruction 
sem_Instruction_PushWith  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule658  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule659  ()
         _output = rule660  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule661 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule658 #-}
   rule658 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule659 #-}
   rule659 = \  (_ :: ()) ->
     False
   {-# INLINE rule660 #-}
   rule660 = \  (_ :: ()) ->
     Instruction_PushWith
   {-# INLINE rule661 #-}
   rule661 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_ReturnValue #-}
sem_Instruction_ReturnValue ::  T_Instruction 
sem_Instruction_ReturnValue  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule662  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule663  ()
         _output = rule664  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule665 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule662 #-}
   rule662 = \  (_ :: ()) ->
                                    BranchingInfo False []
   {-# INLINE rule663 #-}
   rule663 = \  (_ :: ()) ->
                                                           True
   {-# INLINE rule664 #-}
   rule664 = \  (_ :: ()) ->
     Instruction_ReturnValue
   {-# INLINE rule665 #-}
   rule665 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_ReturnVoid #-}
sem_Instruction_ReturnVoid ::  T_Instruction 
sem_Instruction_ReturnVoid  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule666  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule667  ()
         _output = rule668  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule669 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule666 #-}
   rule666 = \  (_ :: ()) ->
                                    BranchingInfo False []
   {-# INLINE rule667 #-}
   rule667 = \  (_ :: ()) ->
                                                           True
   {-# INLINE rule668 #-}
   rule668 = \  (_ :: ()) ->
     Instruction_ReturnVoid
   {-# INLINE rule669 #-}
   rule669 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Rshift #-}
sem_Instruction_Rshift ::  T_Instruction 
sem_Instruction_Rshift  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule670  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule671  ()
         _output = rule672  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule673 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule670 #-}
   rule670 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule671 #-}
   rule671 = \  (_ :: ()) ->
     False
   {-# INLINE rule672 #-}
   rule672 = \  (_ :: ()) ->
     Instruction_Rshift
   {-# INLINE rule673 #-}
   rule673 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SetLocal #-}
sem_Instruction_SetLocal :: (Word32) -> T_Instruction 
sem_Instruction_SetLocal reg_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule674  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule675  ()
         _output = rule676 reg_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule677 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule674 #-}
   rule674 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule675 #-}
   rule675 = \  (_ :: ()) ->
     False
   {-# INLINE rule676 #-}
   rule676 = \ reg_ ->
     Instruction_SetLocal reg_
   {-# INLINE rule677 #-}
   rule677 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SetLocal0 #-}
sem_Instruction_SetLocal0 ::  T_Instruction 
sem_Instruction_SetLocal0  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule678  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule679  ()
         _output = rule680  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule681 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule678 #-}
   rule678 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule679 #-}
   rule679 = \  (_ :: ()) ->
     False
   {-# INLINE rule680 #-}
   rule680 = \  (_ :: ()) ->
     Instruction_SetLocal0
   {-# INLINE rule681 #-}
   rule681 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SetLocal1 #-}
sem_Instruction_SetLocal1 ::  T_Instruction 
sem_Instruction_SetLocal1  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule682  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule683  ()
         _output = rule684  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule685 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule682 #-}
   rule682 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule683 #-}
   rule683 = \  (_ :: ()) ->
     False
   {-# INLINE rule684 #-}
   rule684 = \  (_ :: ()) ->
     Instruction_SetLocal1
   {-# INLINE rule685 #-}
   rule685 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SetLocal2 #-}
sem_Instruction_SetLocal2 ::  T_Instruction 
sem_Instruction_SetLocal2  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule686  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule687  ()
         _output = rule688  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule689 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule686 #-}
   rule686 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule687 #-}
   rule687 = \  (_ :: ()) ->
     False
   {-# INLINE rule688 #-}
   rule688 = \  (_ :: ()) ->
     Instruction_SetLocal2
   {-# INLINE rule689 #-}
   rule689 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SetLocal3 #-}
sem_Instruction_SetLocal3 ::  T_Instruction 
sem_Instruction_SetLocal3  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule690  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule691  ()
         _output = rule692  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule693 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule690 #-}
   rule690 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule691 #-}
   rule691 = \  (_ :: ()) ->
     False
   {-# INLINE rule692 #-}
   rule692 = \  (_ :: ()) ->
     Instruction_SetLocal3
   {-# INLINE rule693 #-}
   rule693 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SetGlobalSlot #-}
sem_Instruction_SetGlobalSlot :: (Word32) -> T_Instruction 
sem_Instruction_SetGlobalSlot slot_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule694  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule695  ()
         _output = rule696 slot_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule697 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule694 #-}
   rule694 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule695 #-}
   rule695 = \  (_ :: ()) ->
     False
   {-# INLINE rule696 #-}
   rule696 = \ slot_ ->
     Instruction_SetGlobalSlot slot_
   {-# INLINE rule697 #-}
   rule697 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SetProperty #-}
sem_Instruction_SetProperty :: (Word32) -> T_Instruction 
sem_Instruction_SetProperty name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule698  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule699  ()
         _output = rule700 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule701 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule698 #-}
   rule698 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule699 #-}
   rule699 = \  (_ :: ()) ->
     False
   {-# INLINE rule700 #-}
   rule700 = \ name_ ->
     Instruction_SetProperty name_
   {-# INLINE rule701 #-}
   rule701 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SetPropertyLate #-}
sem_Instruction_SetPropertyLate ::  T_Instruction 
sem_Instruction_SetPropertyLate  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule702  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule703  ()
         _output = rule704  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule705 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule702 #-}
   rule702 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule703 #-}
   rule703 = \  (_ :: ()) ->
     False
   {-# INLINE rule704 #-}
   rule704 = \  (_ :: ()) ->
     Instruction_SetPropertyLate
   {-# INLINE rule705 #-}
   rule705 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SetSlot #-}
sem_Instruction_SetSlot :: (Word32) -> T_Instruction 
sem_Instruction_SetSlot slot_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule706  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule707  ()
         _output = rule708 slot_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule709 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule706 #-}
   rule706 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule707 #-}
   rule707 = \  (_ :: ()) ->
     False
   {-# INLINE rule708 #-}
   rule708 = \ slot_ ->
     Instruction_SetSlot slot_
   {-# INLINE rule709 #-}
   rule709 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SetSuper #-}
sem_Instruction_SetSuper :: (Word32) -> T_Instruction 
sem_Instruction_SetSuper name_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule710  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule711  ()
         _output = rule712 name_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule713 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule710 #-}
   rule710 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule711 #-}
   rule711 = \  (_ :: ()) ->
     False
   {-# INLINE rule712 #-}
   rule712 = \ name_ ->
     Instruction_SetSuper name_
   {-# INLINE rule713 #-}
   rule713 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SignExtend1 #-}
sem_Instruction_SignExtend1 ::  T_Instruction 
sem_Instruction_SignExtend1  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule714  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule715  ()
         _output = rule716  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule717 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule714 #-}
   rule714 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule715 #-}
   rule715 = \  (_ :: ()) ->
     False
   {-# INLINE rule716 #-}
   rule716 = \  (_ :: ()) ->
     Instruction_SignExtend1
   {-# INLINE rule717 #-}
   rule717 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SignExtend8 #-}
sem_Instruction_SignExtend8 ::  T_Instruction 
sem_Instruction_SignExtend8  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule718  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule719  ()
         _output = rule720  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule721 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule718 #-}
   rule718 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule719 #-}
   rule719 = \  (_ :: ()) ->
     False
   {-# INLINE rule720 #-}
   rule720 = \  (_ :: ()) ->
     Instruction_SignExtend8
   {-# INLINE rule721 #-}
   rule721 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_SignExtend16 #-}
sem_Instruction_SignExtend16 ::  T_Instruction 
sem_Instruction_SignExtend16  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule722  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule723  ()
         _output = rule724  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule725 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule722 #-}
   rule722 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule723 #-}
   rule723 = \  (_ :: ()) ->
     False
   {-# INLINE rule724 #-}
   rule724 = \  (_ :: ()) ->
     Instruction_SignExtend16
   {-# INLINE rule725 #-}
   rule725 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_StoreFloat32 #-}
sem_Instruction_StoreFloat32 ::  T_Instruction 
sem_Instruction_StoreFloat32  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule726  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule727  ()
         _output = rule728  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule729 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule726 #-}
   rule726 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule727 #-}
   rule727 = \  (_ :: ()) ->
     False
   {-# INLINE rule728 #-}
   rule728 = \  (_ :: ()) ->
     Instruction_StoreFloat32
   {-# INLINE rule729 #-}
   rule729 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_StoreFloat64 #-}
sem_Instruction_StoreFloat64 ::  T_Instruction 
sem_Instruction_StoreFloat64  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule730  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule731  ()
         _output = rule732  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule733 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule730 #-}
   rule730 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule731 #-}
   rule731 = \  (_ :: ()) ->
     False
   {-# INLINE rule732 #-}
   rule732 = \  (_ :: ()) ->
     Instruction_StoreFloat64
   {-# INLINE rule733 #-}
   rule733 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_StoreIndirect32 #-}
sem_Instruction_StoreIndirect32 ::  T_Instruction 
sem_Instruction_StoreIndirect32  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule734  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule735  ()
         _output = rule736  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule737 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule734 #-}
   rule734 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule735 #-}
   rule735 = \  (_ :: ()) ->
     False
   {-# INLINE rule736 #-}
   rule736 = \  (_ :: ()) ->
     Instruction_StoreIndirect32
   {-# INLINE rule737 #-}
   rule737 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_StoreIndirect16 #-}
sem_Instruction_StoreIndirect16 ::  T_Instruction 
sem_Instruction_StoreIndirect16  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule738  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule739  ()
         _output = rule740  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule741 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule738 #-}
   rule738 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule739 #-}
   rule739 = \  (_ :: ()) ->
     False
   {-# INLINE rule740 #-}
   rule740 = \  (_ :: ()) ->
     Instruction_StoreIndirect16
   {-# INLINE rule741 #-}
   rule741 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_StoreIndirect8 #-}
sem_Instruction_StoreIndirect8 ::  T_Instruction 
sem_Instruction_StoreIndirect8  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule742  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule743  ()
         _output = rule744  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule745 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule742 #-}
   rule742 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule743 #-}
   rule743 = \  (_ :: ()) ->
     False
   {-# INLINE rule744 #-}
   rule744 = \  (_ :: ()) ->
     Instruction_StoreIndirect8
   {-# INLINE rule745 #-}
   rule745 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_StrictEquals #-}
sem_Instruction_StrictEquals ::  T_Instruction 
sem_Instruction_StrictEquals  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule746  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule747  ()
         _output = rule748  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule749 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule746 #-}
   rule746 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule747 #-}
   rule747 = \  (_ :: ()) ->
     False
   {-# INLINE rule748 #-}
   rule748 = \  (_ :: ()) ->
     Instruction_StrictEquals
   {-# INLINE rule749 #-}
   rule749 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Substract #-}
sem_Instruction_Substract ::  T_Instruction 
sem_Instruction_Substract  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule750  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule751  ()
         _output = rule752  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule753 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule750 #-}
   rule750 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule751 #-}
   rule751 = \  (_ :: ()) ->
     False
   {-# INLINE rule752 #-}
   rule752 = \  (_ :: ()) ->
     Instruction_Substract
   {-# INLINE rule753 #-}
   rule753 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Substract_i #-}
sem_Instruction_Substract_i ::  T_Instruction 
sem_Instruction_Substract_i  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule754  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule755  ()
         _output = rule756  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule757 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule754 #-}
   rule754 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule755 #-}
   rule755 = \  (_ :: ()) ->
     False
   {-# INLINE rule756 #-}
   rule756 = \  (_ :: ()) ->
     Instruction_Substract_i
   {-# INLINE rule757 #-}
   rule757 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Swap #-}
sem_Instruction_Swap ::  T_Instruction 
sem_Instruction_Swap  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule758  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule759  ()
         _output = rule760  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule761 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule758 #-}
   rule758 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule759 #-}
   rule759 = \  (_ :: ()) ->
     False
   {-# INLINE rule760 #-}
   rule760 = \  (_ :: ()) ->
     Instruction_Swap
   {-# INLINE rule761 #-}
   rule761 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Throw #-}
sem_Instruction_Throw ::  T_Instruction 
sem_Instruction_Throw  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule762  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule763  ()
         _output = rule764  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule765 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule762 #-}
   rule762 = \  (_ :: ()) ->
                                    BranchingInfo False []
   {-# INLINE rule763 #-}
   rule763 = \  (_ :: ()) ->
     False
   {-# INLINE rule764 #-}
   rule764 = \  (_ :: ()) ->
     Instruction_Throw
   {-# INLINE rule765 #-}
   rule765 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Timestamp #-}
sem_Instruction_Timestamp ::  T_Instruction 
sem_Instruction_Timestamp  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule766  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule767  ()
         _output = rule768  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule769 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule766 #-}
   rule766 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule767 #-}
   rule767 = \  (_ :: ()) ->
     False
   {-# INLINE rule768 #-}
   rule768 = \  (_ :: ()) ->
     Instruction_Timestamp
   {-# INLINE rule769 #-}
   rule769 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_TypeOf #-}
sem_Instruction_TypeOf ::  T_Instruction 
sem_Instruction_TypeOf  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule770  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule771  ()
         _output = rule772  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule773 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule770 #-}
   rule770 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule771 #-}
   rule771 = \  (_ :: ()) ->
     False
   {-# INLINE rule772 #-}
   rule772 = \  (_ :: ()) ->
     Instruction_TypeOf
   {-# INLINE rule773 #-}
   rule773 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Urshift #-}
sem_Instruction_Urshift ::  T_Instruction 
sem_Instruction_Urshift  = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule774  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule775  ()
         _output = rule776  ()
         _lhsOoutput :: Instruction
         _lhsOoutput = rule777 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule774 #-}
   rule774 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule775 #-}
   rule775 = \  (_ :: ()) ->
     False
   {-# INLINE rule776 #-}
   rule776 = \  (_ :: ()) ->
     Instruction_Urshift
   {-# INLINE rule777 #-}
   rule777 = \ _output ->
     _output
{-# NOINLINE sem_Instruction_Virtual #-}
sem_Instruction_Virtual :: (Int) -> T_VirtKind  -> T_Instruction 
sem_Instruction_Virtual vid_ kind_ = T_Instruction (return st47) where
   {-# NOINLINE st47 #-}
   st47 = let
      v46 :: T_Instruction_v46 
      v46 = \ (T_Instruction_vIn46 _lhsIisHandler _lhsIsources) -> ( let
         _kindX185 = Control.Monad.Identity.runIdentity (attach_T_VirtKind (kind_))
         (T_VirtKind_vOut184 _kindIoutput) = inv_VirtKind_s185 _kindX185 (T_VirtKind_vIn184 )
         _lhsObranching :: BranchingInfo
         _lhsObranching = rule778  ()
         _lhsOisReturn :: Bool
         _lhsOisReturn = rule779  ()
         _output = rule780 _kindIoutput vid_
         _lhsOoutput :: Instruction
         _lhsOoutput = rule781 _output
         __result_ = T_Instruction_vOut46 _lhsObranching _lhsOisReturn _lhsOoutput
         in __result_ )
     in C_Instruction_s47 v46
   {-# INLINE rule778 #-}
   rule778 = \  (_ :: ()) ->
                                    dfltBranch
   {-# INLINE rule779 #-}
   rule779 = \  (_ :: ()) ->
     False
   {-# INLINE rule780 #-}
   rule780 = \ ((_kindIoutput) :: VirtKind) vid_ ->
     Instruction_Virtual vid_ _kindIoutput
   {-# INLINE rule781 #-}
   rule781 = \ _output ->
     _output

-- Instructions ------------------------------------------------
-- data
type Instructions  = [ LabInstruction ]

-- cata
{-# NOINLINE sem_Instructions #-}
sem_Instructions :: Instructions  -> T_Instructions 
sem_Instructions list = Prelude.foldr sem_Instructions_Cons sem_Instructions_Nil (Prelude.map sem_LabInstruction list)

-- semantic domain
newtype T_Instructions  = T_Instructions {
                                         attach_T_Instructions :: Identity (T_Instructions_s50 )
                                         }
newtype T_Instructions_s50  = C_Instructions_s50 {
                                                 inv_Instructions_s50 :: (T_Instructions_v49 )
                                                 }
data T_Instructions_s51  = C_Instructions_s51
type T_Instructions_v49  = (T_Instructions_vIn49 ) -> (T_Instructions_vOut49 )
data T_Instructions_vIn49  = T_Instructions_vIn49 (IntMap [BranchSource]) (Word32) (IntMap Bool)
data T_Instructions_vOut49  = T_Instructions_vOut49 (Maybe Int) (DeadGraph) (DeadSem) (Map BranchSource [Int]) (Instructions)
{-# NOINLINE sem_Instructions_Cons #-}
sem_Instructions_Cons :: T_LabInstruction  -> T_Instructions  -> T_Instructions 
sem_Instructions_Cons hd_ tl_ = T_Instructions (return st50) where
   {-# NOINLINE st50 #-}
   st50 = let
      v49 :: T_Instructions_v49 
      v49 = \ (T_Instructions_vIn49 _lhsIdistSources _lhsImethodId _lhsIreachRes) -> ( let
         _hdX59 = Control.Monad.Identity.runIdentity (attach_T_LabInstruction (hd_))
         _tlX50 = Control.Monad.Identity.runIdentity (attach_T_Instructions (tl_))
         (T_LabInstruction_vOut58 _hdIgathEdges _hdIgathNodes _hdIgathSources _hdIisDead _hdIlabel _hdIoutput) = inv_LabInstruction_s59 _hdX59 (T_LabInstruction_vIn58 _hdOdistSources _hdOfollowup _hdOmethodId _hdOreachRes)
         (T_Instructions_vOut49 _tlIfollowup _tlIgathEdges _tlIgathNodes _tlIgathSources _tlIoutput) = inv_Instructions_s50 _tlX50 (T_Instructions_vIn49 _tlOdistSources _tlOmethodId _tlOreachRes)
         _lhsOoutput :: Instructions
         _lhsOoutput = rule782 _hdIisDead _hdIoutput _tlIoutput
         _lhsOfollowup :: Maybe Int
         _lhsOfollowup = rule783 _hdIlabel
         _hdOfollowup = rule784 _tlIfollowup
         _lhsOgathEdges :: DeadGraph
         _lhsOgathEdges = rule785 _hdIgathEdges _tlIgathEdges
         _lhsOgathNodes :: DeadSem
         _lhsOgathNodes = rule786 _hdIgathNodes _tlIgathNodes
         _lhsOgathSources :: Map BranchSource [Int]
         _lhsOgathSources = rule787 _hdIgathSources _tlIgathSources
         _output = rule788 _hdIoutput _tlIoutput
         _hdOdistSources = rule789 _lhsIdistSources
         _hdOmethodId = rule790 _lhsImethodId
         _hdOreachRes = rule791 _lhsIreachRes
         _tlOdistSources = rule792 _lhsIdistSources
         _tlOmethodId = rule793 _lhsImethodId
         _tlOreachRes = rule794 _lhsIreachRes
         __result_ = T_Instructions_vOut49 _lhsOfollowup _lhsOgathEdges _lhsOgathNodes _lhsOgathSources _lhsOoutput
         in __result_ )
     in C_Instructions_s50 v49
   {-# INLINE rule782 #-}
   rule782 = \ ((_hdIisDead) :: Bool) ((_hdIoutput) :: LabInstruction) ((_tlIoutput) :: Instructions) ->
                 if _hdIisDead
                 then _tlIoutput
                 else _hdIoutput : _tlIoutput
   {-# INLINE rule783 #-}
   rule783 = \ ((_hdIlabel) :: Int) ->
                           Just _hdIlabel
   {-# INLINE rule784 #-}
   rule784 = \ ((_tlIfollowup) :: Maybe Int) ->
                           _tlIfollowup
   {-# INLINE rule785 #-}
   rule785 = \ ((_hdIgathEdges) :: DeadGraph) ((_tlIgathEdges) :: DeadGraph) ->
     _hdIgathEdges `mappend` _tlIgathEdges
   {-# INLINE rule786 #-}
   rule786 = \ ((_hdIgathNodes) :: DeadSem) ((_tlIgathNodes) :: DeadSem) ->
     _hdIgathNodes `mappend` _tlIgathNodes
   {-# INLINE rule787 #-}
   rule787 = \ ((_hdIgathSources) :: Map BranchSource [Int]) ((_tlIgathSources) :: Map BranchSource [Int]) ->
     _hdIgathSources `m'mappend` _tlIgathSources
   {-# INLINE rule788 #-}
   rule788 = \ ((_hdIoutput) :: LabInstruction) ((_tlIoutput) :: Instructions) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule789 #-}
   rule789 = \ ((_lhsIdistSources) :: IntMap [BranchSource]) ->
     _lhsIdistSources
   {-# INLINE rule790 #-}
   rule790 = \ ((_lhsImethodId) :: Word32) ->
     _lhsImethodId
   {-# INLINE rule791 #-}
   rule791 = \ ((_lhsIreachRes) :: IntMap Bool) ->
     _lhsIreachRes
   {-# INLINE rule792 #-}
   rule792 = \ ((_lhsIdistSources) :: IntMap [BranchSource]) ->
     _lhsIdistSources
   {-# INLINE rule793 #-}
   rule793 = \ ((_lhsImethodId) :: Word32) ->
     _lhsImethodId
   {-# INLINE rule794 #-}
   rule794 = \ ((_lhsIreachRes) :: IntMap Bool) ->
     _lhsIreachRes
{-# NOINLINE sem_Instructions_Nil #-}
sem_Instructions_Nil ::  T_Instructions 
sem_Instructions_Nil  = T_Instructions (return st50) where
   {-# NOINLINE st50 #-}
   st50 = let
      v49 :: T_Instructions_v49 
      v49 = \ (T_Instructions_vIn49 _lhsIdistSources _lhsImethodId _lhsIreachRes) -> ( let
         _lhsOfollowup :: Maybe Int
         _lhsOfollowup = rule795  ()
         _lhsOgathEdges :: DeadGraph
         _lhsOgathEdges = rule796  ()
         _lhsOgathNodes :: DeadSem
         _lhsOgathNodes = rule797  ()
         _lhsOgathSources :: Map BranchSource [Int]
         _lhsOgathSources = rule798  ()
         _output = rule799  ()
         _lhsOoutput :: Instructions
         _lhsOoutput = rule800 _output
         __result_ = T_Instructions_vOut49 _lhsOfollowup _lhsOgathEdges _lhsOgathNodes _lhsOgathSources _lhsOoutput
         in __result_ )
     in C_Instructions_s50 v49
   {-# INLINE rule795 #-}
   rule795 = \  (_ :: ()) ->
                           Nothing
   {-# INLINE rule796 #-}
   rule796 = \  (_ :: ()) ->
     mempty
   {-# INLINE rule797 #-}
   rule797 = \  (_ :: ()) ->
     mempty
   {-# INLINE rule798 #-}
   rule798 = \  (_ :: ()) ->
     mempty
   {-# INLINE rule799 #-}
   rule799 = \  (_ :: ()) ->
     []
   {-# INLINE rule800 #-}
   rule800 = \ _output ->
     _output

-- InstructionsTop ---------------------------------------------
-- data
data InstructionsTop 
  = InstructionsTop_Top {instructions_InstructionsTop_Top :: (Instructions)}

-- cata
{-# INLINE sem_InstructionsTop #-}
sem_InstructionsTop :: InstructionsTop  -> T_InstructionsTop 
sem_InstructionsTop ( InstructionsTop_Top instructions_ ) = sem_InstructionsTop_Top ( sem_Instructions instructions_ )

-- semantic domain
newtype T_InstructionsTop  = T_InstructionsTop {
                                               attach_T_InstructionsTop :: Identity (T_InstructionsTop_s53 )
                                               }
newtype T_InstructionsTop_s53  = C_InstructionsTop_s53 {
                                                       inv_InstructionsTop_s53 :: (T_InstructionsTop_v52 )
                                                       }
data T_InstructionsTop_s54  = C_InstructionsTop_s54
type T_InstructionsTop_v52  = (T_InstructionsTop_vIn52 ) -> (T_InstructionsTop_vOut52 )
data T_InstructionsTop_vIn52  = T_InstructionsTop_vIn52 (IntMap [BranchSource]) (Word32) (IntMap Bool)
data T_InstructionsTop_vOut52  = T_InstructionsTop_vOut52 (Maybe Int) (DeadGraph) (DeadSem) (Map BranchSource [Int]) (InstructionsTop)
{-# NOINLINE sem_InstructionsTop_Top #-}
sem_InstructionsTop_Top :: T_Instructions  -> T_InstructionsTop 
sem_InstructionsTop_Top instructions_ = T_InstructionsTop (return st53) where
   {-# NOINLINE st53 #-}
   st53 = let
      v52 :: T_InstructionsTop_v52 
      v52 = \ (T_InstructionsTop_vIn52 _lhsIdistSources _lhsImethodId _lhsIreachRes) -> ( let
         _instructionsX50 = Control.Monad.Identity.runIdentity (attach_T_Instructions (instructions_))
         (T_Instructions_vOut49 _instructionsIfollowup _instructionsIgathEdges _instructionsIgathNodes _instructionsIgathSources _instructionsIoutput) = inv_Instructions_s50 _instructionsX50 (T_Instructions_vIn49 _instructionsOdistSources _instructionsOmethodId _instructionsOreachRes)
         _lhsOgathEdges :: DeadGraph
         _lhsOgathEdges = rule801 _instructionsIgathEdges
         _lhsOgathNodes :: DeadSem
         _lhsOgathNodes = rule802 _instructionsIgathNodes
         _lhsOgathSources :: Map BranchSource [Int]
         _lhsOgathSources = rule803 _instructionsIgathSources
         _output = rule804 _instructionsIoutput
         _lhsOoutput :: InstructionsTop
         _lhsOoutput = rule805 _output
         _lhsOfollowup :: Maybe Int
         _lhsOfollowup = rule806 _instructionsIfollowup
         _instructionsOdistSources = rule807 _lhsIdistSources
         _instructionsOmethodId = rule808 _lhsImethodId
         _instructionsOreachRes = rule809 _lhsIreachRes
         __result_ = T_InstructionsTop_vOut52 _lhsOfollowup _lhsOgathEdges _lhsOgathNodes _lhsOgathSources _lhsOoutput
         in __result_ )
     in C_InstructionsTop_s53 v52
   {-# INLINE rule801 #-}
   rule801 = \ ((_instructionsIgathEdges) :: DeadGraph) ->
     _instructionsIgathEdges
   {-# INLINE rule802 #-}
   rule802 = \ ((_instructionsIgathNodes) :: DeadSem) ->
     _instructionsIgathNodes
   {-# INLINE rule803 #-}
   rule803 = \ ((_instructionsIgathSources) :: Map BranchSource [Int]) ->
     _instructionsIgathSources
   {-# INLINE rule804 #-}
   rule804 = \ ((_instructionsIoutput) :: Instructions) ->
     InstructionsTop_Top _instructionsIoutput
   {-# INLINE rule805 #-}
   rule805 = \ _output ->
     _output
   {-# INLINE rule806 #-}
   rule806 = \ ((_instructionsIfollowup) :: Maybe Int) ->
     _instructionsIfollowup
   {-# INLINE rule807 #-}
   rule807 = \ ((_lhsIdistSources) :: IntMap [BranchSource]) ->
     _lhsIdistSources
   {-# INLINE rule808 #-}
   rule808 = \ ((_lhsImethodId) :: Word32) ->
     _lhsImethodId
   {-# INLINE rule809 #-}
   rule809 = \ ((_lhsIreachRes) :: IntMap Bool) ->
     _lhsIreachRes

-- Interfaces --------------------------------------------------
-- data
type Interfaces  = [ Word32 ]

-- cata
{-# NOINLINE sem_Interfaces #-}
sem_Interfaces :: Interfaces  -> T_Interfaces 
sem_Interfaces list = Prelude.foldr sem_Interfaces_Cons sem_Interfaces_Nil list

-- semantic domain
newtype T_Interfaces  = T_Interfaces {
                                     attach_T_Interfaces :: Identity (T_Interfaces_s56 )
                                     }
newtype T_Interfaces_s56  = C_Interfaces_s56 {
                                             inv_Interfaces_s56 :: (T_Interfaces_v55 )
                                             }
data T_Interfaces_s57  = C_Interfaces_s57
type T_Interfaces_v55  = (T_Interfaces_vIn55 ) -> (T_Interfaces_vOut55 )
data T_Interfaces_vIn55  = T_Interfaces_vIn55 
data T_Interfaces_vOut55  = T_Interfaces_vOut55 (Interfaces)
{-# NOINLINE sem_Interfaces_Cons #-}
sem_Interfaces_Cons :: (Word32) -> T_Interfaces  -> T_Interfaces 
sem_Interfaces_Cons hd_ tl_ = T_Interfaces (return st56) where
   {-# NOINLINE st56 #-}
   st56 = let
      v55 :: T_Interfaces_v55 
      v55 = \ (T_Interfaces_vIn55 ) -> ( let
         _tlX56 = Control.Monad.Identity.runIdentity (attach_T_Interfaces (tl_))
         (T_Interfaces_vOut55 _tlIoutput) = inv_Interfaces_s56 _tlX56 (T_Interfaces_vIn55 )
         _output = rule810 _tlIoutput hd_
         _lhsOoutput :: Interfaces
         _lhsOoutput = rule811 _output
         __result_ = T_Interfaces_vOut55 _lhsOoutput
         in __result_ )
     in C_Interfaces_s56 v55
   {-# INLINE rule810 #-}
   rule810 = \ ((_tlIoutput) :: Interfaces) hd_ ->
     (:) hd_ _tlIoutput
   {-# INLINE rule811 #-}
   rule811 = \ _output ->
     _output
{-# NOINLINE sem_Interfaces_Nil #-}
sem_Interfaces_Nil ::  T_Interfaces 
sem_Interfaces_Nil  = T_Interfaces (return st56) where
   {-# NOINLINE st56 #-}
   st56 = let
      v55 :: T_Interfaces_v55 
      v55 = \ (T_Interfaces_vIn55 ) -> ( let
         _output = rule812  ()
         _lhsOoutput :: Interfaces
         _lhsOoutput = rule813 _output
         __result_ = T_Interfaces_vOut55 _lhsOoutput
         in __result_ )
     in C_Interfaces_s56 v55
   {-# INLINE rule812 #-}
   rule812 = \  (_ :: ()) ->
     []
   {-# INLINE rule813 #-}
   rule813 = \ _output ->
     _output

-- LabInstruction ----------------------------------------------
-- data
data LabInstruction 
  = LabInstruction_Instr {label_LabInstruction_Instr :: (Int), instruction_LabInstruction_Instr :: (Instruction)}

-- cata
{-# INLINE sem_LabInstruction #-}
sem_LabInstruction :: LabInstruction  -> T_LabInstruction 
sem_LabInstruction ( LabInstruction_Instr label_ instruction_ ) = sem_LabInstruction_Instr label_ ( sem_Instruction instruction_ )

-- semantic domain
newtype T_LabInstruction  = T_LabInstruction {
                                             attach_T_LabInstruction :: Identity (T_LabInstruction_s59 )
                                             }
newtype T_LabInstruction_s59  = C_LabInstruction_s59 {
                                                     inv_LabInstruction_s59 :: (T_LabInstruction_v58 )
                                                     }
data T_LabInstruction_s60  = C_LabInstruction_s60
type T_LabInstruction_v58  = (T_LabInstruction_vIn58 ) -> (T_LabInstruction_vOut58 )
data T_LabInstruction_vIn58  = T_LabInstruction_vIn58 (IntMap [BranchSource]) (Maybe Int) (Word32) (IntMap Bool)
data T_LabInstruction_vOut58  = T_LabInstruction_vOut58 (DeadGraph) (DeadSem) (Map BranchSource [Int]) (Bool) (Int) (LabInstruction)
{-# NOINLINE sem_LabInstruction_Instr #-}
sem_LabInstruction_Instr :: (Int) -> T_Instruction  -> T_LabInstruction 
sem_LabInstruction_Instr label_ instruction_ = T_LabInstruction (return st59) where
   {-# NOINLINE st59 #-}
   st59 = let
      v58 :: T_LabInstruction_v58 
      v58 = \ (T_LabInstruction_vIn58 _lhsIdistSources _lhsIfollowup _lhsImethodId _lhsIreachRes) -> ( let
         _instructionX47 = Control.Monad.Identity.runIdentity (attach_T_Instruction (instruction_))
         (T_Instruction_vOut46 _instructionIbranching _instructionIisReturn _instructionIoutput) = inv_Instruction_s47 _instructionX47 (T_Instruction_vIn46 _instructionOisHandler _instructionOsources)
         _lhsOgathNodes :: DeadSem
         _lhsOgathNodes = rule814 label_
         _lhsOgathEdges :: DeadGraph
         _lhsOgathEdges = rule815 _targets label_
         _lhsOisDead :: Bool
         _lhsOisDead = rule816 _lhsIreachRes label_
         _lhsOlabel :: Int
         _lhsOlabel = rule817 label_
         _source = rule818 label_
         _targets = rule819 _instructionIbranching _lhsIfollowup
         _lhsOgathSources :: Map BranchSource [Int]
         _lhsOgathSources = rule820 _source _targets
         _sources = rule821 _lhsIdistSources label_
         _isHandler = rule822 _sources
         _output = rule823 _instructionIoutput label_
         _lhsOoutput :: LabInstruction
         _lhsOoutput = rule824 _output
         _instructionOisHandler = rule825 _isHandler
         _instructionOsources = rule826 _sources
         __result_ = T_LabInstruction_vOut58 _lhsOgathEdges _lhsOgathNodes _lhsOgathSources _lhsOisDead _lhsOlabel _lhsOoutput
         in __result_ )
     in C_LabInstruction_s59 v58
   {-# INLINE rule814 #-}
   rule814 = \ label_ ->
                    node label_ propagate
   {-# INLINE rule815 #-}
   rule815 = \ _targets label_ ->
                    mconcat [ edge label_ t | t <- _targets     ]
   {-# INLINE rule816 #-}
   rule816 = \ ((_lhsIreachRes) :: IntMap Bool) label_ ->
                 case IntMap.lookup label_ _lhsIreachRes of
                   Just isLive -> not isLive
                   Nothing     -> False
   {-# INLINE rule817 #-}
   rule817 = \ label_ ->
                                          label_
   {-# INLINE rule818 #-}
   rule818 = \ label_ ->
                      SourceInstruction label_
   {-# INLINE rule819 #-}
   rule819 = \ ((_instructionIbranching) :: BranchingInfo) ((_lhsIfollowup) :: Maybe Int) ->
                      (if branchNext _instructionIbranching then maybe [] return _lhsIfollowup else [])
                       ++ branchOther _instructionIbranching
   {-# INLINE rule820 #-}
   rule820 = \ _source _targets ->
                      Map.singleton _source     _targets
   {-# INLINE rule821 #-}
   rule821 = \ ((_lhsIdistSources) :: IntMap [BranchSource]) label_ ->
                     IntMap.findWithDefault [] label_ _lhsIdistSources
   {-# INLINE rule822 #-}
   rule822 = \ _sources ->
                     listToMaybe [ Ref e | (SourceException e) <- _sources     ]
   {-# INLINE rule823 #-}
   rule823 = \ ((_instructionIoutput) :: Instruction) label_ ->
     LabInstruction_Instr label_ _instructionIoutput
   {-# INLINE rule824 #-}
   rule824 = \ _output ->
     _output
   {-# INLINE rule825 #-}
   rule825 = \ _isHandler ->
     _isHandler
   {-# INLINE rule826 #-}
   rule826 = \ _sources ->
     _sources

-- MetaInfo ----------------------------------------------------
-- data
data MetaInfo 
  = MetaInfo_Info {name_MetaInfo_Info :: (Word32), items_MetaInfo_Info :: (MetaItems)}

-- cata
{-# INLINE sem_MetaInfo #-}
sem_MetaInfo :: MetaInfo  -> T_MetaInfo 
sem_MetaInfo ( MetaInfo_Info name_ items_ ) = sem_MetaInfo_Info name_ ( sem_MetaItems items_ )

-- semantic domain
newtype T_MetaInfo  = T_MetaInfo {
                                 attach_T_MetaInfo :: Identity (T_MetaInfo_s62 )
                                 }
newtype T_MetaInfo_s62  = C_MetaInfo_s62 {
                                         inv_MetaInfo_s62 :: (T_MetaInfo_v61 )
                                         }
data T_MetaInfo_s63  = C_MetaInfo_s63
type T_MetaInfo_v61  = (T_MetaInfo_vIn61 ) -> (T_MetaInfo_vOut61 )
data T_MetaInfo_vIn61  = T_MetaInfo_vIn61 
data T_MetaInfo_vOut61  = T_MetaInfo_vOut61 (MetaInfo)
{-# NOINLINE sem_MetaInfo_Info #-}
sem_MetaInfo_Info :: (Word32) -> T_MetaItems  -> T_MetaInfo 
sem_MetaInfo_Info name_ items_ = T_MetaInfo (return st62) where
   {-# NOINLINE st62 #-}
   st62 = let
      v61 :: T_MetaInfo_v61 
      v61 = \ (T_MetaInfo_vIn61 ) -> ( let
         _itemsX71 = Control.Monad.Identity.runIdentity (attach_T_MetaItems (items_))
         (T_MetaItems_vOut70 _itemsIoutput) = inv_MetaItems_s71 _itemsX71 (T_MetaItems_vIn70 )
         _output = rule827 _itemsIoutput name_
         _lhsOoutput :: MetaInfo
         _lhsOoutput = rule828 _output
         __result_ = T_MetaInfo_vOut61 _lhsOoutput
         in __result_ )
     in C_MetaInfo_s62 v61
   {-# INLINE rule827 #-}
   rule827 = \ ((_itemsIoutput) :: MetaItems) name_ ->
     MetaInfo_Info name_ _itemsIoutput
   {-# INLINE rule828 #-}
   rule828 = \ _output ->
     _output

-- MetaInfos ---------------------------------------------------
-- data
type MetaInfos  = [ MetaInfo ]

-- cata
{-# NOINLINE sem_MetaInfos #-}
sem_MetaInfos :: MetaInfos  -> T_MetaInfos 
sem_MetaInfos list = Prelude.foldr sem_MetaInfos_Cons sem_MetaInfos_Nil (Prelude.map sem_MetaInfo list)

-- semantic domain
newtype T_MetaInfos  = T_MetaInfos {
                                   attach_T_MetaInfos :: Identity (T_MetaInfos_s65 )
                                   }
newtype T_MetaInfos_s65  = C_MetaInfos_s65 {
                                           inv_MetaInfos_s65 :: (T_MetaInfos_v64 )
                                           }
data T_MetaInfos_s66  = C_MetaInfos_s66
type T_MetaInfos_v64  = (T_MetaInfos_vIn64 ) -> (T_MetaInfos_vOut64 )
data T_MetaInfos_vIn64  = T_MetaInfos_vIn64 
data T_MetaInfos_vOut64  = T_MetaInfos_vOut64 (MetaInfos)
{-# NOINLINE sem_MetaInfos_Cons #-}
sem_MetaInfos_Cons :: T_MetaInfo  -> T_MetaInfos  -> T_MetaInfos 
sem_MetaInfos_Cons hd_ tl_ = T_MetaInfos (return st65) where
   {-# NOINLINE st65 #-}
   st65 = let
      v64 :: T_MetaInfos_v64 
      v64 = \ (T_MetaInfos_vIn64 ) -> ( let
         _hdX62 = Control.Monad.Identity.runIdentity (attach_T_MetaInfo (hd_))
         _tlX65 = Control.Monad.Identity.runIdentity (attach_T_MetaInfos (tl_))
         (T_MetaInfo_vOut61 _hdIoutput) = inv_MetaInfo_s62 _hdX62 (T_MetaInfo_vIn61 )
         (T_MetaInfos_vOut64 _tlIoutput) = inv_MetaInfos_s65 _tlX65 (T_MetaInfos_vIn64 )
         _output = rule829 _hdIoutput _tlIoutput
         _lhsOoutput :: MetaInfos
         _lhsOoutput = rule830 _output
         __result_ = T_MetaInfos_vOut64 _lhsOoutput
         in __result_ )
     in C_MetaInfos_s65 v64
   {-# INLINE rule829 #-}
   rule829 = \ ((_hdIoutput) :: MetaInfo) ((_tlIoutput) :: MetaInfos) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule830 #-}
   rule830 = \ _output ->
     _output
{-# NOINLINE sem_MetaInfos_Nil #-}
sem_MetaInfos_Nil ::  T_MetaInfos 
sem_MetaInfos_Nil  = T_MetaInfos (return st65) where
   {-# NOINLINE st65 #-}
   st65 = let
      v64 :: T_MetaInfos_v64 
      v64 = \ (T_MetaInfos_vIn64 ) -> ( let
         _output = rule831  ()
         _lhsOoutput :: MetaInfos
         _lhsOoutput = rule832 _output
         __result_ = T_MetaInfos_vOut64 _lhsOoutput
         in __result_ )
     in C_MetaInfos_s65 v64
   {-# INLINE rule831 #-}
   rule831 = \  (_ :: ()) ->
     []
   {-# INLINE rule832 #-}
   rule832 = \ _output ->
     _output

-- MetaItem ----------------------------------------------------
-- data
data MetaItem 
  = MetaItem_Item {key_MetaItem_Item :: (Word32), value_MetaItem_Item :: (Word32)}

-- cata
{-# INLINE sem_MetaItem #-}
sem_MetaItem :: MetaItem  -> T_MetaItem 
sem_MetaItem ( MetaItem_Item key_ value_ ) = sem_MetaItem_Item key_ value_

-- semantic domain
newtype T_MetaItem  = T_MetaItem {
                                 attach_T_MetaItem :: Identity (T_MetaItem_s68 )
                                 }
newtype T_MetaItem_s68  = C_MetaItem_s68 {
                                         inv_MetaItem_s68 :: (T_MetaItem_v67 )
                                         }
data T_MetaItem_s69  = C_MetaItem_s69
type T_MetaItem_v67  = (T_MetaItem_vIn67 ) -> (T_MetaItem_vOut67 )
data T_MetaItem_vIn67  = T_MetaItem_vIn67 
data T_MetaItem_vOut67  = T_MetaItem_vOut67 (MetaItem)
{-# NOINLINE sem_MetaItem_Item #-}
sem_MetaItem_Item :: (Word32) -> (Word32) -> T_MetaItem 
sem_MetaItem_Item key_ value_ = T_MetaItem (return st68) where
   {-# NOINLINE st68 #-}
   st68 = let
      v67 :: T_MetaItem_v67 
      v67 = \ (T_MetaItem_vIn67 ) -> ( let
         _output = rule833 key_ value_
         _lhsOoutput :: MetaItem
         _lhsOoutput = rule834 _output
         __result_ = T_MetaItem_vOut67 _lhsOoutput
         in __result_ )
     in C_MetaItem_s68 v67
   {-# INLINE rule833 #-}
   rule833 = \ key_ value_ ->
     MetaItem_Item key_ value_
   {-# INLINE rule834 #-}
   rule834 = \ _output ->
     _output

-- MetaItems ---------------------------------------------------
-- data
type MetaItems  = [ MetaItem ]

-- cata
{-# NOINLINE sem_MetaItems #-}
sem_MetaItems :: MetaItems  -> T_MetaItems 
sem_MetaItems list = Prelude.foldr sem_MetaItems_Cons sem_MetaItems_Nil (Prelude.map sem_MetaItem list)

-- semantic domain
newtype T_MetaItems  = T_MetaItems {
                                   attach_T_MetaItems :: Identity (T_MetaItems_s71 )
                                   }
newtype T_MetaItems_s71  = C_MetaItems_s71 {
                                           inv_MetaItems_s71 :: (T_MetaItems_v70 )
                                           }
data T_MetaItems_s72  = C_MetaItems_s72
type T_MetaItems_v70  = (T_MetaItems_vIn70 ) -> (T_MetaItems_vOut70 )
data T_MetaItems_vIn70  = T_MetaItems_vIn70 
data T_MetaItems_vOut70  = T_MetaItems_vOut70 (MetaItems)
{-# NOINLINE sem_MetaItems_Cons #-}
sem_MetaItems_Cons :: T_MetaItem  -> T_MetaItems  -> T_MetaItems 
sem_MetaItems_Cons hd_ tl_ = T_MetaItems (return st71) where
   {-# NOINLINE st71 #-}
   st71 = let
      v70 :: T_MetaItems_v70 
      v70 = \ (T_MetaItems_vIn70 ) -> ( let
         _hdX68 = Control.Monad.Identity.runIdentity (attach_T_MetaItem (hd_))
         _tlX71 = Control.Monad.Identity.runIdentity (attach_T_MetaItems (tl_))
         (T_MetaItem_vOut67 _hdIoutput) = inv_MetaItem_s68 _hdX68 (T_MetaItem_vIn67 )
         (T_MetaItems_vOut70 _tlIoutput) = inv_MetaItems_s71 _tlX71 (T_MetaItems_vIn70 )
         _output = rule835 _hdIoutput _tlIoutput
         _lhsOoutput :: MetaItems
         _lhsOoutput = rule836 _output
         __result_ = T_MetaItems_vOut70 _lhsOoutput
         in __result_ )
     in C_MetaItems_s71 v70
   {-# INLINE rule835 #-}
   rule835 = \ ((_hdIoutput) :: MetaItem) ((_tlIoutput) :: MetaItems) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule836 #-}
   rule836 = \ _output ->
     _output
{-# NOINLINE sem_MetaItems_Nil #-}
sem_MetaItems_Nil ::  T_MetaItems 
sem_MetaItems_Nil  = T_MetaItems (return st71) where
   {-# NOINLINE st71 #-}
   st71 = let
      v70 :: T_MetaItems_v70 
      v70 = \ (T_MetaItems_vIn70 ) -> ( let
         _output = rule837  ()
         _lhsOoutput :: MetaItems
         _lhsOoutput = rule838 _output
         __result_ = T_MetaItems_vOut70 _lhsOoutput
         in __result_ )
     in C_MetaItems_s71 v70
   {-# INLINE rule837 #-}
   rule837 = \  (_ :: ()) ->
     []
   {-# INLINE rule838 #-}
   rule838 = \ _output ->
     _output

-- MethodFlag --------------------------------------------------
-- data
data MethodFlag 
  = MethodFlag_NeedArgs {}
  | MethodFlag_NeedAct {}
  | MethodFlag_NeedRest {}
  | MethodFlag_HasOptionals {}
  | MethodFlag_SetDXNS {}
  | MethodFlag_HasParamNames {}

-- cata
{-# NOINLINE sem_MethodFlag #-}
sem_MethodFlag :: MethodFlag  -> T_MethodFlag 
sem_MethodFlag ( MethodFlag_NeedArgs  ) = sem_MethodFlag_NeedArgs 
sem_MethodFlag ( MethodFlag_NeedAct  ) = sem_MethodFlag_NeedAct 
sem_MethodFlag ( MethodFlag_NeedRest  ) = sem_MethodFlag_NeedRest 
sem_MethodFlag ( MethodFlag_HasOptionals  ) = sem_MethodFlag_HasOptionals 
sem_MethodFlag ( MethodFlag_SetDXNS  ) = sem_MethodFlag_SetDXNS 
sem_MethodFlag ( MethodFlag_HasParamNames  ) = sem_MethodFlag_HasParamNames 

-- semantic domain
newtype T_MethodFlag  = T_MethodFlag {
                                     attach_T_MethodFlag :: Identity (T_MethodFlag_s74 )
                                     }
newtype T_MethodFlag_s74  = C_MethodFlag_s74 {
                                             inv_MethodFlag_s74 :: (T_MethodFlag_v73 )
                                             }
data T_MethodFlag_s75  = C_MethodFlag_s75
type T_MethodFlag_v73  = (T_MethodFlag_vIn73 ) -> (T_MethodFlag_vOut73 )
data T_MethodFlag_vIn73  = T_MethodFlag_vIn73 
data T_MethodFlag_vOut73  = T_MethodFlag_vOut73 (MethodFlag)
{-# NOINLINE sem_MethodFlag_NeedArgs #-}
sem_MethodFlag_NeedArgs ::  T_MethodFlag 
sem_MethodFlag_NeedArgs  = T_MethodFlag (return st74) where
   {-# NOINLINE st74 #-}
   st74 = let
      v73 :: T_MethodFlag_v73 
      v73 = \ (T_MethodFlag_vIn73 ) -> ( let
         _output = rule839  ()
         _lhsOoutput :: MethodFlag
         _lhsOoutput = rule840 _output
         __result_ = T_MethodFlag_vOut73 _lhsOoutput
         in __result_ )
     in C_MethodFlag_s74 v73
   {-# INLINE rule839 #-}
   rule839 = \  (_ :: ()) ->
     MethodFlag_NeedArgs
   {-# INLINE rule840 #-}
   rule840 = \ _output ->
     _output
{-# NOINLINE sem_MethodFlag_NeedAct #-}
sem_MethodFlag_NeedAct ::  T_MethodFlag 
sem_MethodFlag_NeedAct  = T_MethodFlag (return st74) where
   {-# NOINLINE st74 #-}
   st74 = let
      v73 :: T_MethodFlag_v73 
      v73 = \ (T_MethodFlag_vIn73 ) -> ( let
         _output = rule841  ()
         _lhsOoutput :: MethodFlag
         _lhsOoutput = rule842 _output
         __result_ = T_MethodFlag_vOut73 _lhsOoutput
         in __result_ )
     in C_MethodFlag_s74 v73
   {-# INLINE rule841 #-}
   rule841 = \  (_ :: ()) ->
     MethodFlag_NeedAct
   {-# INLINE rule842 #-}
   rule842 = \ _output ->
     _output
{-# NOINLINE sem_MethodFlag_NeedRest #-}
sem_MethodFlag_NeedRest ::  T_MethodFlag 
sem_MethodFlag_NeedRest  = T_MethodFlag (return st74) where
   {-# NOINLINE st74 #-}
   st74 = let
      v73 :: T_MethodFlag_v73 
      v73 = \ (T_MethodFlag_vIn73 ) -> ( let
         _output = rule843  ()
         _lhsOoutput :: MethodFlag
         _lhsOoutput = rule844 _output
         __result_ = T_MethodFlag_vOut73 _lhsOoutput
         in __result_ )
     in C_MethodFlag_s74 v73
   {-# INLINE rule843 #-}
   rule843 = \  (_ :: ()) ->
     MethodFlag_NeedRest
   {-# INLINE rule844 #-}
   rule844 = \ _output ->
     _output
{-# NOINLINE sem_MethodFlag_HasOptionals #-}
sem_MethodFlag_HasOptionals ::  T_MethodFlag 
sem_MethodFlag_HasOptionals  = T_MethodFlag (return st74) where
   {-# NOINLINE st74 #-}
   st74 = let
      v73 :: T_MethodFlag_v73 
      v73 = \ (T_MethodFlag_vIn73 ) -> ( let
         _output = rule845  ()
         _lhsOoutput :: MethodFlag
         _lhsOoutput = rule846 _output
         __result_ = T_MethodFlag_vOut73 _lhsOoutput
         in __result_ )
     in C_MethodFlag_s74 v73
   {-# INLINE rule845 #-}
   rule845 = \  (_ :: ()) ->
     MethodFlag_HasOptionals
   {-# INLINE rule846 #-}
   rule846 = \ _output ->
     _output
{-# NOINLINE sem_MethodFlag_SetDXNS #-}
sem_MethodFlag_SetDXNS ::  T_MethodFlag 
sem_MethodFlag_SetDXNS  = T_MethodFlag (return st74) where
   {-# NOINLINE st74 #-}
   st74 = let
      v73 :: T_MethodFlag_v73 
      v73 = \ (T_MethodFlag_vIn73 ) -> ( let
         _output = rule847  ()
         _lhsOoutput :: MethodFlag
         _lhsOoutput = rule848 _output
         __result_ = T_MethodFlag_vOut73 _lhsOoutput
         in __result_ )
     in C_MethodFlag_s74 v73
   {-# INLINE rule847 #-}
   rule847 = \  (_ :: ()) ->
     MethodFlag_SetDXNS
   {-# INLINE rule848 #-}
   rule848 = \ _output ->
     _output
{-# NOINLINE sem_MethodFlag_HasParamNames #-}
sem_MethodFlag_HasParamNames ::  T_MethodFlag 
sem_MethodFlag_HasParamNames  = T_MethodFlag (return st74) where
   {-# NOINLINE st74 #-}
   st74 = let
      v73 :: T_MethodFlag_v73 
      v73 = \ (T_MethodFlag_vIn73 ) -> ( let
         _output = rule849  ()
         _lhsOoutput :: MethodFlag
         _lhsOoutput = rule850 _output
         __result_ = T_MethodFlag_vOut73 _lhsOoutput
         in __result_ )
     in C_MethodFlag_s74 v73
   {-# INLINE rule849 #-}
   rule849 = \  (_ :: ()) ->
     MethodFlag_HasParamNames
   {-# INLINE rule850 #-}
   rule850 = \ _output ->
     _output

-- MethodFlags -------------------------------------------------
-- data
type MethodFlags  = [ MethodFlag ]

-- cata
{-# NOINLINE sem_MethodFlags #-}
sem_MethodFlags :: MethodFlags  -> T_MethodFlags 
sem_MethodFlags list = Prelude.foldr sem_MethodFlags_Cons sem_MethodFlags_Nil (Prelude.map sem_MethodFlag list)

-- semantic domain
newtype T_MethodFlags  = T_MethodFlags {
                                       attach_T_MethodFlags :: Identity (T_MethodFlags_s77 )
                                       }
newtype T_MethodFlags_s77  = C_MethodFlags_s77 {
                                               inv_MethodFlags_s77 :: (T_MethodFlags_v76 )
                                               }
data T_MethodFlags_s78  = C_MethodFlags_s78
type T_MethodFlags_v76  = (T_MethodFlags_vIn76 ) -> (T_MethodFlags_vOut76 )
data T_MethodFlags_vIn76  = T_MethodFlags_vIn76 
data T_MethodFlags_vOut76  = T_MethodFlags_vOut76 (MethodFlags)
{-# NOINLINE sem_MethodFlags_Cons #-}
sem_MethodFlags_Cons :: T_MethodFlag  -> T_MethodFlags  -> T_MethodFlags 
sem_MethodFlags_Cons hd_ tl_ = T_MethodFlags (return st77) where
   {-# NOINLINE st77 #-}
   st77 = let
      v76 :: T_MethodFlags_v76 
      v76 = \ (T_MethodFlags_vIn76 ) -> ( let
         _hdX74 = Control.Monad.Identity.runIdentity (attach_T_MethodFlag (hd_))
         _tlX77 = Control.Monad.Identity.runIdentity (attach_T_MethodFlags (tl_))
         (T_MethodFlag_vOut73 _hdIoutput) = inv_MethodFlag_s74 _hdX74 (T_MethodFlag_vIn73 )
         (T_MethodFlags_vOut76 _tlIoutput) = inv_MethodFlags_s77 _tlX77 (T_MethodFlags_vIn76 )
         _output = rule851 _hdIoutput _tlIoutput
         _lhsOoutput :: MethodFlags
         _lhsOoutput = rule852 _output
         __result_ = T_MethodFlags_vOut76 _lhsOoutput
         in __result_ )
     in C_MethodFlags_s77 v76
   {-# INLINE rule851 #-}
   rule851 = \ ((_hdIoutput) :: MethodFlag) ((_tlIoutput) :: MethodFlags) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule852 #-}
   rule852 = \ _output ->
     _output
{-# NOINLINE sem_MethodFlags_Nil #-}
sem_MethodFlags_Nil ::  T_MethodFlags 
sem_MethodFlags_Nil  = T_MethodFlags (return st77) where
   {-# NOINLINE st77 #-}
   st77 = let
      v76 :: T_MethodFlags_v76 
      v76 = \ (T_MethodFlags_vIn76 ) -> ( let
         _output = rule853  ()
         _lhsOoutput :: MethodFlags
         _lhsOoutput = rule854 _output
         __result_ = T_MethodFlags_vOut76 _lhsOoutput
         in __result_ )
     in C_MethodFlags_s77 v76
   {-# INLINE rule853 #-}
   rule853 = \  (_ :: ()) ->
     []
   {-# INLINE rule854 #-}
   rule854 = \ _output ->
     _output

-- MethodInfo --------------------------------------------------
-- data
data MethodInfo 
  = MethodInfo_Info {return_MethodInfo_Info :: (Word32), params_MethodInfo_Info :: (ParamTypes), name_MethodInfo_Info :: (Word32), flags_MethodInfo_Info :: (MethodFlags), options_MethodInfo_Info :: (Optionals), names_MethodInfo_Info :: (ParamNames)}

-- cata
{-# INLINE sem_MethodInfo #-}
sem_MethodInfo :: MethodInfo  -> T_MethodInfo 
sem_MethodInfo ( MethodInfo_Info return_ params_ name_ flags_ options_ names_ ) = sem_MethodInfo_Info return_ ( sem_ParamTypes params_ ) name_ ( sem_MethodFlags flags_ ) ( sem_Optionals options_ ) ( sem_ParamNames names_ )

-- semantic domain
newtype T_MethodInfo  = T_MethodInfo {
                                     attach_T_MethodInfo :: Identity (T_MethodInfo_s80 )
                                     }
newtype T_MethodInfo_s80  = C_MethodInfo_s80 {
                                             inv_MethodInfo_s80 :: (T_MethodInfo_v79 )
                                             }
data T_MethodInfo_s81  = C_MethodInfo_s81
type T_MethodInfo_v79  = (T_MethodInfo_vIn79 ) -> (T_MethodInfo_vOut79 )
data T_MethodInfo_vIn79  = T_MethodInfo_vIn79 
data T_MethodInfo_vOut79  = T_MethodInfo_vOut79 (MethodInfo)
{-# NOINLINE sem_MethodInfo_Info #-}
sem_MethodInfo_Info :: (Word32) -> T_ParamTypes  -> (Word32) -> T_MethodFlags  -> T_Optionals  -> T_ParamNames  -> T_MethodInfo 
sem_MethodInfo_Info return_ params_ name_ flags_ options_ names_ = T_MethodInfo (return st80) where
   {-# NOINLINE st80 #-}
   st80 = let
      v79 :: T_MethodInfo_v79 
      v79 = \ (T_MethodInfo_vIn79 ) -> ( let
         _paramsX116 = Control.Monad.Identity.runIdentity (attach_T_ParamTypes (params_))
         _flagsX77 = Control.Monad.Identity.runIdentity (attach_T_MethodFlags (flags_))
         _optionsX110 = Control.Monad.Identity.runIdentity (attach_T_Optionals (options_))
         _namesX113 = Control.Monad.Identity.runIdentity (attach_T_ParamNames (names_))
         (T_ParamTypes_vOut115 _paramsIoutput) = inv_ParamTypes_s116 _paramsX116 (T_ParamTypes_vIn115 )
         (T_MethodFlags_vOut76 _flagsIoutput) = inv_MethodFlags_s77 _flagsX77 (T_MethodFlags_vIn76 )
         (T_Optionals_vOut109 _optionsIoutput) = inv_Optionals_s110 _optionsX110 (T_Optionals_vIn109 )
         (T_ParamNames_vOut112 _namesIoutput) = inv_ParamNames_s113 _namesX113 (T_ParamNames_vIn112 )
         _output = rule855 _flagsIoutput _namesIoutput _optionsIoutput _paramsIoutput name_ return_
         _lhsOoutput :: MethodInfo
         _lhsOoutput = rule856 _output
         __result_ = T_MethodInfo_vOut79 _lhsOoutput
         in __result_ )
     in C_MethodInfo_s80 v79
   {-# INLINE rule855 #-}
   rule855 = \ ((_flagsIoutput) :: MethodFlags) ((_namesIoutput) :: ParamNames) ((_optionsIoutput) :: Optionals) ((_paramsIoutput) :: ParamTypes) name_ return_ ->
     MethodInfo_Info return_ _paramsIoutput name_ _flagsIoutput _optionsIoutput _namesIoutput
   {-# INLINE rule856 #-}
   rule856 = \ _output ->
     _output

-- MethodInfos -------------------------------------------------
-- data
type MethodInfos  = [ MethodInfo ]

-- cata
{-# NOINLINE sem_MethodInfos #-}
sem_MethodInfos :: MethodInfos  -> T_MethodInfos 
sem_MethodInfos list = Prelude.foldr sem_MethodInfos_Cons sem_MethodInfos_Nil (Prelude.map sem_MethodInfo list)

-- semantic domain
newtype T_MethodInfos  = T_MethodInfos {
                                       attach_T_MethodInfos :: Identity (T_MethodInfos_s83 )
                                       }
newtype T_MethodInfos_s83  = C_MethodInfos_s83 {
                                               inv_MethodInfos_s83 :: (T_MethodInfos_v82 )
                                               }
data T_MethodInfos_s84  = C_MethodInfos_s84
type T_MethodInfos_v82  = (T_MethodInfos_vIn82 ) -> (T_MethodInfos_vOut82 )
data T_MethodInfos_vIn82  = T_MethodInfos_vIn82 
data T_MethodInfos_vOut82  = T_MethodInfos_vOut82 (MethodInfos)
{-# NOINLINE sem_MethodInfos_Cons #-}
sem_MethodInfos_Cons :: T_MethodInfo  -> T_MethodInfos  -> T_MethodInfos 
sem_MethodInfos_Cons hd_ tl_ = T_MethodInfos (return st83) where
   {-# NOINLINE st83 #-}
   st83 = let
      v82 :: T_MethodInfos_v82 
      v82 = \ (T_MethodInfos_vIn82 ) -> ( let
         _hdX80 = Control.Monad.Identity.runIdentity (attach_T_MethodInfo (hd_))
         _tlX83 = Control.Monad.Identity.runIdentity (attach_T_MethodInfos (tl_))
         (T_MethodInfo_vOut79 _hdIoutput) = inv_MethodInfo_s80 _hdX80 (T_MethodInfo_vIn79 )
         (T_MethodInfos_vOut82 _tlIoutput) = inv_MethodInfos_s83 _tlX83 (T_MethodInfos_vIn82 )
         _output = rule857 _hdIoutput _tlIoutput
         _lhsOoutput :: MethodInfos
         _lhsOoutput = rule858 _output
         __result_ = T_MethodInfos_vOut82 _lhsOoutput
         in __result_ )
     in C_MethodInfos_s83 v82
   {-# INLINE rule857 #-}
   rule857 = \ ((_hdIoutput) :: MethodInfo) ((_tlIoutput) :: MethodInfos) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule858 #-}
   rule858 = \ _output ->
     _output
{-# NOINLINE sem_MethodInfos_Nil #-}
sem_MethodInfos_Nil ::  T_MethodInfos 
sem_MethodInfos_Nil  = T_MethodInfos (return st83) where
   {-# NOINLINE st83 #-}
   st83 = let
      v82 :: T_MethodInfos_v82 
      v82 = \ (T_MethodInfos_vIn82 ) -> ( let
         _output = rule859  ()
         _lhsOoutput :: MethodInfos
         _lhsOoutput = rule860 _output
         __result_ = T_MethodInfos_vOut82 _lhsOoutput
         in __result_ )
     in C_MethodInfos_s83 v82
   {-# INLINE rule859 #-}
   rule859 = \  (_ :: ()) ->
     []
   {-# INLINE rule860 #-}
   rule860 = \ _output ->
     _output

-- MultinameInfo -----------------------------------------------
-- data
data MultinameInfo 
  = MultinameInfo_QName {namespace_MultinameInfo_QName :: (Word32), name_MultinameInfo_QName :: (Word32)}
  | MultinameInfo_QNameA {namespace_MultinameInfo_QNameA :: (Word32), name_MultinameInfo_QNameA :: (Word32)}
  | MultinameInfo_RTQName {name_MultinameInfo_RTQName :: (Word32)}
  | MultinameInfo_RTQNameA {name_MultinameInfo_RTQNameA :: (Word32)}
  | MultinameInfo_RTQNameL {}
  | MultinameInfo_RTQNameLA {}
  | MultinameInfo_Multiname {name_MultinameInfo_Multiname :: (Word32), set_MultinameInfo_Multiname :: (Word32)}
  | MultinameInfo_MultinameA {name_MultinameInfo_MultinameA :: (Word32), set_MultinameInfo_MultinameA :: (Word32)}
  | MultinameInfo_MultinameL {set_MultinameInfo_MultinameL :: (Word32)}
  | MultinameInfo_MultinameLA {set_MultinameInfo_MultinameLA :: (Word32)}
  | MultinameInfo_Generic {name_MultinameInfo_Generic :: (Word32), params_MultinameInfo_Generic :: (ParamNames)}

-- cata
{-# NOINLINE sem_MultinameInfo #-}
sem_MultinameInfo :: MultinameInfo  -> T_MultinameInfo 
sem_MultinameInfo ( MultinameInfo_QName namespace_ name_ ) = sem_MultinameInfo_QName namespace_ name_
sem_MultinameInfo ( MultinameInfo_QNameA namespace_ name_ ) = sem_MultinameInfo_QNameA namespace_ name_
sem_MultinameInfo ( MultinameInfo_RTQName name_ ) = sem_MultinameInfo_RTQName name_
sem_MultinameInfo ( MultinameInfo_RTQNameA name_ ) = sem_MultinameInfo_RTQNameA name_
sem_MultinameInfo ( MultinameInfo_RTQNameL  ) = sem_MultinameInfo_RTQNameL 
sem_MultinameInfo ( MultinameInfo_RTQNameLA  ) = sem_MultinameInfo_RTQNameLA 
sem_MultinameInfo ( MultinameInfo_Multiname name_ set_ ) = sem_MultinameInfo_Multiname name_ set_
sem_MultinameInfo ( MultinameInfo_MultinameA name_ set_ ) = sem_MultinameInfo_MultinameA name_ set_
sem_MultinameInfo ( MultinameInfo_MultinameL set_ ) = sem_MultinameInfo_MultinameL set_
sem_MultinameInfo ( MultinameInfo_MultinameLA set_ ) = sem_MultinameInfo_MultinameLA set_
sem_MultinameInfo ( MultinameInfo_Generic name_ params_ ) = sem_MultinameInfo_Generic name_ ( sem_ParamNames params_ )

-- semantic domain
newtype T_MultinameInfo  = T_MultinameInfo {
                                           attach_T_MultinameInfo :: Identity (T_MultinameInfo_s86 )
                                           }
newtype T_MultinameInfo_s86  = C_MultinameInfo_s86 {
                                                   inv_MultinameInfo_s86 :: (T_MultinameInfo_v85 )
                                                   }
data T_MultinameInfo_s87  = C_MultinameInfo_s87
type T_MultinameInfo_v85  = (T_MultinameInfo_vIn85 ) -> (T_MultinameInfo_vOut85 )
data T_MultinameInfo_vIn85  = T_MultinameInfo_vIn85 
data T_MultinameInfo_vOut85  = T_MultinameInfo_vOut85 (MultinameInfo)
{-# NOINLINE sem_MultinameInfo_QName #-}
sem_MultinameInfo_QName :: (Word32) -> (Word32) -> T_MultinameInfo 
sem_MultinameInfo_QName namespace_ name_ = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _output = rule861 name_ namespace_
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule862 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule861 #-}
   rule861 = \ name_ namespace_ ->
     MultinameInfo_QName namespace_ name_
   {-# INLINE rule862 #-}
   rule862 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfo_QNameA #-}
sem_MultinameInfo_QNameA :: (Word32) -> (Word32) -> T_MultinameInfo 
sem_MultinameInfo_QNameA namespace_ name_ = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _output = rule863 name_ namespace_
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule864 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule863 #-}
   rule863 = \ name_ namespace_ ->
     MultinameInfo_QNameA namespace_ name_
   {-# INLINE rule864 #-}
   rule864 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfo_RTQName #-}
sem_MultinameInfo_RTQName :: (Word32) -> T_MultinameInfo 
sem_MultinameInfo_RTQName name_ = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _output = rule865 name_
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule866 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule865 #-}
   rule865 = \ name_ ->
     MultinameInfo_RTQName name_
   {-# INLINE rule866 #-}
   rule866 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfo_RTQNameA #-}
sem_MultinameInfo_RTQNameA :: (Word32) -> T_MultinameInfo 
sem_MultinameInfo_RTQNameA name_ = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _output = rule867 name_
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule868 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule867 #-}
   rule867 = \ name_ ->
     MultinameInfo_RTQNameA name_
   {-# INLINE rule868 #-}
   rule868 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfo_RTQNameL #-}
sem_MultinameInfo_RTQNameL ::  T_MultinameInfo 
sem_MultinameInfo_RTQNameL  = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _output = rule869  ()
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule870 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule869 #-}
   rule869 = \  (_ :: ()) ->
     MultinameInfo_RTQNameL
   {-# INLINE rule870 #-}
   rule870 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfo_RTQNameLA #-}
sem_MultinameInfo_RTQNameLA ::  T_MultinameInfo 
sem_MultinameInfo_RTQNameLA  = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _output = rule871  ()
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule872 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule871 #-}
   rule871 = \  (_ :: ()) ->
     MultinameInfo_RTQNameLA
   {-# INLINE rule872 #-}
   rule872 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfo_Multiname #-}
sem_MultinameInfo_Multiname :: (Word32) -> (Word32) -> T_MultinameInfo 
sem_MultinameInfo_Multiname name_ set_ = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _output = rule873 name_ set_
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule874 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule873 #-}
   rule873 = \ name_ set_ ->
     MultinameInfo_Multiname name_ set_
   {-# INLINE rule874 #-}
   rule874 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfo_MultinameA #-}
sem_MultinameInfo_MultinameA :: (Word32) -> (Word32) -> T_MultinameInfo 
sem_MultinameInfo_MultinameA name_ set_ = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _output = rule875 name_ set_
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule876 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule875 #-}
   rule875 = \ name_ set_ ->
     MultinameInfo_MultinameA name_ set_
   {-# INLINE rule876 #-}
   rule876 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfo_MultinameL #-}
sem_MultinameInfo_MultinameL :: (Word32) -> T_MultinameInfo 
sem_MultinameInfo_MultinameL set_ = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _output = rule877 set_
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule878 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule877 #-}
   rule877 = \ set_ ->
     MultinameInfo_MultinameL set_
   {-# INLINE rule878 #-}
   rule878 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfo_MultinameLA #-}
sem_MultinameInfo_MultinameLA :: (Word32) -> T_MultinameInfo 
sem_MultinameInfo_MultinameLA set_ = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _output = rule879 set_
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule880 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule879 #-}
   rule879 = \ set_ ->
     MultinameInfo_MultinameLA set_
   {-# INLINE rule880 #-}
   rule880 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfo_Generic #-}
sem_MultinameInfo_Generic :: (Word32) -> T_ParamNames  -> T_MultinameInfo 
sem_MultinameInfo_Generic name_ params_ = T_MultinameInfo (return st86) where
   {-# NOINLINE st86 #-}
   st86 = let
      v85 :: T_MultinameInfo_v85 
      v85 = \ (T_MultinameInfo_vIn85 ) -> ( let
         _paramsX113 = Control.Monad.Identity.runIdentity (attach_T_ParamNames (params_))
         (T_ParamNames_vOut112 _paramsIoutput) = inv_ParamNames_s113 _paramsX113 (T_ParamNames_vIn112 )
         _output = rule881 _paramsIoutput name_
         _lhsOoutput :: MultinameInfo
         _lhsOoutput = rule882 _output
         __result_ = T_MultinameInfo_vOut85 _lhsOoutput
         in __result_ )
     in C_MultinameInfo_s86 v85
   {-# INLINE rule881 #-}
   rule881 = \ ((_paramsIoutput) :: ParamNames) name_ ->
     MultinameInfo_Generic name_ _paramsIoutput
   {-# INLINE rule882 #-}
   rule882 = \ _output ->
     _output

-- MultinameInfos ----------------------------------------------
-- data
type MultinameInfos  = [ MultinameInfo ]

-- cata
{-# NOINLINE sem_MultinameInfos #-}
sem_MultinameInfos :: MultinameInfos  -> T_MultinameInfos 
sem_MultinameInfos list = Prelude.foldr sem_MultinameInfos_Cons sem_MultinameInfos_Nil (Prelude.map sem_MultinameInfo list)

-- semantic domain
newtype T_MultinameInfos  = T_MultinameInfos {
                                             attach_T_MultinameInfos :: Identity (T_MultinameInfos_s89 )
                                             }
newtype T_MultinameInfos_s89  = C_MultinameInfos_s89 {
                                                     inv_MultinameInfos_s89 :: (T_MultinameInfos_v88 )
                                                     }
data T_MultinameInfos_s90  = C_MultinameInfos_s90
type T_MultinameInfos_v88  = (T_MultinameInfos_vIn88 ) -> (T_MultinameInfos_vOut88 )
data T_MultinameInfos_vIn88  = T_MultinameInfos_vIn88 
data T_MultinameInfos_vOut88  = T_MultinameInfos_vOut88 (MultinameInfos)
{-# NOINLINE sem_MultinameInfos_Cons #-}
sem_MultinameInfos_Cons :: T_MultinameInfo  -> T_MultinameInfos  -> T_MultinameInfos 
sem_MultinameInfos_Cons hd_ tl_ = T_MultinameInfos (return st89) where
   {-# NOINLINE st89 #-}
   st89 = let
      v88 :: T_MultinameInfos_v88 
      v88 = \ (T_MultinameInfos_vIn88 ) -> ( let
         _hdX86 = Control.Monad.Identity.runIdentity (attach_T_MultinameInfo (hd_))
         _tlX89 = Control.Monad.Identity.runIdentity (attach_T_MultinameInfos (tl_))
         (T_MultinameInfo_vOut85 _hdIoutput) = inv_MultinameInfo_s86 _hdX86 (T_MultinameInfo_vIn85 )
         (T_MultinameInfos_vOut88 _tlIoutput) = inv_MultinameInfos_s89 _tlX89 (T_MultinameInfos_vIn88 )
         _output = rule883 _hdIoutput _tlIoutput
         _lhsOoutput :: MultinameInfos
         _lhsOoutput = rule884 _output
         __result_ = T_MultinameInfos_vOut88 _lhsOoutput
         in __result_ )
     in C_MultinameInfos_s89 v88
   {-# INLINE rule883 #-}
   rule883 = \ ((_hdIoutput) :: MultinameInfo) ((_tlIoutput) :: MultinameInfos) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule884 #-}
   rule884 = \ _output ->
     _output
{-# NOINLINE sem_MultinameInfos_Nil #-}
sem_MultinameInfos_Nil ::  T_MultinameInfos 
sem_MultinameInfos_Nil  = T_MultinameInfos (return st89) where
   {-# NOINLINE st89 #-}
   st89 = let
      v88 :: T_MultinameInfos_v88 
      v88 = \ (T_MultinameInfos_vIn88 ) -> ( let
         _output = rule885  ()
         _lhsOoutput :: MultinameInfos
         _lhsOoutput = rule886 _output
         __result_ = T_MultinameInfos_vOut88 _lhsOoutput
         in __result_ )
     in C_MultinameInfos_s89 v88
   {-# INLINE rule885 #-}
   rule885 = \  (_ :: ()) ->
     []
   {-# INLINE rule886 #-}
   rule886 = \ _output ->
     _output

-- MultinameKind -----------------------------------------------
-- data
data MultinameKind 
  = MultinameKind_QName {}
  | MultinameKind_QNameA {}
  | MultinameKind_RTQName {}
  | MultinameKind_RTQNameA {}
  | MultinameKind_RTQNameL {}
  | MultinameKind_RTQNameLA {}
  | MultinameKind_Multiname {}
  | MultinameKind_MultinameA {}
  | MultinameKind_MultinameL {}
  | MultinameKind_MultinameLA {}
  | MultinameKind_Generic {}

-- cata
{-# NOINLINE sem_MultinameKind #-}
sem_MultinameKind :: MultinameKind  -> T_MultinameKind 
sem_MultinameKind ( MultinameKind_QName  ) = sem_MultinameKind_QName 
sem_MultinameKind ( MultinameKind_QNameA  ) = sem_MultinameKind_QNameA 
sem_MultinameKind ( MultinameKind_RTQName  ) = sem_MultinameKind_RTQName 
sem_MultinameKind ( MultinameKind_RTQNameA  ) = sem_MultinameKind_RTQNameA 
sem_MultinameKind ( MultinameKind_RTQNameL  ) = sem_MultinameKind_RTQNameL 
sem_MultinameKind ( MultinameKind_RTQNameLA  ) = sem_MultinameKind_RTQNameLA 
sem_MultinameKind ( MultinameKind_Multiname  ) = sem_MultinameKind_Multiname 
sem_MultinameKind ( MultinameKind_MultinameA  ) = sem_MultinameKind_MultinameA 
sem_MultinameKind ( MultinameKind_MultinameL  ) = sem_MultinameKind_MultinameL 
sem_MultinameKind ( MultinameKind_MultinameLA  ) = sem_MultinameKind_MultinameLA 
sem_MultinameKind ( MultinameKind_Generic  ) = sem_MultinameKind_Generic 

-- semantic domain
newtype T_MultinameKind  = T_MultinameKind {
                                           attach_T_MultinameKind :: Identity (T_MultinameKind_s92 )
                                           }
newtype T_MultinameKind_s92  = C_MultinameKind_s92 {
                                                   inv_MultinameKind_s92 :: (T_MultinameKind_v91 )
                                                   }
data T_MultinameKind_s93  = C_MultinameKind_s93
type T_MultinameKind_v91  = (T_MultinameKind_vIn91 ) -> (T_MultinameKind_vOut91 )
data T_MultinameKind_vIn91  = T_MultinameKind_vIn91 
data T_MultinameKind_vOut91  = T_MultinameKind_vOut91 (MultinameKind)
{-# NOINLINE sem_MultinameKind_QName #-}
sem_MultinameKind_QName ::  T_MultinameKind 
sem_MultinameKind_QName  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule887  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule888 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule887 #-}
   rule887 = \  (_ :: ()) ->
     MultinameKind_QName
   {-# INLINE rule888 #-}
   rule888 = \ _output ->
     _output
{-# NOINLINE sem_MultinameKind_QNameA #-}
sem_MultinameKind_QNameA ::  T_MultinameKind 
sem_MultinameKind_QNameA  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule889  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule890 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule889 #-}
   rule889 = \  (_ :: ()) ->
     MultinameKind_QNameA
   {-# INLINE rule890 #-}
   rule890 = \ _output ->
     _output
{-# NOINLINE sem_MultinameKind_RTQName #-}
sem_MultinameKind_RTQName ::  T_MultinameKind 
sem_MultinameKind_RTQName  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule891  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule892 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule891 #-}
   rule891 = \  (_ :: ()) ->
     MultinameKind_RTQName
   {-# INLINE rule892 #-}
   rule892 = \ _output ->
     _output
{-# NOINLINE sem_MultinameKind_RTQNameA #-}
sem_MultinameKind_RTQNameA ::  T_MultinameKind 
sem_MultinameKind_RTQNameA  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule893  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule894 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule893 #-}
   rule893 = \  (_ :: ()) ->
     MultinameKind_RTQNameA
   {-# INLINE rule894 #-}
   rule894 = \ _output ->
     _output
{-# NOINLINE sem_MultinameKind_RTQNameL #-}
sem_MultinameKind_RTQNameL ::  T_MultinameKind 
sem_MultinameKind_RTQNameL  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule895  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule896 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule895 #-}
   rule895 = \  (_ :: ()) ->
     MultinameKind_RTQNameL
   {-# INLINE rule896 #-}
   rule896 = \ _output ->
     _output
{-# NOINLINE sem_MultinameKind_RTQNameLA #-}
sem_MultinameKind_RTQNameLA ::  T_MultinameKind 
sem_MultinameKind_RTQNameLA  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule897  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule898 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule897 #-}
   rule897 = \  (_ :: ()) ->
     MultinameKind_RTQNameLA
   {-# INLINE rule898 #-}
   rule898 = \ _output ->
     _output
{-# NOINLINE sem_MultinameKind_Multiname #-}
sem_MultinameKind_Multiname ::  T_MultinameKind 
sem_MultinameKind_Multiname  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule899  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule900 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule899 #-}
   rule899 = \  (_ :: ()) ->
     MultinameKind_Multiname
   {-# INLINE rule900 #-}
   rule900 = \ _output ->
     _output
{-# NOINLINE sem_MultinameKind_MultinameA #-}
sem_MultinameKind_MultinameA ::  T_MultinameKind 
sem_MultinameKind_MultinameA  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule901  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule902 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule901 #-}
   rule901 = \  (_ :: ()) ->
     MultinameKind_MultinameA
   {-# INLINE rule902 #-}
   rule902 = \ _output ->
     _output
{-# NOINLINE sem_MultinameKind_MultinameL #-}
sem_MultinameKind_MultinameL ::  T_MultinameKind 
sem_MultinameKind_MultinameL  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule903  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule904 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule903 #-}
   rule903 = \  (_ :: ()) ->
     MultinameKind_MultinameL
   {-# INLINE rule904 #-}
   rule904 = \ _output ->
     _output
{-# NOINLINE sem_MultinameKind_MultinameLA #-}
sem_MultinameKind_MultinameLA ::  T_MultinameKind 
sem_MultinameKind_MultinameLA  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule905  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule906 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule905 #-}
   rule905 = \  (_ :: ()) ->
     MultinameKind_MultinameLA
   {-# INLINE rule906 #-}
   rule906 = \ _output ->
     _output
{-# NOINLINE sem_MultinameKind_Generic #-}
sem_MultinameKind_Generic ::  T_MultinameKind 
sem_MultinameKind_Generic  = T_MultinameKind (return st92) where
   {-# NOINLINE st92 #-}
   st92 = let
      v91 :: T_MultinameKind_v91 
      v91 = \ (T_MultinameKind_vIn91 ) -> ( let
         _output = rule907  ()
         _lhsOoutput :: MultinameKind
         _lhsOoutput = rule908 _output
         __result_ = T_MultinameKind_vOut91 _lhsOoutput
         in __result_ )
     in C_MultinameKind_s92 v91
   {-# INLINE rule907 #-}
   rule907 = \  (_ :: ()) ->
     MultinameKind_Generic
   {-# INLINE rule908 #-}
   rule908 = \ _output ->
     _output

-- NamespaceInfo -----------------------------------------------
-- data
data NamespaceInfo 
  = NamespaceInfo_Info {kind_NamespaceInfo_Info :: (NamespaceKind), name_NamespaceInfo_Info :: (Word32)}

-- cata
{-# INLINE sem_NamespaceInfo #-}
sem_NamespaceInfo :: NamespaceInfo  -> T_NamespaceInfo 
sem_NamespaceInfo ( NamespaceInfo_Info kind_ name_ ) = sem_NamespaceInfo_Info ( sem_NamespaceKind kind_ ) name_

-- semantic domain
newtype T_NamespaceInfo  = T_NamespaceInfo {
                                           attach_T_NamespaceInfo :: Identity (T_NamespaceInfo_s95 )
                                           }
newtype T_NamespaceInfo_s95  = C_NamespaceInfo_s95 {
                                                   inv_NamespaceInfo_s95 :: (T_NamespaceInfo_v94 )
                                                   }
data T_NamespaceInfo_s96  = C_NamespaceInfo_s96
type T_NamespaceInfo_v94  = (T_NamespaceInfo_vIn94 ) -> (T_NamespaceInfo_vOut94 )
data T_NamespaceInfo_vIn94  = T_NamespaceInfo_vIn94 
data T_NamespaceInfo_vOut94  = T_NamespaceInfo_vOut94 (NamespaceInfo)
{-# NOINLINE sem_NamespaceInfo_Info #-}
sem_NamespaceInfo_Info :: T_NamespaceKind  -> (Word32) -> T_NamespaceInfo 
sem_NamespaceInfo_Info kind_ name_ = T_NamespaceInfo (return st95) where
   {-# NOINLINE st95 #-}
   st95 = let
      v94 :: T_NamespaceInfo_v94 
      v94 = \ (T_NamespaceInfo_vIn94 ) -> ( let
         _kindX101 = Control.Monad.Identity.runIdentity (attach_T_NamespaceKind (kind_))
         (T_NamespaceKind_vOut100 _kindIoutput) = inv_NamespaceKind_s101 _kindX101 (T_NamespaceKind_vIn100 )
         _output = rule909 _kindIoutput name_
         _lhsOoutput :: NamespaceInfo
         _lhsOoutput = rule910 _output
         __result_ = T_NamespaceInfo_vOut94 _lhsOoutput
         in __result_ )
     in C_NamespaceInfo_s95 v94
   {-# INLINE rule909 #-}
   rule909 = \ ((_kindIoutput) :: NamespaceKind) name_ ->
     NamespaceInfo_Info _kindIoutput name_
   {-# INLINE rule910 #-}
   rule910 = \ _output ->
     _output

-- NamespaceInfos ----------------------------------------------
-- data
type NamespaceInfos  = [ NamespaceInfo ]

-- cata
{-# NOINLINE sem_NamespaceInfos #-}
sem_NamespaceInfos :: NamespaceInfos  -> T_NamespaceInfos 
sem_NamespaceInfos list = Prelude.foldr sem_NamespaceInfos_Cons sem_NamespaceInfos_Nil (Prelude.map sem_NamespaceInfo list)

-- semantic domain
newtype T_NamespaceInfos  = T_NamespaceInfos {
                                             attach_T_NamespaceInfos :: Identity (T_NamespaceInfos_s98 )
                                             }
newtype T_NamespaceInfos_s98  = C_NamespaceInfos_s98 {
                                                     inv_NamespaceInfos_s98 :: (T_NamespaceInfos_v97 )
                                                     }
data T_NamespaceInfos_s99  = C_NamespaceInfos_s99
type T_NamespaceInfos_v97  = (T_NamespaceInfos_vIn97 ) -> (T_NamespaceInfos_vOut97 )
data T_NamespaceInfos_vIn97  = T_NamespaceInfos_vIn97 
data T_NamespaceInfos_vOut97  = T_NamespaceInfos_vOut97 (NamespaceInfos)
{-# NOINLINE sem_NamespaceInfos_Cons #-}
sem_NamespaceInfos_Cons :: T_NamespaceInfo  -> T_NamespaceInfos  -> T_NamespaceInfos 
sem_NamespaceInfos_Cons hd_ tl_ = T_NamespaceInfos (return st98) where
   {-# NOINLINE st98 #-}
   st98 = let
      v97 :: T_NamespaceInfos_v97 
      v97 = \ (T_NamespaceInfos_vIn97 ) -> ( let
         _hdX95 = Control.Monad.Identity.runIdentity (attach_T_NamespaceInfo (hd_))
         _tlX98 = Control.Monad.Identity.runIdentity (attach_T_NamespaceInfos (tl_))
         (T_NamespaceInfo_vOut94 _hdIoutput) = inv_NamespaceInfo_s95 _hdX95 (T_NamespaceInfo_vIn94 )
         (T_NamespaceInfos_vOut97 _tlIoutput) = inv_NamespaceInfos_s98 _tlX98 (T_NamespaceInfos_vIn97 )
         _output = rule911 _hdIoutput _tlIoutput
         _lhsOoutput :: NamespaceInfos
         _lhsOoutput = rule912 _output
         __result_ = T_NamespaceInfos_vOut97 _lhsOoutput
         in __result_ )
     in C_NamespaceInfos_s98 v97
   {-# INLINE rule911 #-}
   rule911 = \ ((_hdIoutput) :: NamespaceInfo) ((_tlIoutput) :: NamespaceInfos) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule912 #-}
   rule912 = \ _output ->
     _output
{-# NOINLINE sem_NamespaceInfos_Nil #-}
sem_NamespaceInfos_Nil ::  T_NamespaceInfos 
sem_NamespaceInfos_Nil  = T_NamespaceInfos (return st98) where
   {-# NOINLINE st98 #-}
   st98 = let
      v97 :: T_NamespaceInfos_v97 
      v97 = \ (T_NamespaceInfos_vIn97 ) -> ( let
         _output = rule913  ()
         _lhsOoutput :: NamespaceInfos
         _lhsOoutput = rule914 _output
         __result_ = T_NamespaceInfos_vOut97 _lhsOoutput
         in __result_ )
     in C_NamespaceInfos_s98 v97
   {-# INLINE rule913 #-}
   rule913 = \  (_ :: ()) ->
     []
   {-# INLINE rule914 #-}
   rule914 = \ _output ->
     _output

-- NamespaceKind -----------------------------------------------
-- data
data NamespaceKind 
  = NamespaceKind_General {}
  | NamespaceKind_Package {}
  | NamespaceKind_Internal {}
  | NamespaceKind_Protected {}
  | NamespaceKind_Explicit {}
  | NamespaceKind_Static {}
  | NamespaceKind_Private {}

-- cata
{-# NOINLINE sem_NamespaceKind #-}
sem_NamespaceKind :: NamespaceKind  -> T_NamespaceKind 
sem_NamespaceKind ( NamespaceKind_General  ) = sem_NamespaceKind_General 
sem_NamespaceKind ( NamespaceKind_Package  ) = sem_NamespaceKind_Package 
sem_NamespaceKind ( NamespaceKind_Internal  ) = sem_NamespaceKind_Internal 
sem_NamespaceKind ( NamespaceKind_Protected  ) = sem_NamespaceKind_Protected 
sem_NamespaceKind ( NamespaceKind_Explicit  ) = sem_NamespaceKind_Explicit 
sem_NamespaceKind ( NamespaceKind_Static  ) = sem_NamespaceKind_Static 
sem_NamespaceKind ( NamespaceKind_Private  ) = sem_NamespaceKind_Private 

-- semantic domain
newtype T_NamespaceKind  = T_NamespaceKind {
                                           attach_T_NamespaceKind :: Identity (T_NamespaceKind_s101 )
                                           }
newtype T_NamespaceKind_s101  = C_NamespaceKind_s101 {
                                                     inv_NamespaceKind_s101 :: (T_NamespaceKind_v100 )
                                                     }
data T_NamespaceKind_s102  = C_NamespaceKind_s102
type T_NamespaceKind_v100  = (T_NamespaceKind_vIn100 ) -> (T_NamespaceKind_vOut100 )
data T_NamespaceKind_vIn100  = T_NamespaceKind_vIn100 
data T_NamespaceKind_vOut100  = T_NamespaceKind_vOut100 (NamespaceKind)
{-# NOINLINE sem_NamespaceKind_General #-}
sem_NamespaceKind_General ::  T_NamespaceKind 
sem_NamespaceKind_General  = T_NamespaceKind (return st101) where
   {-# NOINLINE st101 #-}
   st101 = let
      v100 :: T_NamespaceKind_v100 
      v100 = \ (T_NamespaceKind_vIn100 ) -> ( let
         _output = rule915  ()
         _lhsOoutput :: NamespaceKind
         _lhsOoutput = rule916 _output
         __result_ = T_NamespaceKind_vOut100 _lhsOoutput
         in __result_ )
     in C_NamespaceKind_s101 v100
   {-# INLINE rule915 #-}
   rule915 = \  (_ :: ()) ->
     NamespaceKind_General
   {-# INLINE rule916 #-}
   rule916 = \ _output ->
     _output
{-# NOINLINE sem_NamespaceKind_Package #-}
sem_NamespaceKind_Package ::  T_NamespaceKind 
sem_NamespaceKind_Package  = T_NamespaceKind (return st101) where
   {-# NOINLINE st101 #-}
   st101 = let
      v100 :: T_NamespaceKind_v100 
      v100 = \ (T_NamespaceKind_vIn100 ) -> ( let
         _output = rule917  ()
         _lhsOoutput :: NamespaceKind
         _lhsOoutput = rule918 _output
         __result_ = T_NamespaceKind_vOut100 _lhsOoutput
         in __result_ )
     in C_NamespaceKind_s101 v100
   {-# INLINE rule917 #-}
   rule917 = \  (_ :: ()) ->
     NamespaceKind_Package
   {-# INLINE rule918 #-}
   rule918 = \ _output ->
     _output
{-# NOINLINE sem_NamespaceKind_Internal #-}
sem_NamespaceKind_Internal ::  T_NamespaceKind 
sem_NamespaceKind_Internal  = T_NamespaceKind (return st101) where
   {-# NOINLINE st101 #-}
   st101 = let
      v100 :: T_NamespaceKind_v100 
      v100 = \ (T_NamespaceKind_vIn100 ) -> ( let
         _output = rule919  ()
         _lhsOoutput :: NamespaceKind
         _lhsOoutput = rule920 _output
         __result_ = T_NamespaceKind_vOut100 _lhsOoutput
         in __result_ )
     in C_NamespaceKind_s101 v100
   {-# INLINE rule919 #-}
   rule919 = \  (_ :: ()) ->
     NamespaceKind_Internal
   {-# INLINE rule920 #-}
   rule920 = \ _output ->
     _output
{-# NOINLINE sem_NamespaceKind_Protected #-}
sem_NamespaceKind_Protected ::  T_NamespaceKind 
sem_NamespaceKind_Protected  = T_NamespaceKind (return st101) where
   {-# NOINLINE st101 #-}
   st101 = let
      v100 :: T_NamespaceKind_v100 
      v100 = \ (T_NamespaceKind_vIn100 ) -> ( let
         _output = rule921  ()
         _lhsOoutput :: NamespaceKind
         _lhsOoutput = rule922 _output
         __result_ = T_NamespaceKind_vOut100 _lhsOoutput
         in __result_ )
     in C_NamespaceKind_s101 v100
   {-# INLINE rule921 #-}
   rule921 = \  (_ :: ()) ->
     NamespaceKind_Protected
   {-# INLINE rule922 #-}
   rule922 = \ _output ->
     _output
{-# NOINLINE sem_NamespaceKind_Explicit #-}
sem_NamespaceKind_Explicit ::  T_NamespaceKind 
sem_NamespaceKind_Explicit  = T_NamespaceKind (return st101) where
   {-# NOINLINE st101 #-}
   st101 = let
      v100 :: T_NamespaceKind_v100 
      v100 = \ (T_NamespaceKind_vIn100 ) -> ( let
         _output = rule923  ()
         _lhsOoutput :: NamespaceKind
         _lhsOoutput = rule924 _output
         __result_ = T_NamespaceKind_vOut100 _lhsOoutput
         in __result_ )
     in C_NamespaceKind_s101 v100
   {-# INLINE rule923 #-}
   rule923 = \  (_ :: ()) ->
     NamespaceKind_Explicit
   {-# INLINE rule924 #-}
   rule924 = \ _output ->
     _output
{-# NOINLINE sem_NamespaceKind_Static #-}
sem_NamespaceKind_Static ::  T_NamespaceKind 
sem_NamespaceKind_Static  = T_NamespaceKind (return st101) where
   {-# NOINLINE st101 #-}
   st101 = let
      v100 :: T_NamespaceKind_v100 
      v100 = \ (T_NamespaceKind_vIn100 ) -> ( let
         _output = rule925  ()
         _lhsOoutput :: NamespaceKind
         _lhsOoutput = rule926 _output
         __result_ = T_NamespaceKind_vOut100 _lhsOoutput
         in __result_ )
     in C_NamespaceKind_s101 v100
   {-# INLINE rule925 #-}
   rule925 = \  (_ :: ()) ->
     NamespaceKind_Static
   {-# INLINE rule926 #-}
   rule926 = \ _output ->
     _output
{-# NOINLINE sem_NamespaceKind_Private #-}
sem_NamespaceKind_Private ::  T_NamespaceKind 
sem_NamespaceKind_Private  = T_NamespaceKind (return st101) where
   {-# NOINLINE st101 #-}
   st101 = let
      v100 :: T_NamespaceKind_v100 
      v100 = \ (T_NamespaceKind_vIn100 ) -> ( let
         _output = rule927  ()
         _lhsOoutput :: NamespaceKind
         _lhsOoutput = rule928 _output
         __result_ = T_NamespaceKind_vOut100 _lhsOoutput
         in __result_ )
     in C_NamespaceKind_s101 v100
   {-# INLINE rule927 #-}
   rule927 = \  (_ :: ()) ->
     NamespaceKind_Private
   {-# INLINE rule928 #-}
   rule928 = \ _output ->
     _output

-- NamespaceNames ----------------------------------------------
-- data
type NamespaceNames  = [ Word32 ]

-- cata
{-# NOINLINE sem_NamespaceNames #-}
sem_NamespaceNames :: NamespaceNames  -> T_NamespaceNames 
sem_NamespaceNames list = Prelude.foldr sem_NamespaceNames_Cons sem_NamespaceNames_Nil list

-- semantic domain
newtype T_NamespaceNames  = T_NamespaceNames {
                                             attach_T_NamespaceNames :: Identity (T_NamespaceNames_s104 )
                                             }
newtype T_NamespaceNames_s104  = C_NamespaceNames_s104 {
                                                       inv_NamespaceNames_s104 :: (T_NamespaceNames_v103 )
                                                       }
data T_NamespaceNames_s105  = C_NamespaceNames_s105
type T_NamespaceNames_v103  = (T_NamespaceNames_vIn103 ) -> (T_NamespaceNames_vOut103 )
data T_NamespaceNames_vIn103  = T_NamespaceNames_vIn103 
data T_NamespaceNames_vOut103  = T_NamespaceNames_vOut103 (NamespaceNames)
{-# NOINLINE sem_NamespaceNames_Cons #-}
sem_NamespaceNames_Cons :: (Word32) -> T_NamespaceNames  -> T_NamespaceNames 
sem_NamespaceNames_Cons hd_ tl_ = T_NamespaceNames (return st104) where
   {-# NOINLINE st104 #-}
   st104 = let
      v103 :: T_NamespaceNames_v103 
      v103 = \ (T_NamespaceNames_vIn103 ) -> ( let
         _tlX104 = Control.Monad.Identity.runIdentity (attach_T_NamespaceNames (tl_))
         (T_NamespaceNames_vOut103 _tlIoutput) = inv_NamespaceNames_s104 _tlX104 (T_NamespaceNames_vIn103 )
         _output = rule929 _tlIoutput hd_
         _lhsOoutput :: NamespaceNames
         _lhsOoutput = rule930 _output
         __result_ = T_NamespaceNames_vOut103 _lhsOoutput
         in __result_ )
     in C_NamespaceNames_s104 v103
   {-# INLINE rule929 #-}
   rule929 = \ ((_tlIoutput) :: NamespaceNames) hd_ ->
     (:) hd_ _tlIoutput
   {-# INLINE rule930 #-}
   rule930 = \ _output ->
     _output
{-# NOINLINE sem_NamespaceNames_Nil #-}
sem_NamespaceNames_Nil ::  T_NamespaceNames 
sem_NamespaceNames_Nil  = T_NamespaceNames (return st104) where
   {-# NOINLINE st104 #-}
   st104 = let
      v103 :: T_NamespaceNames_v103 
      v103 = \ (T_NamespaceNames_vIn103 ) -> ( let
         _output = rule931  ()
         _lhsOoutput :: NamespaceNames
         _lhsOoutput = rule932 _output
         __result_ = T_NamespaceNames_vOut103 _lhsOoutput
         in __result_ )
     in C_NamespaceNames_s104 v103
   {-# INLINE rule931 #-}
   rule931 = \  (_ :: ()) ->
     []
   {-# INLINE rule932 #-}
   rule932 = \ _output ->
     _output

-- Optional ----------------------------------------------------
-- data
data Optional 
  = Optional_Detail {val_Optional_Detail :: (Word32), kind_Optional_Detail :: (ValueKind)}

-- cata
{-# INLINE sem_Optional #-}
sem_Optional :: Optional  -> T_Optional 
sem_Optional ( Optional_Detail val_ kind_ ) = sem_Optional_Detail val_ ( sem_ValueKind kind_ )

-- semantic domain
newtype T_Optional  = T_Optional {
                                 attach_T_Optional :: Identity (T_Optional_s107 )
                                 }
newtype T_Optional_s107  = C_Optional_s107 {
                                           inv_Optional_s107 :: (T_Optional_v106 )
                                           }
data T_Optional_s108  = C_Optional_s108
type T_Optional_v106  = (T_Optional_vIn106 ) -> (T_Optional_vOut106 )
data T_Optional_vIn106  = T_Optional_vIn106 
data T_Optional_vOut106  = T_Optional_vOut106 (Optional)
{-# NOINLINE sem_Optional_Detail #-}
sem_Optional_Detail :: (Word32) -> T_ValueKind  -> T_Optional 
sem_Optional_Detail val_ kind_ = T_Optional (return st107) where
   {-# NOINLINE st107 #-}
   st107 = let
      v106 :: T_Optional_v106 
      v106 = \ (T_Optional_vIn106 ) -> ( let
         _kindX182 = Control.Monad.Identity.runIdentity (attach_T_ValueKind (kind_))
         (T_ValueKind_vOut181 _kindIoutput) = inv_ValueKind_s182 _kindX182 (T_ValueKind_vIn181 )
         _output = rule933 _kindIoutput val_
         _lhsOoutput :: Optional
         _lhsOoutput = rule934 _output
         __result_ = T_Optional_vOut106 _lhsOoutput
         in __result_ )
     in C_Optional_s107 v106
   {-# INLINE rule933 #-}
   rule933 = \ ((_kindIoutput) :: ValueKind) val_ ->
     Optional_Detail val_ _kindIoutput
   {-# INLINE rule934 #-}
   rule934 = \ _output ->
     _output

-- Optionals ---------------------------------------------------
-- data
type Optionals  = [ Optional ]

-- cata
{-# NOINLINE sem_Optionals #-}
sem_Optionals :: Optionals  -> T_Optionals 
sem_Optionals list = Prelude.foldr sem_Optionals_Cons sem_Optionals_Nil (Prelude.map sem_Optional list)

-- semantic domain
newtype T_Optionals  = T_Optionals {
                                   attach_T_Optionals :: Identity (T_Optionals_s110 )
                                   }
newtype T_Optionals_s110  = C_Optionals_s110 {
                                             inv_Optionals_s110 :: (T_Optionals_v109 )
                                             }
data T_Optionals_s111  = C_Optionals_s111
type T_Optionals_v109  = (T_Optionals_vIn109 ) -> (T_Optionals_vOut109 )
data T_Optionals_vIn109  = T_Optionals_vIn109 
data T_Optionals_vOut109  = T_Optionals_vOut109 (Optionals)
{-# NOINLINE sem_Optionals_Cons #-}
sem_Optionals_Cons :: T_Optional  -> T_Optionals  -> T_Optionals 
sem_Optionals_Cons hd_ tl_ = T_Optionals (return st110) where
   {-# NOINLINE st110 #-}
   st110 = let
      v109 :: T_Optionals_v109 
      v109 = \ (T_Optionals_vIn109 ) -> ( let
         _hdX107 = Control.Monad.Identity.runIdentity (attach_T_Optional (hd_))
         _tlX110 = Control.Monad.Identity.runIdentity (attach_T_Optionals (tl_))
         (T_Optional_vOut106 _hdIoutput) = inv_Optional_s107 _hdX107 (T_Optional_vIn106 )
         (T_Optionals_vOut109 _tlIoutput) = inv_Optionals_s110 _tlX110 (T_Optionals_vIn109 )
         _output = rule935 _hdIoutput _tlIoutput
         _lhsOoutput :: Optionals
         _lhsOoutput = rule936 _output
         __result_ = T_Optionals_vOut109 _lhsOoutput
         in __result_ )
     in C_Optionals_s110 v109
   {-# INLINE rule935 #-}
   rule935 = \ ((_hdIoutput) :: Optional) ((_tlIoutput) :: Optionals) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule936 #-}
   rule936 = \ _output ->
     _output
{-# NOINLINE sem_Optionals_Nil #-}
sem_Optionals_Nil ::  T_Optionals 
sem_Optionals_Nil  = T_Optionals (return st110) where
   {-# NOINLINE st110 #-}
   st110 = let
      v109 :: T_Optionals_v109 
      v109 = \ (T_Optionals_vIn109 ) -> ( let
         _output = rule937  ()
         _lhsOoutput :: Optionals
         _lhsOoutput = rule938 _output
         __result_ = T_Optionals_vOut109 _lhsOoutput
         in __result_ )
     in C_Optionals_s110 v109
   {-# INLINE rule937 #-}
   rule937 = \  (_ :: ()) ->
     []
   {-# INLINE rule938 #-}
   rule938 = \ _output ->
     _output

-- ParamNames --------------------------------------------------
-- data
type ParamNames  = [ Word32 ]

-- cata
{-# NOINLINE sem_ParamNames #-}
sem_ParamNames :: ParamNames  -> T_ParamNames 
sem_ParamNames list = Prelude.foldr sem_ParamNames_Cons sem_ParamNames_Nil list

-- semantic domain
newtype T_ParamNames  = T_ParamNames {
                                     attach_T_ParamNames :: Identity (T_ParamNames_s113 )
                                     }
newtype T_ParamNames_s113  = C_ParamNames_s113 {
                                               inv_ParamNames_s113 :: (T_ParamNames_v112 )
                                               }
data T_ParamNames_s114  = C_ParamNames_s114
type T_ParamNames_v112  = (T_ParamNames_vIn112 ) -> (T_ParamNames_vOut112 )
data T_ParamNames_vIn112  = T_ParamNames_vIn112 
data T_ParamNames_vOut112  = T_ParamNames_vOut112 (ParamNames)
{-# NOINLINE sem_ParamNames_Cons #-}
sem_ParamNames_Cons :: (Word32) -> T_ParamNames  -> T_ParamNames 
sem_ParamNames_Cons hd_ tl_ = T_ParamNames (return st113) where
   {-# NOINLINE st113 #-}
   st113 = let
      v112 :: T_ParamNames_v112 
      v112 = \ (T_ParamNames_vIn112 ) -> ( let
         _tlX113 = Control.Monad.Identity.runIdentity (attach_T_ParamNames (tl_))
         (T_ParamNames_vOut112 _tlIoutput) = inv_ParamNames_s113 _tlX113 (T_ParamNames_vIn112 )
         _output = rule939 _tlIoutput hd_
         _lhsOoutput :: ParamNames
         _lhsOoutput = rule940 _output
         __result_ = T_ParamNames_vOut112 _lhsOoutput
         in __result_ )
     in C_ParamNames_s113 v112
   {-# INLINE rule939 #-}
   rule939 = \ ((_tlIoutput) :: ParamNames) hd_ ->
     (:) hd_ _tlIoutput
   {-# INLINE rule940 #-}
   rule940 = \ _output ->
     _output
{-# NOINLINE sem_ParamNames_Nil #-}
sem_ParamNames_Nil ::  T_ParamNames 
sem_ParamNames_Nil  = T_ParamNames (return st113) where
   {-# NOINLINE st113 #-}
   st113 = let
      v112 :: T_ParamNames_v112 
      v112 = \ (T_ParamNames_vIn112 ) -> ( let
         _output = rule941  ()
         _lhsOoutput :: ParamNames
         _lhsOoutput = rule942 _output
         __result_ = T_ParamNames_vOut112 _lhsOoutput
         in __result_ )
     in C_ParamNames_s113 v112
   {-# INLINE rule941 #-}
   rule941 = \  (_ :: ()) ->
     []
   {-# INLINE rule942 #-}
   rule942 = \ _output ->
     _output

-- ParamTypes --------------------------------------------------
-- data
type ParamTypes  = [ Word32 ]

-- cata
{-# NOINLINE sem_ParamTypes #-}
sem_ParamTypes :: ParamTypes  -> T_ParamTypes 
sem_ParamTypes list = Prelude.foldr sem_ParamTypes_Cons sem_ParamTypes_Nil list

-- semantic domain
newtype T_ParamTypes  = T_ParamTypes {
                                     attach_T_ParamTypes :: Identity (T_ParamTypes_s116 )
                                     }
newtype T_ParamTypes_s116  = C_ParamTypes_s116 {
                                               inv_ParamTypes_s116 :: (T_ParamTypes_v115 )
                                               }
data T_ParamTypes_s117  = C_ParamTypes_s117
type T_ParamTypes_v115  = (T_ParamTypes_vIn115 ) -> (T_ParamTypes_vOut115 )
data T_ParamTypes_vIn115  = T_ParamTypes_vIn115 
data T_ParamTypes_vOut115  = T_ParamTypes_vOut115 (ParamTypes)
{-# NOINLINE sem_ParamTypes_Cons #-}
sem_ParamTypes_Cons :: (Word32) -> T_ParamTypes  -> T_ParamTypes 
sem_ParamTypes_Cons hd_ tl_ = T_ParamTypes (return st116) where
   {-# NOINLINE st116 #-}
   st116 = let
      v115 :: T_ParamTypes_v115 
      v115 = \ (T_ParamTypes_vIn115 ) -> ( let
         _tlX116 = Control.Monad.Identity.runIdentity (attach_T_ParamTypes (tl_))
         (T_ParamTypes_vOut115 _tlIoutput) = inv_ParamTypes_s116 _tlX116 (T_ParamTypes_vIn115 )
         _output = rule943 _tlIoutput hd_
         _lhsOoutput :: ParamTypes
         _lhsOoutput = rule944 _output
         __result_ = T_ParamTypes_vOut115 _lhsOoutput
         in __result_ )
     in C_ParamTypes_s116 v115
   {-# INLINE rule943 #-}
   rule943 = \ ((_tlIoutput) :: ParamTypes) hd_ ->
     (:) hd_ _tlIoutput
   {-# INLINE rule944 #-}
   rule944 = \ _output ->
     _output
{-# NOINLINE sem_ParamTypes_Nil #-}
sem_ParamTypes_Nil ::  T_ParamTypes 
sem_ParamTypes_Nil  = T_ParamTypes (return st116) where
   {-# NOINLINE st116 #-}
   st116 = let
      v115 :: T_ParamTypes_v115 
      v115 = \ (T_ParamTypes_vIn115 ) -> ( let
         _output = rule945  ()
         _lhsOoutput :: ParamTypes
         _lhsOoutput = rule946 _output
         __result_ = T_ParamTypes_vOut115 _lhsOoutput
         in __result_ )
     in C_ParamTypes_s116 v115
   {-# INLINE rule945 #-}
   rule945 = \  (_ :: ()) ->
     []
   {-# INLINE rule946 #-}
   rule946 = \ _output ->
     _output

-- PoolDoubles -------------------------------------------------
-- data
type PoolDoubles  = [ Double ]

-- cata
{-# NOINLINE sem_PoolDoubles #-}
sem_PoolDoubles :: PoolDoubles  -> T_PoolDoubles 
sem_PoolDoubles list = Prelude.foldr sem_PoolDoubles_Cons sem_PoolDoubles_Nil list

-- semantic domain
newtype T_PoolDoubles  = T_PoolDoubles {
                                       attach_T_PoolDoubles :: Identity (T_PoolDoubles_s119 )
                                       }
newtype T_PoolDoubles_s119  = C_PoolDoubles_s119 {
                                                 inv_PoolDoubles_s119 :: (T_PoolDoubles_v118 )
                                                 }
data T_PoolDoubles_s120  = C_PoolDoubles_s120
type T_PoolDoubles_v118  = (T_PoolDoubles_vIn118 ) -> (T_PoolDoubles_vOut118 )
data T_PoolDoubles_vIn118  = T_PoolDoubles_vIn118 
data T_PoolDoubles_vOut118  = T_PoolDoubles_vOut118 (PoolDoubles)
{-# NOINLINE sem_PoolDoubles_Cons #-}
sem_PoolDoubles_Cons :: (Double) -> T_PoolDoubles  -> T_PoolDoubles 
sem_PoolDoubles_Cons hd_ tl_ = T_PoolDoubles (return st119) where
   {-# NOINLINE st119 #-}
   st119 = let
      v118 :: T_PoolDoubles_v118 
      v118 = \ (T_PoolDoubles_vIn118 ) -> ( let
         _tlX119 = Control.Monad.Identity.runIdentity (attach_T_PoolDoubles (tl_))
         (T_PoolDoubles_vOut118 _tlIoutput) = inv_PoolDoubles_s119 _tlX119 (T_PoolDoubles_vIn118 )
         _output = rule947 _tlIoutput hd_
         _lhsOoutput :: PoolDoubles
         _lhsOoutput = rule948 _output
         __result_ = T_PoolDoubles_vOut118 _lhsOoutput
         in __result_ )
     in C_PoolDoubles_s119 v118
   {-# INLINE rule947 #-}
   rule947 = \ ((_tlIoutput) :: PoolDoubles) hd_ ->
     (:) hd_ _tlIoutput
   {-# INLINE rule948 #-}
   rule948 = \ _output ->
     _output
{-# NOINLINE sem_PoolDoubles_Nil #-}
sem_PoolDoubles_Nil ::  T_PoolDoubles 
sem_PoolDoubles_Nil  = T_PoolDoubles (return st119) where
   {-# NOINLINE st119 #-}
   st119 = let
      v118 :: T_PoolDoubles_v118 
      v118 = \ (T_PoolDoubles_vIn118 ) -> ( let
         _output = rule949  ()
         _lhsOoutput :: PoolDoubles
         _lhsOoutput = rule950 _output
         __result_ = T_PoolDoubles_vOut118 _lhsOoutput
         in __result_ )
     in C_PoolDoubles_s119 v118
   {-# INLINE rule949 #-}
   rule949 = \  (_ :: ()) ->
     []
   {-# INLINE rule950 #-}
   rule950 = \ _output ->
     _output

-- PoolInfo ----------------------------------------------------
-- data
data PoolInfo 
  = PoolInfo_Info {integers_PoolInfo_Info :: (PoolInts), uintegers_PoolInfo_Info :: (PoolUInts), doubles_PoolInfo_Info :: (PoolDoubles), strings_PoolInfo_Info :: (PoolStrings), namespaces_PoolInfo_Info :: (NamespaceInfos), namesets_PoolInfo_Info :: (SetInfos), multinames_PoolInfo_Info :: (MultinameInfos)}

-- cata
{-# INLINE sem_PoolInfo #-}
sem_PoolInfo :: PoolInfo  -> T_PoolInfo 
sem_PoolInfo ( PoolInfo_Info integers_ uintegers_ doubles_ strings_ namespaces_ namesets_ multinames_ ) = sem_PoolInfo_Info ( sem_PoolInts integers_ ) ( sem_PoolUInts uintegers_ ) ( sem_PoolDoubles doubles_ ) ( sem_PoolStrings strings_ ) ( sem_NamespaceInfos namespaces_ ) ( sem_SetInfos namesets_ ) ( sem_MultinameInfos multinames_ )

-- semantic domain
newtype T_PoolInfo  = T_PoolInfo {
                                 attach_T_PoolInfo :: Identity (T_PoolInfo_s122 )
                                 }
newtype T_PoolInfo_s122  = C_PoolInfo_s122 {
                                           inv_PoolInfo_s122 :: (T_PoolInfo_v121 )
                                           }
data T_PoolInfo_s123  = C_PoolInfo_s123
type T_PoolInfo_v121  = (T_PoolInfo_vIn121 ) -> (T_PoolInfo_vOut121 )
data T_PoolInfo_vIn121  = T_PoolInfo_vIn121 
data T_PoolInfo_vOut121  = T_PoolInfo_vOut121 (PoolInfo)
{-# NOINLINE sem_PoolInfo_Info #-}
sem_PoolInfo_Info :: T_PoolInts  -> T_PoolUInts  -> T_PoolDoubles  -> T_PoolStrings  -> T_NamespaceInfos  -> T_SetInfos  -> T_MultinameInfos  -> T_PoolInfo 
sem_PoolInfo_Info integers_ uintegers_ doubles_ strings_ namespaces_ namesets_ multinames_ = T_PoolInfo (return st122) where
   {-# NOINLINE st122 #-}
   st122 = let
      v121 :: T_PoolInfo_v121 
      v121 = \ (T_PoolInfo_vIn121 ) -> ( let
         _integersX125 = Control.Monad.Identity.runIdentity (attach_T_PoolInts (integers_))
         _uintegersX131 = Control.Monad.Identity.runIdentity (attach_T_PoolUInts (uintegers_))
         _doublesX119 = Control.Monad.Identity.runIdentity (attach_T_PoolDoubles (doubles_))
         _stringsX128 = Control.Monad.Identity.runIdentity (attach_T_PoolStrings (strings_))
         _namespacesX98 = Control.Monad.Identity.runIdentity (attach_T_NamespaceInfos (namespaces_))
         _namesetsX146 = Control.Monad.Identity.runIdentity (attach_T_SetInfos (namesets_))
         _multinamesX89 = Control.Monad.Identity.runIdentity (attach_T_MultinameInfos (multinames_))
         (T_PoolInts_vOut124 _integersIoutput) = inv_PoolInts_s125 _integersX125 (T_PoolInts_vIn124 )
         (T_PoolUInts_vOut130 _uintegersIoutput) = inv_PoolUInts_s131 _uintegersX131 (T_PoolUInts_vIn130 )
         (T_PoolDoubles_vOut118 _doublesIoutput) = inv_PoolDoubles_s119 _doublesX119 (T_PoolDoubles_vIn118 )
         (T_PoolStrings_vOut127 _stringsIoutput) = inv_PoolStrings_s128 _stringsX128 (T_PoolStrings_vIn127 )
         (T_NamespaceInfos_vOut97 _namespacesIoutput) = inv_NamespaceInfos_s98 _namespacesX98 (T_NamespaceInfos_vIn97 )
         (T_SetInfos_vOut145 _namesetsIoutput) = inv_SetInfos_s146 _namesetsX146 (T_SetInfos_vIn145 )
         (T_MultinameInfos_vOut88 _multinamesIoutput) = inv_MultinameInfos_s89 _multinamesX89 (T_MultinameInfos_vIn88 )
         _output = rule951 _doublesIoutput _integersIoutput _multinamesIoutput _namesetsIoutput _namespacesIoutput _stringsIoutput _uintegersIoutput
         _lhsOoutput :: PoolInfo
         _lhsOoutput = rule952 _output
         __result_ = T_PoolInfo_vOut121 _lhsOoutput
         in __result_ )
     in C_PoolInfo_s122 v121
   {-# INLINE rule951 #-}
   rule951 = \ ((_doublesIoutput) :: PoolDoubles) ((_integersIoutput) :: PoolInts) ((_multinamesIoutput) :: MultinameInfos) ((_namesetsIoutput) :: SetInfos) ((_namespacesIoutput) :: NamespaceInfos) ((_stringsIoutput) :: PoolStrings) ((_uintegersIoutput) :: PoolUInts) ->
     PoolInfo_Info _integersIoutput _uintegersIoutput _doublesIoutput _stringsIoutput _namespacesIoutput _namesetsIoutput _multinamesIoutput
   {-# INLINE rule952 #-}
   rule952 = \ _output ->
     _output

-- PoolInts ----------------------------------------------------
-- data
type PoolInts  = [ Word32 ]

-- cata
{-# NOINLINE sem_PoolInts #-}
sem_PoolInts :: PoolInts  -> T_PoolInts 
sem_PoolInts list = Prelude.foldr sem_PoolInts_Cons sem_PoolInts_Nil list

-- semantic domain
newtype T_PoolInts  = T_PoolInts {
                                 attach_T_PoolInts :: Identity (T_PoolInts_s125 )
                                 }
newtype T_PoolInts_s125  = C_PoolInts_s125 {
                                           inv_PoolInts_s125 :: (T_PoolInts_v124 )
                                           }
data T_PoolInts_s126  = C_PoolInts_s126
type T_PoolInts_v124  = (T_PoolInts_vIn124 ) -> (T_PoolInts_vOut124 )
data T_PoolInts_vIn124  = T_PoolInts_vIn124 
data T_PoolInts_vOut124  = T_PoolInts_vOut124 (PoolInts)
{-# NOINLINE sem_PoolInts_Cons #-}
sem_PoolInts_Cons :: (Word32) -> T_PoolInts  -> T_PoolInts 
sem_PoolInts_Cons hd_ tl_ = T_PoolInts (return st125) where
   {-# NOINLINE st125 #-}
   st125 = let
      v124 :: T_PoolInts_v124 
      v124 = \ (T_PoolInts_vIn124 ) -> ( let
         _tlX125 = Control.Monad.Identity.runIdentity (attach_T_PoolInts (tl_))
         (T_PoolInts_vOut124 _tlIoutput) = inv_PoolInts_s125 _tlX125 (T_PoolInts_vIn124 )
         _output = rule953 _tlIoutput hd_
         _lhsOoutput :: PoolInts
         _lhsOoutput = rule954 _output
         __result_ = T_PoolInts_vOut124 _lhsOoutput
         in __result_ )
     in C_PoolInts_s125 v124
   {-# INLINE rule953 #-}
   rule953 = \ ((_tlIoutput) :: PoolInts) hd_ ->
     (:) hd_ _tlIoutput
   {-# INLINE rule954 #-}
   rule954 = \ _output ->
     _output
{-# NOINLINE sem_PoolInts_Nil #-}
sem_PoolInts_Nil ::  T_PoolInts 
sem_PoolInts_Nil  = T_PoolInts (return st125) where
   {-# NOINLINE st125 #-}
   st125 = let
      v124 :: T_PoolInts_v124 
      v124 = \ (T_PoolInts_vIn124 ) -> ( let
         _output = rule955  ()
         _lhsOoutput :: PoolInts
         _lhsOoutput = rule956 _output
         __result_ = T_PoolInts_vOut124 _lhsOoutput
         in __result_ )
     in C_PoolInts_s125 v124
   {-# INLINE rule955 #-}
   rule955 = \  (_ :: ()) ->
     []
   {-# INLINE rule956 #-}
   rule956 = \ _output ->
     _output

-- PoolStrings -------------------------------------------------
-- data
type PoolStrings  = [ ByteString ]

-- cata
{-# NOINLINE sem_PoolStrings #-}
sem_PoolStrings :: PoolStrings  -> T_PoolStrings 
sem_PoolStrings list = Prelude.foldr sem_PoolStrings_Cons sem_PoolStrings_Nil list

-- semantic domain
newtype T_PoolStrings  = T_PoolStrings {
                                       attach_T_PoolStrings :: Identity (T_PoolStrings_s128 )
                                       }
newtype T_PoolStrings_s128  = C_PoolStrings_s128 {
                                                 inv_PoolStrings_s128 :: (T_PoolStrings_v127 )
                                                 }
data T_PoolStrings_s129  = C_PoolStrings_s129
type T_PoolStrings_v127  = (T_PoolStrings_vIn127 ) -> (T_PoolStrings_vOut127 )
data T_PoolStrings_vIn127  = T_PoolStrings_vIn127 
data T_PoolStrings_vOut127  = T_PoolStrings_vOut127 (PoolStrings)
{-# NOINLINE sem_PoolStrings_Cons #-}
sem_PoolStrings_Cons :: (ByteString) -> T_PoolStrings  -> T_PoolStrings 
sem_PoolStrings_Cons hd_ tl_ = T_PoolStrings (return st128) where
   {-# NOINLINE st128 #-}
   st128 = let
      v127 :: T_PoolStrings_v127 
      v127 = \ (T_PoolStrings_vIn127 ) -> ( let
         _tlX128 = Control.Monad.Identity.runIdentity (attach_T_PoolStrings (tl_))
         (T_PoolStrings_vOut127 _tlIoutput) = inv_PoolStrings_s128 _tlX128 (T_PoolStrings_vIn127 )
         _output = rule957 _tlIoutput hd_
         _lhsOoutput :: PoolStrings
         _lhsOoutput = rule958 _output
         __result_ = T_PoolStrings_vOut127 _lhsOoutput
         in __result_ )
     in C_PoolStrings_s128 v127
   {-# INLINE rule957 #-}
   rule957 = \ ((_tlIoutput) :: PoolStrings) hd_ ->
     (:) hd_ _tlIoutput
   {-# INLINE rule958 #-}
   rule958 = \ _output ->
     _output
{-# NOINLINE sem_PoolStrings_Nil #-}
sem_PoolStrings_Nil ::  T_PoolStrings 
sem_PoolStrings_Nil  = T_PoolStrings (return st128) where
   {-# NOINLINE st128 #-}
   st128 = let
      v127 :: T_PoolStrings_v127 
      v127 = \ (T_PoolStrings_vIn127 ) -> ( let
         _output = rule959  ()
         _lhsOoutput :: PoolStrings
         _lhsOoutput = rule960 _output
         __result_ = T_PoolStrings_vOut127 _lhsOoutput
         in __result_ )
     in C_PoolStrings_s128 v127
   {-# INLINE rule959 #-}
   rule959 = \  (_ :: ()) ->
     []
   {-# INLINE rule960 #-}
   rule960 = \ _output ->
     _output

-- PoolUInts ---------------------------------------------------
-- data
type PoolUInts  = [ Word32 ]

-- cata
{-# NOINLINE sem_PoolUInts #-}
sem_PoolUInts :: PoolUInts  -> T_PoolUInts 
sem_PoolUInts list = Prelude.foldr sem_PoolUInts_Cons sem_PoolUInts_Nil list

-- semantic domain
newtype T_PoolUInts  = T_PoolUInts {
                                   attach_T_PoolUInts :: Identity (T_PoolUInts_s131 )
                                   }
newtype T_PoolUInts_s131  = C_PoolUInts_s131 {
                                             inv_PoolUInts_s131 :: (T_PoolUInts_v130 )
                                             }
data T_PoolUInts_s132  = C_PoolUInts_s132
type T_PoolUInts_v130  = (T_PoolUInts_vIn130 ) -> (T_PoolUInts_vOut130 )
data T_PoolUInts_vIn130  = T_PoolUInts_vIn130 
data T_PoolUInts_vOut130  = T_PoolUInts_vOut130 (PoolUInts)
{-# NOINLINE sem_PoolUInts_Cons #-}
sem_PoolUInts_Cons :: (Word32) -> T_PoolUInts  -> T_PoolUInts 
sem_PoolUInts_Cons hd_ tl_ = T_PoolUInts (return st131) where
   {-# NOINLINE st131 #-}
   st131 = let
      v130 :: T_PoolUInts_v130 
      v130 = \ (T_PoolUInts_vIn130 ) -> ( let
         _tlX131 = Control.Monad.Identity.runIdentity (attach_T_PoolUInts (tl_))
         (T_PoolUInts_vOut130 _tlIoutput) = inv_PoolUInts_s131 _tlX131 (T_PoolUInts_vIn130 )
         _output = rule961 _tlIoutput hd_
         _lhsOoutput :: PoolUInts
         _lhsOoutput = rule962 _output
         __result_ = T_PoolUInts_vOut130 _lhsOoutput
         in __result_ )
     in C_PoolUInts_s131 v130
   {-# INLINE rule961 #-}
   rule961 = \ ((_tlIoutput) :: PoolUInts) hd_ ->
     (:) hd_ _tlIoutput
   {-# INLINE rule962 #-}
   rule962 = \ _output ->
     _output
{-# NOINLINE sem_PoolUInts_Nil #-}
sem_PoolUInts_Nil ::  T_PoolUInts 
sem_PoolUInts_Nil  = T_PoolUInts (return st131) where
   {-# NOINLINE st131 #-}
   st131 = let
      v130 :: T_PoolUInts_v130 
      v130 = \ (T_PoolUInts_vIn130 ) -> ( let
         _output = rule963  ()
         _lhsOoutput :: PoolUInts
         _lhsOoutput = rule964 _output
         __result_ = T_PoolUInts_vOut130 _lhsOoutput
         in __result_ )
     in C_PoolUInts_s131 v130
   {-# INLINE rule963 #-}
   rule963 = \  (_ :: ()) ->
     []
   {-# INLINE rule964 #-}
   rule964 = \ _output ->
     _output

-- Rect --------------------------------------------------------
-- data
data Rect 
  = Rect_Rect {bits_Rect_Rect :: (Int), xMin_Rect_Rect :: (Word32), xMax_Rect_Rect :: (Word32), yMin_Rect_Rect :: (Word32), yMax_Rect_Rect :: (Word32)}

-- cata
{-# INLINE sem_Rect #-}
sem_Rect :: Rect  -> T_Rect 
sem_Rect ( Rect_Rect bits_ xMin_ xMax_ yMin_ yMax_ ) = sem_Rect_Rect bits_ xMin_ xMax_ yMin_ yMax_

-- semantic domain
newtype T_Rect  = T_Rect {
                         attach_T_Rect :: Identity (T_Rect_s134 )
                         }
newtype T_Rect_s134  = C_Rect_s134 {
                                   inv_Rect_s134 :: (T_Rect_v133 )
                                   }
data T_Rect_s135  = C_Rect_s135
type T_Rect_v133  = (T_Rect_vIn133 ) -> (T_Rect_vOut133 )
data T_Rect_vIn133  = T_Rect_vIn133 
data T_Rect_vOut133  = T_Rect_vOut133 (Rect)
{-# NOINLINE sem_Rect_Rect #-}
sem_Rect_Rect :: (Int) -> (Word32) -> (Word32) -> (Word32) -> (Word32) -> T_Rect 
sem_Rect_Rect bits_ xMin_ xMax_ yMin_ yMax_ = T_Rect (return st134) where
   {-# NOINLINE st134 #-}
   st134 = let
      v133 :: T_Rect_v133 
      v133 = \ (T_Rect_vIn133 ) -> ( let
         _output = rule965 bits_ xMax_ xMin_ yMax_ yMin_
         _lhsOoutput :: Rect
         _lhsOoutput = rule966 _output
         __result_ = T_Rect_vOut133 _lhsOoutput
         in __result_ )
     in C_Rect_s134 v133
   {-# INLINE rule965 #-}
   rule965 = \ bits_ xMax_ xMin_ yMax_ yMin_ ->
     Rect_Rect bits_ xMin_ xMax_ yMin_ yMax_
   {-# INLINE rule966 #-}
   rule966 = \ _output ->
     _output

-- ScriptInfo --------------------------------------------------
-- data
data ScriptInfo 
  = ScriptInfo_Info {method_ScriptInfo_Info :: (Word32), traits_ScriptInfo_Info :: (Traits)}

-- cata
{-# INLINE sem_ScriptInfo #-}
sem_ScriptInfo :: ScriptInfo  -> T_ScriptInfo 
sem_ScriptInfo ( ScriptInfo_Info method_ traits_ ) = sem_ScriptInfo_Info method_ ( sem_Traits traits_ )

-- semantic domain
newtype T_ScriptInfo  = T_ScriptInfo {
                                     attach_T_ScriptInfo :: Identity (T_ScriptInfo_s137 )
                                     }
newtype T_ScriptInfo_s137  = C_ScriptInfo_s137 {
                                               inv_ScriptInfo_s137 :: (T_ScriptInfo_v136 )
                                               }
data T_ScriptInfo_s138  = C_ScriptInfo_s138
type T_ScriptInfo_v136  = (T_ScriptInfo_vIn136 ) -> (T_ScriptInfo_vOut136 )
data T_ScriptInfo_vIn136  = T_ScriptInfo_vIn136 
data T_ScriptInfo_vOut136  = T_ScriptInfo_vOut136 (ScriptInfo)
{-# NOINLINE sem_ScriptInfo_Info #-}
sem_ScriptInfo_Info :: (Word32) -> T_Traits  -> T_ScriptInfo 
sem_ScriptInfo_Info method_ traits_ = T_ScriptInfo (return st137) where
   {-# NOINLINE st137 #-}
   st137 = let
      v136 :: T_ScriptInfo_v136 
      v136 = \ (T_ScriptInfo_vIn136 ) -> ( let
         _traitsX179 = Control.Monad.Identity.runIdentity (attach_T_Traits (traits_))
         (T_Traits_vOut178 _traitsIoutput) = inv_Traits_s179 _traitsX179 (T_Traits_vIn178 )
         _output = rule967 _traitsIoutput method_
         _lhsOoutput :: ScriptInfo
         _lhsOoutput = rule968 _output
         __result_ = T_ScriptInfo_vOut136 _lhsOoutput
         in __result_ )
     in C_ScriptInfo_s137 v136
   {-# INLINE rule967 #-}
   rule967 = \ ((_traitsIoutput) :: Traits) method_ ->
     ScriptInfo_Info method_ _traitsIoutput
   {-# INLINE rule968 #-}
   rule968 = \ _output ->
     _output

-- ScriptInfos -------------------------------------------------
-- data
type ScriptInfos  = [ ScriptInfo ]

-- cata
{-# NOINLINE sem_ScriptInfos #-}
sem_ScriptInfos :: ScriptInfos  -> T_ScriptInfos 
sem_ScriptInfos list = Prelude.foldr sem_ScriptInfos_Cons sem_ScriptInfos_Nil (Prelude.map sem_ScriptInfo list)

-- semantic domain
newtype T_ScriptInfos  = T_ScriptInfos {
                                       attach_T_ScriptInfos :: Identity (T_ScriptInfos_s140 )
                                       }
newtype T_ScriptInfos_s140  = C_ScriptInfos_s140 {
                                                 inv_ScriptInfos_s140 :: (T_ScriptInfos_v139 )
                                                 }
data T_ScriptInfos_s141  = C_ScriptInfos_s141
type T_ScriptInfos_v139  = (T_ScriptInfos_vIn139 ) -> (T_ScriptInfos_vOut139 )
data T_ScriptInfos_vIn139  = T_ScriptInfos_vIn139 
data T_ScriptInfos_vOut139  = T_ScriptInfos_vOut139 (ScriptInfos)
{-# NOINLINE sem_ScriptInfos_Cons #-}
sem_ScriptInfos_Cons :: T_ScriptInfo  -> T_ScriptInfos  -> T_ScriptInfos 
sem_ScriptInfos_Cons hd_ tl_ = T_ScriptInfos (return st140) where
   {-# NOINLINE st140 #-}
   st140 = let
      v139 :: T_ScriptInfos_v139 
      v139 = \ (T_ScriptInfos_vIn139 ) -> ( let
         _hdX137 = Control.Monad.Identity.runIdentity (attach_T_ScriptInfo (hd_))
         _tlX140 = Control.Monad.Identity.runIdentity (attach_T_ScriptInfos (tl_))
         (T_ScriptInfo_vOut136 _hdIoutput) = inv_ScriptInfo_s137 _hdX137 (T_ScriptInfo_vIn136 )
         (T_ScriptInfos_vOut139 _tlIoutput) = inv_ScriptInfos_s140 _tlX140 (T_ScriptInfos_vIn139 )
         _output = rule969 _hdIoutput _tlIoutput
         _lhsOoutput :: ScriptInfos
         _lhsOoutput = rule970 _output
         __result_ = T_ScriptInfos_vOut139 _lhsOoutput
         in __result_ )
     in C_ScriptInfos_s140 v139
   {-# INLINE rule969 #-}
   rule969 = \ ((_hdIoutput) :: ScriptInfo) ((_tlIoutput) :: ScriptInfos) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule970 #-}
   rule970 = \ _output ->
     _output
{-# NOINLINE sem_ScriptInfos_Nil #-}
sem_ScriptInfos_Nil ::  T_ScriptInfos 
sem_ScriptInfos_Nil  = T_ScriptInfos (return st140) where
   {-# NOINLINE st140 #-}
   st140 = let
      v139 :: T_ScriptInfos_v139 
      v139 = \ (T_ScriptInfos_vIn139 ) -> ( let
         _output = rule971  ()
         _lhsOoutput :: ScriptInfos
         _lhsOoutput = rule972 _output
         __result_ = T_ScriptInfos_vOut139 _lhsOoutput
         in __result_ )
     in C_ScriptInfos_s140 v139
   {-# INLINE rule971 #-}
   rule971 = \  (_ :: ()) ->
     []
   {-# INLINE rule972 #-}
   rule972 = \ _output ->
     _output

-- SetInfo -----------------------------------------------------
-- data
data SetInfo 
  = SetInfo_Info {names_SetInfo_Info :: (NamespaceNames)}

-- cata
{-# INLINE sem_SetInfo #-}
sem_SetInfo :: SetInfo  -> T_SetInfo 
sem_SetInfo ( SetInfo_Info names_ ) = sem_SetInfo_Info ( sem_NamespaceNames names_ )

-- semantic domain
newtype T_SetInfo  = T_SetInfo {
                               attach_T_SetInfo :: Identity (T_SetInfo_s143 )
                               }
newtype T_SetInfo_s143  = C_SetInfo_s143 {
                                         inv_SetInfo_s143 :: (T_SetInfo_v142 )
                                         }
data T_SetInfo_s144  = C_SetInfo_s144
type T_SetInfo_v142  = (T_SetInfo_vIn142 ) -> (T_SetInfo_vOut142 )
data T_SetInfo_vIn142  = T_SetInfo_vIn142 
data T_SetInfo_vOut142  = T_SetInfo_vOut142 (SetInfo)
{-# NOINLINE sem_SetInfo_Info #-}
sem_SetInfo_Info :: T_NamespaceNames  -> T_SetInfo 
sem_SetInfo_Info names_ = T_SetInfo (return st143) where
   {-# NOINLINE st143 #-}
   st143 = let
      v142 :: T_SetInfo_v142 
      v142 = \ (T_SetInfo_vIn142 ) -> ( let
         _namesX104 = Control.Monad.Identity.runIdentity (attach_T_NamespaceNames (names_))
         (T_NamespaceNames_vOut103 _namesIoutput) = inv_NamespaceNames_s104 _namesX104 (T_NamespaceNames_vIn103 )
         _output = rule973 _namesIoutput
         _lhsOoutput :: SetInfo
         _lhsOoutput = rule974 _output
         __result_ = T_SetInfo_vOut142 _lhsOoutput
         in __result_ )
     in C_SetInfo_s143 v142
   {-# INLINE rule973 #-}
   rule973 = \ ((_namesIoutput) :: NamespaceNames) ->
     SetInfo_Info _namesIoutput
   {-# INLINE rule974 #-}
   rule974 = \ _output ->
     _output

-- SetInfos ----------------------------------------------------
-- data
type SetInfos  = [ SetInfo ]

-- cata
{-# NOINLINE sem_SetInfos #-}
sem_SetInfos :: SetInfos  -> T_SetInfos 
sem_SetInfos list = Prelude.foldr sem_SetInfos_Cons sem_SetInfos_Nil (Prelude.map sem_SetInfo list)

-- semantic domain
newtype T_SetInfos  = T_SetInfos {
                                 attach_T_SetInfos :: Identity (T_SetInfos_s146 )
                                 }
newtype T_SetInfos_s146  = C_SetInfos_s146 {
                                           inv_SetInfos_s146 :: (T_SetInfos_v145 )
                                           }
data T_SetInfos_s147  = C_SetInfos_s147
type T_SetInfos_v145  = (T_SetInfos_vIn145 ) -> (T_SetInfos_vOut145 )
data T_SetInfos_vIn145  = T_SetInfos_vIn145 
data T_SetInfos_vOut145  = T_SetInfos_vOut145 (SetInfos)
{-# NOINLINE sem_SetInfos_Cons #-}
sem_SetInfos_Cons :: T_SetInfo  -> T_SetInfos  -> T_SetInfos 
sem_SetInfos_Cons hd_ tl_ = T_SetInfos (return st146) where
   {-# NOINLINE st146 #-}
   st146 = let
      v145 :: T_SetInfos_v145 
      v145 = \ (T_SetInfos_vIn145 ) -> ( let
         _hdX143 = Control.Monad.Identity.runIdentity (attach_T_SetInfo (hd_))
         _tlX146 = Control.Monad.Identity.runIdentity (attach_T_SetInfos (tl_))
         (T_SetInfo_vOut142 _hdIoutput) = inv_SetInfo_s143 _hdX143 (T_SetInfo_vIn142 )
         (T_SetInfos_vOut145 _tlIoutput) = inv_SetInfos_s146 _tlX146 (T_SetInfos_vIn145 )
         _output = rule975 _hdIoutput _tlIoutput
         _lhsOoutput :: SetInfos
         _lhsOoutput = rule976 _output
         __result_ = T_SetInfos_vOut145 _lhsOoutput
         in __result_ )
     in C_SetInfos_s146 v145
   {-# INLINE rule975 #-}
   rule975 = \ ((_hdIoutput) :: SetInfo) ((_tlIoutput) :: SetInfos) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule976 #-}
   rule976 = \ _output ->
     _output
{-# NOINLINE sem_SetInfos_Nil #-}
sem_SetInfos_Nil ::  T_SetInfos 
sem_SetInfos_Nil  = T_SetInfos (return st146) where
   {-# NOINLINE st146 #-}
   st146 = let
      v145 :: T_SetInfos_v145 
      v145 = \ (T_SetInfos_vIn145 ) -> ( let
         _output = rule977  ()
         _lhsOoutput :: SetInfos
         _lhsOoutput = rule978 _output
         __result_ = T_SetInfos_vOut145 _lhsOoutput
         in __result_ )
     in C_SetInfos_s146 v145
   {-# INLINE rule977 #-}
   rule977 = \  (_ :: ()) ->
     []
   {-# INLINE rule978 #-}
   rule978 = \ _output ->
     _output

-- SwfFile -----------------------------------------------------
-- data
data SwfFile 
  = SwfFile_File {compressed_SwfFile_File :: (Bool), version_SwfFile_File :: (Word8), length_SwfFile_File :: (Word32), size_SwfFile_File :: (Rect), rate_SwfFile_File :: (Word16), count_SwfFile_File :: (Word16), tags_SwfFile_File :: (Tags)}

-- wrapper
data Inh_SwfFile  = Inh_SwfFile {  }
data Syn_SwfFile  = Syn_SwfFile { output_Syn_SwfFile :: (SwfFile) }
{-# INLINABLE wrap_SwfFile #-}
wrap_SwfFile :: T_SwfFile  -> Inh_SwfFile  -> (Syn_SwfFile )
wrap_SwfFile (T_SwfFile act) (Inh_SwfFile ) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg = T_SwfFile_vIn148 
        (T_SwfFile_vOut148 _lhsOoutput) <- return (inv_SwfFile_s149 sem arg)
        return (Syn_SwfFile _lhsOoutput)
   )

-- cata
{-# INLINE sem_SwfFile #-}
sem_SwfFile :: SwfFile  -> T_SwfFile 
sem_SwfFile ( SwfFile_File compressed_ version_ length_ size_ rate_ count_ tags_ ) = sem_SwfFile_File compressed_ version_ length_ ( sem_Rect size_ ) rate_ count_ ( sem_Tags tags_ )

-- semantic domain
newtype T_SwfFile  = T_SwfFile {
                               attach_T_SwfFile :: Identity (T_SwfFile_s149 )
                               }
newtype T_SwfFile_s149  = C_SwfFile_s149 {
                                         inv_SwfFile_s149 :: (T_SwfFile_v148 )
                                         }
data T_SwfFile_s150  = C_SwfFile_s150
type T_SwfFile_v148  = (T_SwfFile_vIn148 ) -> (T_SwfFile_vOut148 )
data T_SwfFile_vIn148  = T_SwfFile_vIn148 
data T_SwfFile_vOut148  = T_SwfFile_vOut148 (SwfFile)
{-# NOINLINE sem_SwfFile_File #-}
sem_SwfFile_File :: (Bool) -> (Word8) -> (Word32) -> T_Rect  -> (Word16) -> (Word16) -> T_Tags  -> T_SwfFile 
sem_SwfFile_File compressed_ version_ length_ size_ rate_ count_ tags_ = T_SwfFile (return st149) where
   {-# NOINLINE st149 #-}
   st149 = let
      v148 :: T_SwfFile_v148 
      v148 = \ (T_SwfFile_vIn148 ) -> ( let
         _sizeX134 = Control.Monad.Identity.runIdentity (attach_T_Rect (size_))
         _tagsX158 = Control.Monad.Identity.runIdentity (attach_T_Tags (tags_))
         (T_Rect_vOut133 _sizeIoutput) = inv_Rect_s134 _sizeX134 (T_Rect_vIn133 )
         (T_Tags_vOut157 _tagsIoutput) = inv_Tags_s158 _tagsX158 (T_Tags_vIn157 )
         _output = rule979 _sizeIoutput _tagsIoutput compressed_ count_ length_ rate_ version_
         _lhsOoutput :: SwfFile
         _lhsOoutput = rule980 _output
         __result_ = T_SwfFile_vOut148 _lhsOoutput
         in __result_ )
     in C_SwfFile_s149 v148
   {-# INLINE rule979 #-}
   rule979 = \ ((_sizeIoutput) :: Rect) ((_tagsIoutput) :: Tags) compressed_ count_ length_ rate_ version_ ->
     SwfFile_File compressed_ version_ length_ _sizeIoutput rate_ count_ _tagsIoutput
   {-# INLINE rule980 #-}
   rule980 = \ _output ->
     _output

-- Tag ---------------------------------------------------------
-- data
data Tag 
  = Tag_Abc {flags_Tag_Abc :: (AbcFlags), name_Tag_Abc :: (ByteString), file_Tag_Abc :: (AbcFile)}
  | Tag_FileAttributes {useDirectBlit_Tag_FileAttributes :: (Bool), useGPU_Tag_FileAttributes :: (Bool), hasMetaData_Tag_FileAttributes :: (Bool), hasAS3_Tag_FileAttributes :: (Bool), useNetwork_Tag_FileAttributes :: (Bool)}
  | Tag_Opaque {kind_Tag_Opaque :: (TagKind), length_Tag_Opaque :: (Word32), body_Tag_Opaque :: (ByteString)}
  | Tag_End {}

-- cata
{-# NOINLINE sem_Tag #-}
sem_Tag :: Tag  -> T_Tag 
sem_Tag ( Tag_Abc flags_ name_ file_ ) = sem_Tag_Abc ( sem_AbcFlags flags_ ) name_ ( sem_AbcFile file_ )
sem_Tag ( Tag_FileAttributes useDirectBlit_ useGPU_ hasMetaData_ hasAS3_ useNetwork_ ) = sem_Tag_FileAttributes useDirectBlit_ useGPU_ hasMetaData_ hasAS3_ useNetwork_
sem_Tag ( Tag_Opaque kind_ length_ body_ ) = sem_Tag_Opaque ( sem_TagKind kind_ ) length_ body_
sem_Tag ( Tag_End  ) = sem_Tag_End 

-- semantic domain
newtype T_Tag  = T_Tag {
                       attach_T_Tag :: Identity (T_Tag_s152 )
                       }
newtype T_Tag_s152  = C_Tag_s152 {
                                 inv_Tag_s152 :: (T_Tag_v151 )
                                 }
data T_Tag_s153  = C_Tag_s153
type T_Tag_v151  = (T_Tag_vIn151 ) -> (T_Tag_vOut151 )
data T_Tag_vIn151  = T_Tag_vIn151 
data T_Tag_vOut151  = T_Tag_vOut151 (Tag)
{-# NOINLINE sem_Tag_Abc #-}
sem_Tag_Abc :: T_AbcFlags  -> (ByteString) -> T_AbcFile  -> T_Tag 
sem_Tag_Abc flags_ name_ file_ = T_Tag (return st152) where
   {-# NOINLINE st152 #-}
   st152 = let
      v151 :: T_Tag_v151 
      v151 = \ (T_Tag_vIn151 ) -> ( let
         _flagsX8 = Control.Monad.Identity.runIdentity (attach_T_AbcFlags (flags_))
         _fileX2 = Control.Monad.Identity.runIdentity (attach_T_AbcFile (file_))
         (T_AbcFlags_vOut7 _flagsIoutput) = inv_AbcFlags_s8 _flagsX8 (T_AbcFlags_vIn7 )
         (T_AbcFile_vOut1 _fileIoutput) = inv_AbcFile_s2 _fileX2 (T_AbcFile_vIn1 )
         _output = rule981 _fileIoutput _flagsIoutput name_
         _lhsOoutput :: Tag
         _lhsOoutput = rule982 _output
         __result_ = T_Tag_vOut151 _lhsOoutput
         in __result_ )
     in C_Tag_s152 v151
   {-# INLINE rule981 #-}
   rule981 = \ ((_fileIoutput) :: AbcFile) ((_flagsIoutput) :: AbcFlags) name_ ->
     Tag_Abc _flagsIoutput name_ _fileIoutput
   {-# INLINE rule982 #-}
   rule982 = \ _output ->
     _output
{-# NOINLINE sem_Tag_FileAttributes #-}
sem_Tag_FileAttributes :: (Bool) -> (Bool) -> (Bool) -> (Bool) -> (Bool) -> T_Tag 
sem_Tag_FileAttributes useDirectBlit_ useGPU_ hasMetaData_ hasAS3_ useNetwork_ = T_Tag (return st152) where
   {-# NOINLINE st152 #-}
   st152 = let
      v151 :: T_Tag_v151 
      v151 = \ (T_Tag_vIn151 ) -> ( let
         _output = rule983 hasAS3_ hasMetaData_ useDirectBlit_ useGPU_ useNetwork_
         _lhsOoutput :: Tag
         _lhsOoutput = rule984 _output
         __result_ = T_Tag_vOut151 _lhsOoutput
         in __result_ )
     in C_Tag_s152 v151
   {-# INLINE rule983 #-}
   rule983 = \ hasAS3_ hasMetaData_ useDirectBlit_ useGPU_ useNetwork_ ->
     Tag_FileAttributes useDirectBlit_ useGPU_ hasMetaData_ hasAS3_ useNetwork_
   {-# INLINE rule984 #-}
   rule984 = \ _output ->
     _output
{-# NOINLINE sem_Tag_Opaque #-}
sem_Tag_Opaque :: T_TagKind  -> (Word32) -> (ByteString) -> T_Tag 
sem_Tag_Opaque kind_ length_ body_ = T_Tag (return st152) where
   {-# NOINLINE st152 #-}
   st152 = let
      v151 :: T_Tag_v151 
      v151 = \ (T_Tag_vIn151 ) -> ( let
         _kindX155 = Control.Monad.Identity.runIdentity (attach_T_TagKind (kind_))
         (T_TagKind_vOut154 _kindIoutput) = inv_TagKind_s155 _kindX155 (T_TagKind_vIn154 )
         _output = rule985 _kindIoutput body_ length_
         _lhsOoutput :: Tag
         _lhsOoutput = rule986 _output
         __result_ = T_Tag_vOut151 _lhsOoutput
         in __result_ )
     in C_Tag_s152 v151
   {-# INLINE rule985 #-}
   rule985 = \ ((_kindIoutput) :: TagKind) body_ length_ ->
     Tag_Opaque _kindIoutput length_ body_
   {-# INLINE rule986 #-}
   rule986 = \ _output ->
     _output
{-# NOINLINE sem_Tag_End #-}
sem_Tag_End ::  T_Tag 
sem_Tag_End  = T_Tag (return st152) where
   {-# NOINLINE st152 #-}
   st152 = let
      v151 :: T_Tag_v151 
      v151 = \ (T_Tag_vIn151 ) -> ( let
         _output = rule987  ()
         _lhsOoutput :: Tag
         _lhsOoutput = rule988 _output
         __result_ = T_Tag_vOut151 _lhsOoutput
         in __result_ )
     in C_Tag_s152 v151
   {-# INLINE rule987 #-}
   rule987 = \  (_ :: ()) ->
     Tag_End
   {-# INLINE rule988 #-}
   rule988 = \ _output ->
     _output

-- TagKind -----------------------------------------------------
-- data
data TagKind 
  = TagKind_End {}
  | TagKind_ShowFrame {}
  | TagKind_DefineShape {}
  | TagKind_PlaceObject {}
  | TagKind_RemoveObject {}
  | TagKind_DefineBits {}
  | TagKind_DefineButton {}
  | TagKind_JPEGTables {}
  | TagKind_SetBackgroundColor {}
  | TagKind_DefineFont {}
  | TagKind_DefineText {}
  | TagKind_DoAction {}
  | TagKind_DefineFontInfo {}
  | TagKind_DefineSound {}
  | TagKind_StartSound {}
  | TagKind_DefineButtonSound {}
  | TagKind_SoundStreamHead {}
  | TagKind_SoundStreamBlock {}
  | TagKind_DefineBitsLossless {}
  | TagKind_DefineBitsJPEG2 {}
  | TagKind_DefineShape2 {}
  | TagKind_DefineButtonCxform {}
  | TagKind_Protect {}
  | TagKind_PlaceObject2 {}
  | TagKind_RemoveObject2 {}
  | TagKind_DefineShape3 {}
  | TagKind_DefineText2 {}
  | TagKind_DefineButton2 {}
  | TagKind_DefineBitsJPEG3 {}
  | TagKind_DefineBitsLossless2 {}
  | TagKind_DefineEditText {}
  | TagKind_DefineSprite {}
  | TagKind_FrameLabel {}
  | TagKind_SoundStreamHead2 {}
  | TagKind_DefineMorphShape {}
  | TagKind_DefineFont2 {}
  | TagKind_ExportAssets {}
  | TagKind_ImportAssets {}
  | TagKind_EnableDebugger {}
  | TagKind_DoInitAction {}
  | TagKind_DefineVideoStream {}
  | TagKind_VideoFrame {}
  | TagKind_DefineFontInfo2 {}
  | TagKind_EnableDebugger2 {}
  | TagKind_ScriptLimits {}
  | TagKind_SetTabIndex {}
  | TagKind_FileAttributes {}
  | TagKind_PlaceObject3 {}
  | TagKind_ImportAssets2 {}
  | TagKind_DefineFontAlignZones {}
  | TagKind_CSMTextSettings {}
  | TagKind_DefineFont3 {}
  | TagKind_SymbolClass {}
  | TagKind_Metadata {}
  | TagKind_DefineScalingGrid {}
  | TagKind_DoABC {}
  | TagKind_DefineShape4 {}
  | TagKind_DefineMorphShape2 {}
  | TagKind_DefineSceneAndFrameLabelData {}
  | TagKind_DefineBinaryData {}
  | TagKind_DefineFontName {}
  | TagKind_StartSound2 {}
  | TagKind_DefineBitsJPEG4 {}
  | TagKind_DefineFont4 {}
  | TagKind_Other {code_TagKind_Other :: (Word16)}

-- cata
{-# NOINLINE sem_TagKind #-}
sem_TagKind :: TagKind  -> T_TagKind 
sem_TagKind ( TagKind_End  ) = sem_TagKind_End 
sem_TagKind ( TagKind_ShowFrame  ) = sem_TagKind_ShowFrame 
sem_TagKind ( TagKind_DefineShape  ) = sem_TagKind_DefineShape 
sem_TagKind ( TagKind_PlaceObject  ) = sem_TagKind_PlaceObject 
sem_TagKind ( TagKind_RemoveObject  ) = sem_TagKind_RemoveObject 
sem_TagKind ( TagKind_DefineBits  ) = sem_TagKind_DefineBits 
sem_TagKind ( TagKind_DefineButton  ) = sem_TagKind_DefineButton 
sem_TagKind ( TagKind_JPEGTables  ) = sem_TagKind_JPEGTables 
sem_TagKind ( TagKind_SetBackgroundColor  ) = sem_TagKind_SetBackgroundColor 
sem_TagKind ( TagKind_DefineFont  ) = sem_TagKind_DefineFont 
sem_TagKind ( TagKind_DefineText  ) = sem_TagKind_DefineText 
sem_TagKind ( TagKind_DoAction  ) = sem_TagKind_DoAction 
sem_TagKind ( TagKind_DefineFontInfo  ) = sem_TagKind_DefineFontInfo 
sem_TagKind ( TagKind_DefineSound  ) = sem_TagKind_DefineSound 
sem_TagKind ( TagKind_StartSound  ) = sem_TagKind_StartSound 
sem_TagKind ( TagKind_DefineButtonSound  ) = sem_TagKind_DefineButtonSound 
sem_TagKind ( TagKind_SoundStreamHead  ) = sem_TagKind_SoundStreamHead 
sem_TagKind ( TagKind_SoundStreamBlock  ) = sem_TagKind_SoundStreamBlock 
sem_TagKind ( TagKind_DefineBitsLossless  ) = sem_TagKind_DefineBitsLossless 
sem_TagKind ( TagKind_DefineBitsJPEG2  ) = sem_TagKind_DefineBitsJPEG2 
sem_TagKind ( TagKind_DefineShape2  ) = sem_TagKind_DefineShape2 
sem_TagKind ( TagKind_DefineButtonCxform  ) = sem_TagKind_DefineButtonCxform 
sem_TagKind ( TagKind_Protect  ) = sem_TagKind_Protect 
sem_TagKind ( TagKind_PlaceObject2  ) = sem_TagKind_PlaceObject2 
sem_TagKind ( TagKind_RemoveObject2  ) = sem_TagKind_RemoveObject2 
sem_TagKind ( TagKind_DefineShape3  ) = sem_TagKind_DefineShape3 
sem_TagKind ( TagKind_DefineText2  ) = sem_TagKind_DefineText2 
sem_TagKind ( TagKind_DefineButton2  ) = sem_TagKind_DefineButton2 
sem_TagKind ( TagKind_DefineBitsJPEG3  ) = sem_TagKind_DefineBitsJPEG3 
sem_TagKind ( TagKind_DefineBitsLossless2  ) = sem_TagKind_DefineBitsLossless2 
sem_TagKind ( TagKind_DefineEditText  ) = sem_TagKind_DefineEditText 
sem_TagKind ( TagKind_DefineSprite  ) = sem_TagKind_DefineSprite 
sem_TagKind ( TagKind_FrameLabel  ) = sem_TagKind_FrameLabel 
sem_TagKind ( TagKind_SoundStreamHead2  ) = sem_TagKind_SoundStreamHead2 
sem_TagKind ( TagKind_DefineMorphShape  ) = sem_TagKind_DefineMorphShape 
sem_TagKind ( TagKind_DefineFont2  ) = sem_TagKind_DefineFont2 
sem_TagKind ( TagKind_ExportAssets  ) = sem_TagKind_ExportAssets 
sem_TagKind ( TagKind_ImportAssets  ) = sem_TagKind_ImportAssets 
sem_TagKind ( TagKind_EnableDebugger  ) = sem_TagKind_EnableDebugger 
sem_TagKind ( TagKind_DoInitAction  ) = sem_TagKind_DoInitAction 
sem_TagKind ( TagKind_DefineVideoStream  ) = sem_TagKind_DefineVideoStream 
sem_TagKind ( TagKind_VideoFrame  ) = sem_TagKind_VideoFrame 
sem_TagKind ( TagKind_DefineFontInfo2  ) = sem_TagKind_DefineFontInfo2 
sem_TagKind ( TagKind_EnableDebugger2  ) = sem_TagKind_EnableDebugger2 
sem_TagKind ( TagKind_ScriptLimits  ) = sem_TagKind_ScriptLimits 
sem_TagKind ( TagKind_SetTabIndex  ) = sem_TagKind_SetTabIndex 
sem_TagKind ( TagKind_FileAttributes  ) = sem_TagKind_FileAttributes 
sem_TagKind ( TagKind_PlaceObject3  ) = sem_TagKind_PlaceObject3 
sem_TagKind ( TagKind_ImportAssets2  ) = sem_TagKind_ImportAssets2 
sem_TagKind ( TagKind_DefineFontAlignZones  ) = sem_TagKind_DefineFontAlignZones 
sem_TagKind ( TagKind_CSMTextSettings  ) = sem_TagKind_CSMTextSettings 
sem_TagKind ( TagKind_DefineFont3  ) = sem_TagKind_DefineFont3 
sem_TagKind ( TagKind_SymbolClass  ) = sem_TagKind_SymbolClass 
sem_TagKind ( TagKind_Metadata  ) = sem_TagKind_Metadata 
sem_TagKind ( TagKind_DefineScalingGrid  ) = sem_TagKind_DefineScalingGrid 
sem_TagKind ( TagKind_DoABC  ) = sem_TagKind_DoABC 
sem_TagKind ( TagKind_DefineShape4  ) = sem_TagKind_DefineShape4 
sem_TagKind ( TagKind_DefineMorphShape2  ) = sem_TagKind_DefineMorphShape2 
sem_TagKind ( TagKind_DefineSceneAndFrameLabelData  ) = sem_TagKind_DefineSceneAndFrameLabelData 
sem_TagKind ( TagKind_DefineBinaryData  ) = sem_TagKind_DefineBinaryData 
sem_TagKind ( TagKind_DefineFontName  ) = sem_TagKind_DefineFontName 
sem_TagKind ( TagKind_StartSound2  ) = sem_TagKind_StartSound2 
sem_TagKind ( TagKind_DefineBitsJPEG4  ) = sem_TagKind_DefineBitsJPEG4 
sem_TagKind ( TagKind_DefineFont4  ) = sem_TagKind_DefineFont4 
sem_TagKind ( TagKind_Other code_ ) = sem_TagKind_Other code_

-- semantic domain
newtype T_TagKind  = T_TagKind {
                               attach_T_TagKind :: Identity (T_TagKind_s155 )
                               }
newtype T_TagKind_s155  = C_TagKind_s155 {
                                         inv_TagKind_s155 :: (T_TagKind_v154 )
                                         }
data T_TagKind_s156  = C_TagKind_s156
type T_TagKind_v154  = (T_TagKind_vIn154 ) -> (T_TagKind_vOut154 )
data T_TagKind_vIn154  = T_TagKind_vIn154 
data T_TagKind_vOut154  = T_TagKind_vOut154 (TagKind)
{-# NOINLINE sem_TagKind_End #-}
sem_TagKind_End ::  T_TagKind 
sem_TagKind_End  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule989  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule990 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule989 #-}
   rule989 = \  (_ :: ()) ->
     TagKind_End
   {-# INLINE rule990 #-}
   rule990 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_ShowFrame #-}
sem_TagKind_ShowFrame ::  T_TagKind 
sem_TagKind_ShowFrame  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule991  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule992 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule991 #-}
   rule991 = \  (_ :: ()) ->
     TagKind_ShowFrame
   {-# INLINE rule992 #-}
   rule992 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineShape #-}
sem_TagKind_DefineShape ::  T_TagKind 
sem_TagKind_DefineShape  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule993  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule994 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule993 #-}
   rule993 = \  (_ :: ()) ->
     TagKind_DefineShape
   {-# INLINE rule994 #-}
   rule994 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_PlaceObject #-}
sem_TagKind_PlaceObject ::  T_TagKind 
sem_TagKind_PlaceObject  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule995  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule996 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule995 #-}
   rule995 = \  (_ :: ()) ->
     TagKind_PlaceObject
   {-# INLINE rule996 #-}
   rule996 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_RemoveObject #-}
sem_TagKind_RemoveObject ::  T_TagKind 
sem_TagKind_RemoveObject  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule997  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule998 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule997 #-}
   rule997 = \  (_ :: ()) ->
     TagKind_RemoveObject
   {-# INLINE rule998 #-}
   rule998 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineBits #-}
sem_TagKind_DefineBits ::  T_TagKind 
sem_TagKind_DefineBits  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule999  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1000 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule999 #-}
   rule999 = \  (_ :: ()) ->
     TagKind_DefineBits
   {-# INLINE rule1000 #-}
   rule1000 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineButton #-}
sem_TagKind_DefineButton ::  T_TagKind 
sem_TagKind_DefineButton  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1001  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1002 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1001 #-}
   rule1001 = \  (_ :: ()) ->
     TagKind_DefineButton
   {-# INLINE rule1002 #-}
   rule1002 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_JPEGTables #-}
sem_TagKind_JPEGTables ::  T_TagKind 
sem_TagKind_JPEGTables  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1003  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1004 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1003 #-}
   rule1003 = \  (_ :: ()) ->
     TagKind_JPEGTables
   {-# INLINE rule1004 #-}
   rule1004 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_SetBackgroundColor #-}
sem_TagKind_SetBackgroundColor ::  T_TagKind 
sem_TagKind_SetBackgroundColor  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1005  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1006 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1005 #-}
   rule1005 = \  (_ :: ()) ->
     TagKind_SetBackgroundColor
   {-# INLINE rule1006 #-}
   rule1006 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineFont #-}
sem_TagKind_DefineFont ::  T_TagKind 
sem_TagKind_DefineFont  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1007  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1008 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1007 #-}
   rule1007 = \  (_ :: ()) ->
     TagKind_DefineFont
   {-# INLINE rule1008 #-}
   rule1008 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineText #-}
sem_TagKind_DefineText ::  T_TagKind 
sem_TagKind_DefineText  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1009  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1010 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1009 #-}
   rule1009 = \  (_ :: ()) ->
     TagKind_DefineText
   {-# INLINE rule1010 #-}
   rule1010 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DoAction #-}
sem_TagKind_DoAction ::  T_TagKind 
sem_TagKind_DoAction  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1011  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1012 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1011 #-}
   rule1011 = \  (_ :: ()) ->
     TagKind_DoAction
   {-# INLINE rule1012 #-}
   rule1012 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineFontInfo #-}
sem_TagKind_DefineFontInfo ::  T_TagKind 
sem_TagKind_DefineFontInfo  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1013  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1014 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1013 #-}
   rule1013 = \  (_ :: ()) ->
     TagKind_DefineFontInfo
   {-# INLINE rule1014 #-}
   rule1014 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineSound #-}
sem_TagKind_DefineSound ::  T_TagKind 
sem_TagKind_DefineSound  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1015  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1016 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1015 #-}
   rule1015 = \  (_ :: ()) ->
     TagKind_DefineSound
   {-# INLINE rule1016 #-}
   rule1016 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_StartSound #-}
sem_TagKind_StartSound ::  T_TagKind 
sem_TagKind_StartSound  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1017  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1018 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1017 #-}
   rule1017 = \  (_ :: ()) ->
     TagKind_StartSound
   {-# INLINE rule1018 #-}
   rule1018 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineButtonSound #-}
sem_TagKind_DefineButtonSound ::  T_TagKind 
sem_TagKind_DefineButtonSound  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1019  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1020 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1019 #-}
   rule1019 = \  (_ :: ()) ->
     TagKind_DefineButtonSound
   {-# INLINE rule1020 #-}
   rule1020 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_SoundStreamHead #-}
sem_TagKind_SoundStreamHead ::  T_TagKind 
sem_TagKind_SoundStreamHead  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1021  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1022 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1021 #-}
   rule1021 = \  (_ :: ()) ->
     TagKind_SoundStreamHead
   {-# INLINE rule1022 #-}
   rule1022 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_SoundStreamBlock #-}
sem_TagKind_SoundStreamBlock ::  T_TagKind 
sem_TagKind_SoundStreamBlock  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1023  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1024 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1023 #-}
   rule1023 = \  (_ :: ()) ->
     TagKind_SoundStreamBlock
   {-# INLINE rule1024 #-}
   rule1024 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineBitsLossless #-}
sem_TagKind_DefineBitsLossless ::  T_TagKind 
sem_TagKind_DefineBitsLossless  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1025  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1026 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1025 #-}
   rule1025 = \  (_ :: ()) ->
     TagKind_DefineBitsLossless
   {-# INLINE rule1026 #-}
   rule1026 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineBitsJPEG2 #-}
sem_TagKind_DefineBitsJPEG2 ::  T_TagKind 
sem_TagKind_DefineBitsJPEG2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1027  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1028 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1027 #-}
   rule1027 = \  (_ :: ()) ->
     TagKind_DefineBitsJPEG2
   {-# INLINE rule1028 #-}
   rule1028 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineShape2 #-}
sem_TagKind_DefineShape2 ::  T_TagKind 
sem_TagKind_DefineShape2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1029  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1030 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1029 #-}
   rule1029 = \  (_ :: ()) ->
     TagKind_DefineShape2
   {-# INLINE rule1030 #-}
   rule1030 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineButtonCxform #-}
sem_TagKind_DefineButtonCxform ::  T_TagKind 
sem_TagKind_DefineButtonCxform  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1031  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1032 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1031 #-}
   rule1031 = \  (_ :: ()) ->
     TagKind_DefineButtonCxform
   {-# INLINE rule1032 #-}
   rule1032 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_Protect #-}
sem_TagKind_Protect ::  T_TagKind 
sem_TagKind_Protect  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1033  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1034 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1033 #-}
   rule1033 = \  (_ :: ()) ->
     TagKind_Protect
   {-# INLINE rule1034 #-}
   rule1034 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_PlaceObject2 #-}
sem_TagKind_PlaceObject2 ::  T_TagKind 
sem_TagKind_PlaceObject2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1035  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1036 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1035 #-}
   rule1035 = \  (_ :: ()) ->
     TagKind_PlaceObject2
   {-# INLINE rule1036 #-}
   rule1036 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_RemoveObject2 #-}
sem_TagKind_RemoveObject2 ::  T_TagKind 
sem_TagKind_RemoveObject2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1037  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1038 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1037 #-}
   rule1037 = \  (_ :: ()) ->
     TagKind_RemoveObject2
   {-# INLINE rule1038 #-}
   rule1038 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineShape3 #-}
sem_TagKind_DefineShape3 ::  T_TagKind 
sem_TagKind_DefineShape3  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1039  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1040 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1039 #-}
   rule1039 = \  (_ :: ()) ->
     TagKind_DefineShape3
   {-# INLINE rule1040 #-}
   rule1040 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineText2 #-}
sem_TagKind_DefineText2 ::  T_TagKind 
sem_TagKind_DefineText2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1041  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1042 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1041 #-}
   rule1041 = \  (_ :: ()) ->
     TagKind_DefineText2
   {-# INLINE rule1042 #-}
   rule1042 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineButton2 #-}
sem_TagKind_DefineButton2 ::  T_TagKind 
sem_TagKind_DefineButton2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1043  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1044 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1043 #-}
   rule1043 = \  (_ :: ()) ->
     TagKind_DefineButton2
   {-# INLINE rule1044 #-}
   rule1044 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineBitsJPEG3 #-}
sem_TagKind_DefineBitsJPEG3 ::  T_TagKind 
sem_TagKind_DefineBitsJPEG3  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1045  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1046 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1045 #-}
   rule1045 = \  (_ :: ()) ->
     TagKind_DefineBitsJPEG3
   {-# INLINE rule1046 #-}
   rule1046 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineBitsLossless2 #-}
sem_TagKind_DefineBitsLossless2 ::  T_TagKind 
sem_TagKind_DefineBitsLossless2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1047  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1048 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1047 #-}
   rule1047 = \  (_ :: ()) ->
     TagKind_DefineBitsLossless2
   {-# INLINE rule1048 #-}
   rule1048 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineEditText #-}
sem_TagKind_DefineEditText ::  T_TagKind 
sem_TagKind_DefineEditText  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1049  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1050 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1049 #-}
   rule1049 = \  (_ :: ()) ->
     TagKind_DefineEditText
   {-# INLINE rule1050 #-}
   rule1050 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineSprite #-}
sem_TagKind_DefineSprite ::  T_TagKind 
sem_TagKind_DefineSprite  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1051  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1052 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1051 #-}
   rule1051 = \  (_ :: ()) ->
     TagKind_DefineSprite
   {-# INLINE rule1052 #-}
   rule1052 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_FrameLabel #-}
sem_TagKind_FrameLabel ::  T_TagKind 
sem_TagKind_FrameLabel  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1053  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1054 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1053 #-}
   rule1053 = \  (_ :: ()) ->
     TagKind_FrameLabel
   {-# INLINE rule1054 #-}
   rule1054 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_SoundStreamHead2 #-}
sem_TagKind_SoundStreamHead2 ::  T_TagKind 
sem_TagKind_SoundStreamHead2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1055  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1056 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1055 #-}
   rule1055 = \  (_ :: ()) ->
     TagKind_SoundStreamHead2
   {-# INLINE rule1056 #-}
   rule1056 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineMorphShape #-}
sem_TagKind_DefineMorphShape ::  T_TagKind 
sem_TagKind_DefineMorphShape  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1057  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1058 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1057 #-}
   rule1057 = \  (_ :: ()) ->
     TagKind_DefineMorphShape
   {-# INLINE rule1058 #-}
   rule1058 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineFont2 #-}
sem_TagKind_DefineFont2 ::  T_TagKind 
sem_TagKind_DefineFont2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1059  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1060 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1059 #-}
   rule1059 = \  (_ :: ()) ->
     TagKind_DefineFont2
   {-# INLINE rule1060 #-}
   rule1060 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_ExportAssets #-}
sem_TagKind_ExportAssets ::  T_TagKind 
sem_TagKind_ExportAssets  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1061  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1062 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1061 #-}
   rule1061 = \  (_ :: ()) ->
     TagKind_ExportAssets
   {-# INLINE rule1062 #-}
   rule1062 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_ImportAssets #-}
sem_TagKind_ImportAssets ::  T_TagKind 
sem_TagKind_ImportAssets  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1063  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1064 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1063 #-}
   rule1063 = \  (_ :: ()) ->
     TagKind_ImportAssets
   {-# INLINE rule1064 #-}
   rule1064 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_EnableDebugger #-}
sem_TagKind_EnableDebugger ::  T_TagKind 
sem_TagKind_EnableDebugger  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1065  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1066 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1065 #-}
   rule1065 = \  (_ :: ()) ->
     TagKind_EnableDebugger
   {-# INLINE rule1066 #-}
   rule1066 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DoInitAction #-}
sem_TagKind_DoInitAction ::  T_TagKind 
sem_TagKind_DoInitAction  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1067  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1068 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1067 #-}
   rule1067 = \  (_ :: ()) ->
     TagKind_DoInitAction
   {-# INLINE rule1068 #-}
   rule1068 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineVideoStream #-}
sem_TagKind_DefineVideoStream ::  T_TagKind 
sem_TagKind_DefineVideoStream  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1069  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1070 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1069 #-}
   rule1069 = \  (_ :: ()) ->
     TagKind_DefineVideoStream
   {-# INLINE rule1070 #-}
   rule1070 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_VideoFrame #-}
sem_TagKind_VideoFrame ::  T_TagKind 
sem_TagKind_VideoFrame  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1071  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1072 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1071 #-}
   rule1071 = \  (_ :: ()) ->
     TagKind_VideoFrame
   {-# INLINE rule1072 #-}
   rule1072 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineFontInfo2 #-}
sem_TagKind_DefineFontInfo2 ::  T_TagKind 
sem_TagKind_DefineFontInfo2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1073  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1074 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1073 #-}
   rule1073 = \  (_ :: ()) ->
     TagKind_DefineFontInfo2
   {-# INLINE rule1074 #-}
   rule1074 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_EnableDebugger2 #-}
sem_TagKind_EnableDebugger2 ::  T_TagKind 
sem_TagKind_EnableDebugger2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1075  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1076 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1075 #-}
   rule1075 = \  (_ :: ()) ->
     TagKind_EnableDebugger2
   {-# INLINE rule1076 #-}
   rule1076 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_ScriptLimits #-}
sem_TagKind_ScriptLimits ::  T_TagKind 
sem_TagKind_ScriptLimits  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1077  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1078 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1077 #-}
   rule1077 = \  (_ :: ()) ->
     TagKind_ScriptLimits
   {-# INLINE rule1078 #-}
   rule1078 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_SetTabIndex #-}
sem_TagKind_SetTabIndex ::  T_TagKind 
sem_TagKind_SetTabIndex  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1079  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1080 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1079 #-}
   rule1079 = \  (_ :: ()) ->
     TagKind_SetTabIndex
   {-# INLINE rule1080 #-}
   rule1080 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_FileAttributes #-}
sem_TagKind_FileAttributes ::  T_TagKind 
sem_TagKind_FileAttributes  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1081  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1082 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1081 #-}
   rule1081 = \  (_ :: ()) ->
     TagKind_FileAttributes
   {-# INLINE rule1082 #-}
   rule1082 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_PlaceObject3 #-}
sem_TagKind_PlaceObject3 ::  T_TagKind 
sem_TagKind_PlaceObject3  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1083  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1084 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1083 #-}
   rule1083 = \  (_ :: ()) ->
     TagKind_PlaceObject3
   {-# INLINE rule1084 #-}
   rule1084 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_ImportAssets2 #-}
sem_TagKind_ImportAssets2 ::  T_TagKind 
sem_TagKind_ImportAssets2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1085  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1086 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1085 #-}
   rule1085 = \  (_ :: ()) ->
     TagKind_ImportAssets2
   {-# INLINE rule1086 #-}
   rule1086 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineFontAlignZones #-}
sem_TagKind_DefineFontAlignZones ::  T_TagKind 
sem_TagKind_DefineFontAlignZones  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1087  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1088 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1087 #-}
   rule1087 = \  (_ :: ()) ->
     TagKind_DefineFontAlignZones
   {-# INLINE rule1088 #-}
   rule1088 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_CSMTextSettings #-}
sem_TagKind_CSMTextSettings ::  T_TagKind 
sem_TagKind_CSMTextSettings  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1089  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1090 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1089 #-}
   rule1089 = \  (_ :: ()) ->
     TagKind_CSMTextSettings
   {-# INLINE rule1090 #-}
   rule1090 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineFont3 #-}
sem_TagKind_DefineFont3 ::  T_TagKind 
sem_TagKind_DefineFont3  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1091  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1092 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1091 #-}
   rule1091 = \  (_ :: ()) ->
     TagKind_DefineFont3
   {-# INLINE rule1092 #-}
   rule1092 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_SymbolClass #-}
sem_TagKind_SymbolClass ::  T_TagKind 
sem_TagKind_SymbolClass  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1093  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1094 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1093 #-}
   rule1093 = \  (_ :: ()) ->
     TagKind_SymbolClass
   {-# INLINE rule1094 #-}
   rule1094 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_Metadata #-}
sem_TagKind_Metadata ::  T_TagKind 
sem_TagKind_Metadata  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1095  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1096 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1095 #-}
   rule1095 = \  (_ :: ()) ->
     TagKind_Metadata
   {-# INLINE rule1096 #-}
   rule1096 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineScalingGrid #-}
sem_TagKind_DefineScalingGrid ::  T_TagKind 
sem_TagKind_DefineScalingGrid  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1097  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1098 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1097 #-}
   rule1097 = \  (_ :: ()) ->
     TagKind_DefineScalingGrid
   {-# INLINE rule1098 #-}
   rule1098 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DoABC #-}
sem_TagKind_DoABC ::  T_TagKind 
sem_TagKind_DoABC  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1099  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1100 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1099 #-}
   rule1099 = \  (_ :: ()) ->
     TagKind_DoABC
   {-# INLINE rule1100 #-}
   rule1100 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineShape4 #-}
sem_TagKind_DefineShape4 ::  T_TagKind 
sem_TagKind_DefineShape4  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1101  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1102 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1101 #-}
   rule1101 = \  (_ :: ()) ->
     TagKind_DefineShape4
   {-# INLINE rule1102 #-}
   rule1102 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineMorphShape2 #-}
sem_TagKind_DefineMorphShape2 ::  T_TagKind 
sem_TagKind_DefineMorphShape2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1103  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1104 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1103 #-}
   rule1103 = \  (_ :: ()) ->
     TagKind_DefineMorphShape2
   {-# INLINE rule1104 #-}
   rule1104 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineSceneAndFrameLabelData #-}
sem_TagKind_DefineSceneAndFrameLabelData ::  T_TagKind 
sem_TagKind_DefineSceneAndFrameLabelData  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1105  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1106 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1105 #-}
   rule1105 = \  (_ :: ()) ->
     TagKind_DefineSceneAndFrameLabelData
   {-# INLINE rule1106 #-}
   rule1106 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineBinaryData #-}
sem_TagKind_DefineBinaryData ::  T_TagKind 
sem_TagKind_DefineBinaryData  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1107  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1108 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1107 #-}
   rule1107 = \  (_ :: ()) ->
     TagKind_DefineBinaryData
   {-# INLINE rule1108 #-}
   rule1108 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineFontName #-}
sem_TagKind_DefineFontName ::  T_TagKind 
sem_TagKind_DefineFontName  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1109  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1110 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1109 #-}
   rule1109 = \  (_ :: ()) ->
     TagKind_DefineFontName
   {-# INLINE rule1110 #-}
   rule1110 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_StartSound2 #-}
sem_TagKind_StartSound2 ::  T_TagKind 
sem_TagKind_StartSound2  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1111  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1112 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1111 #-}
   rule1111 = \  (_ :: ()) ->
     TagKind_StartSound2
   {-# INLINE rule1112 #-}
   rule1112 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineBitsJPEG4 #-}
sem_TagKind_DefineBitsJPEG4 ::  T_TagKind 
sem_TagKind_DefineBitsJPEG4  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1113  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1114 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1113 #-}
   rule1113 = \  (_ :: ()) ->
     TagKind_DefineBitsJPEG4
   {-# INLINE rule1114 #-}
   rule1114 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_DefineFont4 #-}
sem_TagKind_DefineFont4 ::  T_TagKind 
sem_TagKind_DefineFont4  = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1115  ()
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1116 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1115 #-}
   rule1115 = \  (_ :: ()) ->
     TagKind_DefineFont4
   {-# INLINE rule1116 #-}
   rule1116 = \ _output ->
     _output
{-# NOINLINE sem_TagKind_Other #-}
sem_TagKind_Other :: (Word16) -> T_TagKind 
sem_TagKind_Other code_ = T_TagKind (return st155) where
   {-# NOINLINE st155 #-}
   st155 = let
      v154 :: T_TagKind_v154 
      v154 = \ (T_TagKind_vIn154 ) -> ( let
         _output = rule1117 code_
         _lhsOoutput :: TagKind
         _lhsOoutput = rule1118 _output
         __result_ = T_TagKind_vOut154 _lhsOoutput
         in __result_ )
     in C_TagKind_s155 v154
   {-# INLINE rule1117 #-}
   rule1117 = \ code_ ->
     TagKind_Other code_
   {-# INLINE rule1118 #-}
   rule1118 = \ _output ->
     _output

-- Tags --------------------------------------------------------
-- data
type Tags  = [ Tag ]

-- cata
{-# NOINLINE sem_Tags #-}
sem_Tags :: Tags  -> T_Tags 
sem_Tags list = Prelude.foldr sem_Tags_Cons sem_Tags_Nil (Prelude.map sem_Tag list)

-- semantic domain
newtype T_Tags  = T_Tags {
                         attach_T_Tags :: Identity (T_Tags_s158 )
                         }
newtype T_Tags_s158  = C_Tags_s158 {
                                   inv_Tags_s158 :: (T_Tags_v157 )
                                   }
data T_Tags_s159  = C_Tags_s159
type T_Tags_v157  = (T_Tags_vIn157 ) -> (T_Tags_vOut157 )
data T_Tags_vIn157  = T_Tags_vIn157 
data T_Tags_vOut157  = T_Tags_vOut157 (Tags)
{-# NOINLINE sem_Tags_Cons #-}
sem_Tags_Cons :: T_Tag  -> T_Tags  -> T_Tags 
sem_Tags_Cons hd_ tl_ = T_Tags (return st158) where
   {-# NOINLINE st158 #-}
   st158 = let
      v157 :: T_Tags_v157 
      v157 = \ (T_Tags_vIn157 ) -> ( let
         _hdX152 = Control.Monad.Identity.runIdentity (attach_T_Tag (hd_))
         _tlX158 = Control.Monad.Identity.runIdentity (attach_T_Tags (tl_))
         (T_Tag_vOut151 _hdIoutput) = inv_Tag_s152 _hdX152 (T_Tag_vIn151 )
         (T_Tags_vOut157 _tlIoutput) = inv_Tags_s158 _tlX158 (T_Tags_vIn157 )
         _output = rule1119 _hdIoutput _tlIoutput
         _lhsOoutput :: Tags
         _lhsOoutput = rule1120 _output
         __result_ = T_Tags_vOut157 _lhsOoutput
         in __result_ )
     in C_Tags_s158 v157
   {-# INLINE rule1119 #-}
   rule1119 = \ ((_hdIoutput) :: Tag) ((_tlIoutput) :: Tags) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule1120 #-}
   rule1120 = \ _output ->
     _output
{-# NOINLINE sem_Tags_Nil #-}
sem_Tags_Nil ::  T_Tags 
sem_Tags_Nil  = T_Tags (return st158) where
   {-# NOINLINE st158 #-}
   st158 = let
      v157 :: T_Tags_v157 
      v157 = \ (T_Tags_vIn157 ) -> ( let
         _output = rule1121  ()
         _lhsOoutput :: Tags
         _lhsOoutput = rule1122 _output
         __result_ = T_Tags_vOut157 _lhsOoutput
         in __result_ )
     in C_Tags_s158 v157
   {-# INLINE rule1121 #-}
   rule1121 = \  (_ :: ()) ->
     []
   {-# INLINE rule1122 #-}
   rule1122 = \ _output ->
     _output

-- Trait -------------------------------------------------------
-- data
data Trait 
  = Trait_Trait {name_Trait_Trait :: (Word32), data_Trait_Trait :: (TraitData), attrs_Trait_Trait :: (TraitAttrs), meta_Trait_Trait :: (TraitMeta)}

-- cata
{-# INLINE sem_Trait #-}
sem_Trait :: Trait  -> T_Trait 
sem_Trait ( Trait_Trait name_ data_ attrs_ meta_ ) = sem_Trait_Trait name_ ( sem_TraitData data_ ) ( sem_TraitAttrs attrs_ ) ( sem_TraitMeta meta_ )

-- semantic domain
newtype T_Trait  = T_Trait {
                           attach_T_Trait :: Identity (T_Trait_s161 )
                           }
newtype T_Trait_s161  = C_Trait_s161 {
                                     inv_Trait_s161 :: (T_Trait_v160 )
                                     }
data T_Trait_s162  = C_Trait_s162
type T_Trait_v160  = (T_Trait_vIn160 ) -> (T_Trait_vOut160 )
data T_Trait_vIn160  = T_Trait_vIn160 
data T_Trait_vOut160  = T_Trait_vOut160 (Trait)
{-# NOINLINE sem_Trait_Trait #-}
sem_Trait_Trait :: (Word32) -> T_TraitData  -> T_TraitAttrs  -> T_TraitMeta  -> T_Trait 
sem_Trait_Trait name_ data_ attrs_ meta_ = T_Trait (return st161) where
   {-# NOINLINE st161 #-}
   st161 = let
      v160 :: T_Trait_v160 
      v160 = \ (T_Trait_vIn160 ) -> ( let
         _dataX170 = Control.Monad.Identity.runIdentity (attach_T_TraitData (data_))
         _attrsX167 = Control.Monad.Identity.runIdentity (attach_T_TraitAttrs (attrs_))
         _metaX176 = Control.Monad.Identity.runIdentity (attach_T_TraitMeta (meta_))
         (T_TraitData_vOut169 _dataIoutput) = inv_TraitData_s170 _dataX170 (T_TraitData_vIn169 )
         (T_TraitAttrs_vOut166 _attrsIoutput) = inv_TraitAttrs_s167 _attrsX167 (T_TraitAttrs_vIn166 )
         (T_TraitMeta_vOut175 _metaIoutput) = inv_TraitMeta_s176 _metaX176 (T_TraitMeta_vIn175 )
         _output = rule1123 _attrsIoutput _dataIoutput _metaIoutput name_
         _lhsOoutput :: Trait
         _lhsOoutput = rule1124 _output
         __result_ = T_Trait_vOut160 _lhsOoutput
         in __result_ )
     in C_Trait_s161 v160
   {-# INLINE rule1123 #-}
   rule1123 = \ ((_attrsIoutput) :: TraitAttrs) ((_dataIoutput) :: TraitData) ((_metaIoutput) :: TraitMeta) name_ ->
     Trait_Trait name_ _dataIoutput _attrsIoutput _metaIoutput
   {-# INLINE rule1124 #-}
   rule1124 = \ _output ->
     _output

-- TraitAttr ---------------------------------------------------
-- data
data TraitAttr 
  = TraitAttr_Final {}
  | TraitAttr_Override {}
  | TraitAttr_Metadata {}

-- cata
{-# NOINLINE sem_TraitAttr #-}
sem_TraitAttr :: TraitAttr  -> T_TraitAttr 
sem_TraitAttr ( TraitAttr_Final  ) = sem_TraitAttr_Final 
sem_TraitAttr ( TraitAttr_Override  ) = sem_TraitAttr_Override 
sem_TraitAttr ( TraitAttr_Metadata  ) = sem_TraitAttr_Metadata 

-- semantic domain
newtype T_TraitAttr  = T_TraitAttr {
                                   attach_T_TraitAttr :: Identity (T_TraitAttr_s164 )
                                   }
newtype T_TraitAttr_s164  = C_TraitAttr_s164 {
                                             inv_TraitAttr_s164 :: (T_TraitAttr_v163 )
                                             }
data T_TraitAttr_s165  = C_TraitAttr_s165
type T_TraitAttr_v163  = (T_TraitAttr_vIn163 ) -> (T_TraitAttr_vOut163 )
data T_TraitAttr_vIn163  = T_TraitAttr_vIn163 
data T_TraitAttr_vOut163  = T_TraitAttr_vOut163 (TraitAttr)
{-# NOINLINE sem_TraitAttr_Final #-}
sem_TraitAttr_Final ::  T_TraitAttr 
sem_TraitAttr_Final  = T_TraitAttr (return st164) where
   {-# NOINLINE st164 #-}
   st164 = let
      v163 :: T_TraitAttr_v163 
      v163 = \ (T_TraitAttr_vIn163 ) -> ( let
         _output = rule1125  ()
         _lhsOoutput :: TraitAttr
         _lhsOoutput = rule1126 _output
         __result_ = T_TraitAttr_vOut163 _lhsOoutput
         in __result_ )
     in C_TraitAttr_s164 v163
   {-# INLINE rule1125 #-}
   rule1125 = \  (_ :: ()) ->
     TraitAttr_Final
   {-# INLINE rule1126 #-}
   rule1126 = \ _output ->
     _output
{-# NOINLINE sem_TraitAttr_Override #-}
sem_TraitAttr_Override ::  T_TraitAttr 
sem_TraitAttr_Override  = T_TraitAttr (return st164) where
   {-# NOINLINE st164 #-}
   st164 = let
      v163 :: T_TraitAttr_v163 
      v163 = \ (T_TraitAttr_vIn163 ) -> ( let
         _output = rule1127  ()
         _lhsOoutput :: TraitAttr
         _lhsOoutput = rule1128 _output
         __result_ = T_TraitAttr_vOut163 _lhsOoutput
         in __result_ )
     in C_TraitAttr_s164 v163
   {-# INLINE rule1127 #-}
   rule1127 = \  (_ :: ()) ->
     TraitAttr_Override
   {-# INLINE rule1128 #-}
   rule1128 = \ _output ->
     _output
{-# NOINLINE sem_TraitAttr_Metadata #-}
sem_TraitAttr_Metadata ::  T_TraitAttr 
sem_TraitAttr_Metadata  = T_TraitAttr (return st164) where
   {-# NOINLINE st164 #-}
   st164 = let
      v163 :: T_TraitAttr_v163 
      v163 = \ (T_TraitAttr_vIn163 ) -> ( let
         _output = rule1129  ()
         _lhsOoutput :: TraitAttr
         _lhsOoutput = rule1130 _output
         __result_ = T_TraitAttr_vOut163 _lhsOoutput
         in __result_ )
     in C_TraitAttr_s164 v163
   {-# INLINE rule1129 #-}
   rule1129 = \  (_ :: ()) ->
     TraitAttr_Metadata
   {-# INLINE rule1130 #-}
   rule1130 = \ _output ->
     _output

-- TraitAttrs --------------------------------------------------
-- data
type TraitAttrs  = [ TraitAttr ]

-- cata
{-# NOINLINE sem_TraitAttrs #-}
sem_TraitAttrs :: TraitAttrs  -> T_TraitAttrs 
sem_TraitAttrs list = Prelude.foldr sem_TraitAttrs_Cons sem_TraitAttrs_Nil (Prelude.map sem_TraitAttr list)

-- semantic domain
newtype T_TraitAttrs  = T_TraitAttrs {
                                     attach_T_TraitAttrs :: Identity (T_TraitAttrs_s167 )
                                     }
newtype T_TraitAttrs_s167  = C_TraitAttrs_s167 {
                                               inv_TraitAttrs_s167 :: (T_TraitAttrs_v166 )
                                               }
data T_TraitAttrs_s168  = C_TraitAttrs_s168
type T_TraitAttrs_v166  = (T_TraitAttrs_vIn166 ) -> (T_TraitAttrs_vOut166 )
data T_TraitAttrs_vIn166  = T_TraitAttrs_vIn166 
data T_TraitAttrs_vOut166  = T_TraitAttrs_vOut166 (TraitAttrs)
{-# NOINLINE sem_TraitAttrs_Cons #-}
sem_TraitAttrs_Cons :: T_TraitAttr  -> T_TraitAttrs  -> T_TraitAttrs 
sem_TraitAttrs_Cons hd_ tl_ = T_TraitAttrs (return st167) where
   {-# NOINLINE st167 #-}
   st167 = let
      v166 :: T_TraitAttrs_v166 
      v166 = \ (T_TraitAttrs_vIn166 ) -> ( let
         _hdX164 = Control.Monad.Identity.runIdentity (attach_T_TraitAttr (hd_))
         _tlX167 = Control.Monad.Identity.runIdentity (attach_T_TraitAttrs (tl_))
         (T_TraitAttr_vOut163 _hdIoutput) = inv_TraitAttr_s164 _hdX164 (T_TraitAttr_vIn163 )
         (T_TraitAttrs_vOut166 _tlIoutput) = inv_TraitAttrs_s167 _tlX167 (T_TraitAttrs_vIn166 )
         _output = rule1131 _hdIoutput _tlIoutput
         _lhsOoutput :: TraitAttrs
         _lhsOoutput = rule1132 _output
         __result_ = T_TraitAttrs_vOut166 _lhsOoutput
         in __result_ )
     in C_TraitAttrs_s167 v166
   {-# INLINE rule1131 #-}
   rule1131 = \ ((_hdIoutput) :: TraitAttr) ((_tlIoutput) :: TraitAttrs) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule1132 #-}
   rule1132 = \ _output ->
     _output
{-# NOINLINE sem_TraitAttrs_Nil #-}
sem_TraitAttrs_Nil ::  T_TraitAttrs 
sem_TraitAttrs_Nil  = T_TraitAttrs (return st167) where
   {-# NOINLINE st167 #-}
   st167 = let
      v166 :: T_TraitAttrs_v166 
      v166 = \ (T_TraitAttrs_vIn166 ) -> ( let
         _output = rule1133  ()
         _lhsOoutput :: TraitAttrs
         _lhsOoutput = rule1134 _output
         __result_ = T_TraitAttrs_vOut166 _lhsOoutput
         in __result_ )
     in C_TraitAttrs_s167 v166
   {-# INLINE rule1133 #-}
   rule1133 = \  (_ :: ()) ->
     []
   {-# INLINE rule1134 #-}
   rule1134 = \ _output ->
     _output

-- TraitData ---------------------------------------------------
-- data
data TraitData 
  = TraitData_Slot {slotId_TraitData_Slot :: (Word32), tp_TraitData_Slot :: (Word32), vindex_TraitData_Slot :: (Word32), vkind_TraitData_Slot :: (ValueKind)}
  | TraitData_Const {slotId_TraitData_Const :: (Word32), tp_TraitData_Const :: (Word32), vindex_TraitData_Const :: (Word32), vkind_TraitData_Const :: (ValueKind)}
  | TraitData_Method {dispId_TraitData_Method :: (Word32), method_TraitData_Method :: (Word32)}
  | TraitData_Getter {dispId_TraitData_Getter :: (Word32), method_TraitData_Getter :: (Word32)}
  | TraitData_Setter {dispId_TraitData_Setter :: (Word32), method_TraitData_Setter :: (Word32)}
  | TraitData_Function {dispId_TraitData_Function :: (Word32), method_TraitData_Function :: (Word32)}
  | TraitData_Class {slotId_TraitData_Class :: (Word32), class_TraitData_Class :: (Word32)}

-- cata
{-# NOINLINE sem_TraitData #-}
sem_TraitData :: TraitData  -> T_TraitData 
sem_TraitData ( TraitData_Slot slotId_ tp_ vindex_ vkind_ ) = sem_TraitData_Slot slotId_ tp_ vindex_ ( sem_ValueKind vkind_ )
sem_TraitData ( TraitData_Const slotId_ tp_ vindex_ vkind_ ) = sem_TraitData_Const slotId_ tp_ vindex_ ( sem_ValueKind vkind_ )
sem_TraitData ( TraitData_Method dispId_ method_ ) = sem_TraitData_Method dispId_ method_
sem_TraitData ( TraitData_Getter dispId_ method_ ) = sem_TraitData_Getter dispId_ method_
sem_TraitData ( TraitData_Setter dispId_ method_ ) = sem_TraitData_Setter dispId_ method_
sem_TraitData ( TraitData_Function dispId_ method_ ) = sem_TraitData_Function dispId_ method_
sem_TraitData ( TraitData_Class slotId_ class_ ) = sem_TraitData_Class slotId_ class_

-- semantic domain
newtype T_TraitData  = T_TraitData {
                                   attach_T_TraitData :: Identity (T_TraitData_s170 )
                                   }
newtype T_TraitData_s170  = C_TraitData_s170 {
                                             inv_TraitData_s170 :: (T_TraitData_v169 )
                                             }
data T_TraitData_s171  = C_TraitData_s171
type T_TraitData_v169  = (T_TraitData_vIn169 ) -> (T_TraitData_vOut169 )
data T_TraitData_vIn169  = T_TraitData_vIn169 
data T_TraitData_vOut169  = T_TraitData_vOut169 (TraitData)
{-# NOINLINE sem_TraitData_Slot #-}
sem_TraitData_Slot :: (Word32) -> (Word32) -> (Word32) -> T_ValueKind  -> T_TraitData 
sem_TraitData_Slot slotId_ tp_ vindex_ vkind_ = T_TraitData (return st170) where
   {-# NOINLINE st170 #-}
   st170 = let
      v169 :: T_TraitData_v169 
      v169 = \ (T_TraitData_vIn169 ) -> ( let
         _vkindX182 = Control.Monad.Identity.runIdentity (attach_T_ValueKind (vkind_))
         (T_ValueKind_vOut181 _vkindIoutput) = inv_ValueKind_s182 _vkindX182 (T_ValueKind_vIn181 )
         _output = rule1135 _vkindIoutput slotId_ tp_ vindex_
         _lhsOoutput :: TraitData
         _lhsOoutput = rule1136 _output
         __result_ = T_TraitData_vOut169 _lhsOoutput
         in __result_ )
     in C_TraitData_s170 v169
   {-# INLINE rule1135 #-}
   rule1135 = \ ((_vkindIoutput) :: ValueKind) slotId_ tp_ vindex_ ->
     TraitData_Slot slotId_ tp_ vindex_ _vkindIoutput
   {-# INLINE rule1136 #-}
   rule1136 = \ _output ->
     _output
{-# NOINLINE sem_TraitData_Const #-}
sem_TraitData_Const :: (Word32) -> (Word32) -> (Word32) -> T_ValueKind  -> T_TraitData 
sem_TraitData_Const slotId_ tp_ vindex_ vkind_ = T_TraitData (return st170) where
   {-# NOINLINE st170 #-}
   st170 = let
      v169 :: T_TraitData_v169 
      v169 = \ (T_TraitData_vIn169 ) -> ( let
         _vkindX182 = Control.Monad.Identity.runIdentity (attach_T_ValueKind (vkind_))
         (T_ValueKind_vOut181 _vkindIoutput) = inv_ValueKind_s182 _vkindX182 (T_ValueKind_vIn181 )
         _output = rule1137 _vkindIoutput slotId_ tp_ vindex_
         _lhsOoutput :: TraitData
         _lhsOoutput = rule1138 _output
         __result_ = T_TraitData_vOut169 _lhsOoutput
         in __result_ )
     in C_TraitData_s170 v169
   {-# INLINE rule1137 #-}
   rule1137 = \ ((_vkindIoutput) :: ValueKind) slotId_ tp_ vindex_ ->
     TraitData_Const slotId_ tp_ vindex_ _vkindIoutput
   {-# INLINE rule1138 #-}
   rule1138 = \ _output ->
     _output
{-# NOINLINE sem_TraitData_Method #-}
sem_TraitData_Method :: (Word32) -> (Word32) -> T_TraitData 
sem_TraitData_Method dispId_ method_ = T_TraitData (return st170) where
   {-# NOINLINE st170 #-}
   st170 = let
      v169 :: T_TraitData_v169 
      v169 = \ (T_TraitData_vIn169 ) -> ( let
         _output = rule1139 dispId_ method_
         _lhsOoutput :: TraitData
         _lhsOoutput = rule1140 _output
         __result_ = T_TraitData_vOut169 _lhsOoutput
         in __result_ )
     in C_TraitData_s170 v169
   {-# INLINE rule1139 #-}
   rule1139 = \ dispId_ method_ ->
     TraitData_Method dispId_ method_
   {-# INLINE rule1140 #-}
   rule1140 = \ _output ->
     _output
{-# NOINLINE sem_TraitData_Getter #-}
sem_TraitData_Getter :: (Word32) -> (Word32) -> T_TraitData 
sem_TraitData_Getter dispId_ method_ = T_TraitData (return st170) where
   {-# NOINLINE st170 #-}
   st170 = let
      v169 :: T_TraitData_v169 
      v169 = \ (T_TraitData_vIn169 ) -> ( let
         _output = rule1141 dispId_ method_
         _lhsOoutput :: TraitData
         _lhsOoutput = rule1142 _output
         __result_ = T_TraitData_vOut169 _lhsOoutput
         in __result_ )
     in C_TraitData_s170 v169
   {-# INLINE rule1141 #-}
   rule1141 = \ dispId_ method_ ->
     TraitData_Getter dispId_ method_
   {-# INLINE rule1142 #-}
   rule1142 = \ _output ->
     _output
{-# NOINLINE sem_TraitData_Setter #-}
sem_TraitData_Setter :: (Word32) -> (Word32) -> T_TraitData 
sem_TraitData_Setter dispId_ method_ = T_TraitData (return st170) where
   {-# NOINLINE st170 #-}
   st170 = let
      v169 :: T_TraitData_v169 
      v169 = \ (T_TraitData_vIn169 ) -> ( let
         _output = rule1143 dispId_ method_
         _lhsOoutput :: TraitData
         _lhsOoutput = rule1144 _output
         __result_ = T_TraitData_vOut169 _lhsOoutput
         in __result_ )
     in C_TraitData_s170 v169
   {-# INLINE rule1143 #-}
   rule1143 = \ dispId_ method_ ->
     TraitData_Setter dispId_ method_
   {-# INLINE rule1144 #-}
   rule1144 = \ _output ->
     _output
{-# NOINLINE sem_TraitData_Function #-}
sem_TraitData_Function :: (Word32) -> (Word32) -> T_TraitData 
sem_TraitData_Function dispId_ method_ = T_TraitData (return st170) where
   {-# NOINLINE st170 #-}
   st170 = let
      v169 :: T_TraitData_v169 
      v169 = \ (T_TraitData_vIn169 ) -> ( let
         _output = rule1145 dispId_ method_
         _lhsOoutput :: TraitData
         _lhsOoutput = rule1146 _output
         __result_ = T_TraitData_vOut169 _lhsOoutput
         in __result_ )
     in C_TraitData_s170 v169
   {-# INLINE rule1145 #-}
   rule1145 = \ dispId_ method_ ->
     TraitData_Function dispId_ method_
   {-# INLINE rule1146 #-}
   rule1146 = \ _output ->
     _output
{-# NOINLINE sem_TraitData_Class #-}
sem_TraitData_Class :: (Word32) -> (Word32) -> T_TraitData 
sem_TraitData_Class slotId_ class_ = T_TraitData (return st170) where
   {-# NOINLINE st170 #-}
   st170 = let
      v169 :: T_TraitData_v169 
      v169 = \ (T_TraitData_vIn169 ) -> ( let
         _output = rule1147 class_ slotId_
         _lhsOoutput :: TraitData
         _lhsOoutput = rule1148 _output
         __result_ = T_TraitData_vOut169 _lhsOoutput
         in __result_ )
     in C_TraitData_s170 v169
   {-# INLINE rule1147 #-}
   rule1147 = \ class_ slotId_ ->
     TraitData_Class slotId_ class_
   {-# INLINE rule1148 #-}
   rule1148 = \ _output ->
     _output

-- TraitKind ---------------------------------------------------
-- data
data TraitKind 
  = TraitKind_Slot {}
  | TraitKind_Method {}
  | TraitKind_Getter {}
  | TraitKind_Setter {}
  | TraitKind_Class {}
  | TraitKind_Function {}
  | TraitKind_Const {}

-- cata
{-# NOINLINE sem_TraitKind #-}
sem_TraitKind :: TraitKind  -> T_TraitKind 
sem_TraitKind ( TraitKind_Slot  ) = sem_TraitKind_Slot 
sem_TraitKind ( TraitKind_Method  ) = sem_TraitKind_Method 
sem_TraitKind ( TraitKind_Getter  ) = sem_TraitKind_Getter 
sem_TraitKind ( TraitKind_Setter  ) = sem_TraitKind_Setter 
sem_TraitKind ( TraitKind_Class  ) = sem_TraitKind_Class 
sem_TraitKind ( TraitKind_Function  ) = sem_TraitKind_Function 
sem_TraitKind ( TraitKind_Const  ) = sem_TraitKind_Const 

-- semantic domain
newtype T_TraitKind  = T_TraitKind {
                                   attach_T_TraitKind :: Identity (T_TraitKind_s173 )
                                   }
newtype T_TraitKind_s173  = C_TraitKind_s173 {
                                             inv_TraitKind_s173 :: (T_TraitKind_v172 )
                                             }
data T_TraitKind_s174  = C_TraitKind_s174
type T_TraitKind_v172  = (T_TraitKind_vIn172 ) -> (T_TraitKind_vOut172 )
data T_TraitKind_vIn172  = T_TraitKind_vIn172 
data T_TraitKind_vOut172  = T_TraitKind_vOut172 (TraitKind)
{-# NOINLINE sem_TraitKind_Slot #-}
sem_TraitKind_Slot ::  T_TraitKind 
sem_TraitKind_Slot  = T_TraitKind (return st173) where
   {-# NOINLINE st173 #-}
   st173 = let
      v172 :: T_TraitKind_v172 
      v172 = \ (T_TraitKind_vIn172 ) -> ( let
         _output = rule1149  ()
         _lhsOoutput :: TraitKind
         _lhsOoutput = rule1150 _output
         __result_ = T_TraitKind_vOut172 _lhsOoutput
         in __result_ )
     in C_TraitKind_s173 v172
   {-# INLINE rule1149 #-}
   rule1149 = \  (_ :: ()) ->
     TraitKind_Slot
   {-# INLINE rule1150 #-}
   rule1150 = \ _output ->
     _output
{-# NOINLINE sem_TraitKind_Method #-}
sem_TraitKind_Method ::  T_TraitKind 
sem_TraitKind_Method  = T_TraitKind (return st173) where
   {-# NOINLINE st173 #-}
   st173 = let
      v172 :: T_TraitKind_v172 
      v172 = \ (T_TraitKind_vIn172 ) -> ( let
         _output = rule1151  ()
         _lhsOoutput :: TraitKind
         _lhsOoutput = rule1152 _output
         __result_ = T_TraitKind_vOut172 _lhsOoutput
         in __result_ )
     in C_TraitKind_s173 v172
   {-# INLINE rule1151 #-}
   rule1151 = \  (_ :: ()) ->
     TraitKind_Method
   {-# INLINE rule1152 #-}
   rule1152 = \ _output ->
     _output
{-# NOINLINE sem_TraitKind_Getter #-}
sem_TraitKind_Getter ::  T_TraitKind 
sem_TraitKind_Getter  = T_TraitKind (return st173) where
   {-# NOINLINE st173 #-}
   st173 = let
      v172 :: T_TraitKind_v172 
      v172 = \ (T_TraitKind_vIn172 ) -> ( let
         _output = rule1153  ()
         _lhsOoutput :: TraitKind
         _lhsOoutput = rule1154 _output
         __result_ = T_TraitKind_vOut172 _lhsOoutput
         in __result_ )
     in C_TraitKind_s173 v172
   {-# INLINE rule1153 #-}
   rule1153 = \  (_ :: ()) ->
     TraitKind_Getter
   {-# INLINE rule1154 #-}
   rule1154 = \ _output ->
     _output
{-# NOINLINE sem_TraitKind_Setter #-}
sem_TraitKind_Setter ::  T_TraitKind 
sem_TraitKind_Setter  = T_TraitKind (return st173) where
   {-# NOINLINE st173 #-}
   st173 = let
      v172 :: T_TraitKind_v172 
      v172 = \ (T_TraitKind_vIn172 ) -> ( let
         _output = rule1155  ()
         _lhsOoutput :: TraitKind
         _lhsOoutput = rule1156 _output
         __result_ = T_TraitKind_vOut172 _lhsOoutput
         in __result_ )
     in C_TraitKind_s173 v172
   {-# INLINE rule1155 #-}
   rule1155 = \  (_ :: ()) ->
     TraitKind_Setter
   {-# INLINE rule1156 #-}
   rule1156 = \ _output ->
     _output
{-# NOINLINE sem_TraitKind_Class #-}
sem_TraitKind_Class ::  T_TraitKind 
sem_TraitKind_Class  = T_TraitKind (return st173) where
   {-# NOINLINE st173 #-}
   st173 = let
      v172 :: T_TraitKind_v172 
      v172 = \ (T_TraitKind_vIn172 ) -> ( let
         _output = rule1157  ()
         _lhsOoutput :: TraitKind
         _lhsOoutput = rule1158 _output
         __result_ = T_TraitKind_vOut172 _lhsOoutput
         in __result_ )
     in C_TraitKind_s173 v172
   {-# INLINE rule1157 #-}
   rule1157 = \  (_ :: ()) ->
     TraitKind_Class
   {-# INLINE rule1158 #-}
   rule1158 = \ _output ->
     _output
{-# NOINLINE sem_TraitKind_Function #-}
sem_TraitKind_Function ::  T_TraitKind 
sem_TraitKind_Function  = T_TraitKind (return st173) where
   {-# NOINLINE st173 #-}
   st173 = let
      v172 :: T_TraitKind_v172 
      v172 = \ (T_TraitKind_vIn172 ) -> ( let
         _output = rule1159  ()
         _lhsOoutput :: TraitKind
         _lhsOoutput = rule1160 _output
         __result_ = T_TraitKind_vOut172 _lhsOoutput
         in __result_ )
     in C_TraitKind_s173 v172
   {-# INLINE rule1159 #-}
   rule1159 = \  (_ :: ()) ->
     TraitKind_Function
   {-# INLINE rule1160 #-}
   rule1160 = \ _output ->
     _output
{-# NOINLINE sem_TraitKind_Const #-}
sem_TraitKind_Const ::  T_TraitKind 
sem_TraitKind_Const  = T_TraitKind (return st173) where
   {-# NOINLINE st173 #-}
   st173 = let
      v172 :: T_TraitKind_v172 
      v172 = \ (T_TraitKind_vIn172 ) -> ( let
         _output = rule1161  ()
         _lhsOoutput :: TraitKind
         _lhsOoutput = rule1162 _output
         __result_ = T_TraitKind_vOut172 _lhsOoutput
         in __result_ )
     in C_TraitKind_s173 v172
   {-# INLINE rule1161 #-}
   rule1161 = \  (_ :: ()) ->
     TraitKind_Const
   {-# INLINE rule1162 #-}
   rule1162 = \ _output ->
     _output

-- TraitMeta ---------------------------------------------------
-- data
type TraitMeta  = [ Word32 ]

-- cata
{-# NOINLINE sem_TraitMeta #-}
sem_TraitMeta :: TraitMeta  -> T_TraitMeta 
sem_TraitMeta list = Prelude.foldr sem_TraitMeta_Cons sem_TraitMeta_Nil list

-- semantic domain
newtype T_TraitMeta  = T_TraitMeta {
                                   attach_T_TraitMeta :: Identity (T_TraitMeta_s176 )
                                   }
newtype T_TraitMeta_s176  = C_TraitMeta_s176 {
                                             inv_TraitMeta_s176 :: (T_TraitMeta_v175 )
                                             }
data T_TraitMeta_s177  = C_TraitMeta_s177
type T_TraitMeta_v175  = (T_TraitMeta_vIn175 ) -> (T_TraitMeta_vOut175 )
data T_TraitMeta_vIn175  = T_TraitMeta_vIn175 
data T_TraitMeta_vOut175  = T_TraitMeta_vOut175 (TraitMeta)
{-# NOINLINE sem_TraitMeta_Cons #-}
sem_TraitMeta_Cons :: (Word32) -> T_TraitMeta  -> T_TraitMeta 
sem_TraitMeta_Cons hd_ tl_ = T_TraitMeta (return st176) where
   {-# NOINLINE st176 #-}
   st176 = let
      v175 :: T_TraitMeta_v175 
      v175 = \ (T_TraitMeta_vIn175 ) -> ( let
         _tlX176 = Control.Monad.Identity.runIdentity (attach_T_TraitMeta (tl_))
         (T_TraitMeta_vOut175 _tlIoutput) = inv_TraitMeta_s176 _tlX176 (T_TraitMeta_vIn175 )
         _output = rule1163 _tlIoutput hd_
         _lhsOoutput :: TraitMeta
         _lhsOoutput = rule1164 _output
         __result_ = T_TraitMeta_vOut175 _lhsOoutput
         in __result_ )
     in C_TraitMeta_s176 v175
   {-# INLINE rule1163 #-}
   rule1163 = \ ((_tlIoutput) :: TraitMeta) hd_ ->
     (:) hd_ _tlIoutput
   {-# INLINE rule1164 #-}
   rule1164 = \ _output ->
     _output
{-# NOINLINE sem_TraitMeta_Nil #-}
sem_TraitMeta_Nil ::  T_TraitMeta 
sem_TraitMeta_Nil  = T_TraitMeta (return st176) where
   {-# NOINLINE st176 #-}
   st176 = let
      v175 :: T_TraitMeta_v175 
      v175 = \ (T_TraitMeta_vIn175 ) -> ( let
         _output = rule1165  ()
         _lhsOoutput :: TraitMeta
         _lhsOoutput = rule1166 _output
         __result_ = T_TraitMeta_vOut175 _lhsOoutput
         in __result_ )
     in C_TraitMeta_s176 v175
   {-# INLINE rule1165 #-}
   rule1165 = \  (_ :: ()) ->
     []
   {-# INLINE rule1166 #-}
   rule1166 = \ _output ->
     _output

-- Traits ------------------------------------------------------
-- data
type Traits  = [ Trait ]

-- cata
{-# NOINLINE sem_Traits #-}
sem_Traits :: Traits  -> T_Traits 
sem_Traits list = Prelude.foldr sem_Traits_Cons sem_Traits_Nil (Prelude.map sem_Trait list)

-- semantic domain
newtype T_Traits  = T_Traits {
                             attach_T_Traits :: Identity (T_Traits_s179 )
                             }
newtype T_Traits_s179  = C_Traits_s179 {
                                       inv_Traits_s179 :: (T_Traits_v178 )
                                       }
data T_Traits_s180  = C_Traits_s180
type T_Traits_v178  = (T_Traits_vIn178 ) -> (T_Traits_vOut178 )
data T_Traits_vIn178  = T_Traits_vIn178 
data T_Traits_vOut178  = T_Traits_vOut178 (Traits)
{-# NOINLINE sem_Traits_Cons #-}
sem_Traits_Cons :: T_Trait  -> T_Traits  -> T_Traits 
sem_Traits_Cons hd_ tl_ = T_Traits (return st179) where
   {-# NOINLINE st179 #-}
   st179 = let
      v178 :: T_Traits_v178 
      v178 = \ (T_Traits_vIn178 ) -> ( let
         _hdX161 = Control.Monad.Identity.runIdentity (attach_T_Trait (hd_))
         _tlX179 = Control.Monad.Identity.runIdentity (attach_T_Traits (tl_))
         (T_Trait_vOut160 _hdIoutput) = inv_Trait_s161 _hdX161 (T_Trait_vIn160 )
         (T_Traits_vOut178 _tlIoutput) = inv_Traits_s179 _tlX179 (T_Traits_vIn178 )
         _output = rule1167 _hdIoutput _tlIoutput
         _lhsOoutput :: Traits
         _lhsOoutput = rule1168 _output
         __result_ = T_Traits_vOut178 _lhsOoutput
         in __result_ )
     in C_Traits_s179 v178
   {-# INLINE rule1167 #-}
   rule1167 = \ ((_hdIoutput) :: Trait) ((_tlIoutput) :: Traits) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule1168 #-}
   rule1168 = \ _output ->
     _output
{-# NOINLINE sem_Traits_Nil #-}
sem_Traits_Nil ::  T_Traits 
sem_Traits_Nil  = T_Traits (return st179) where
   {-# NOINLINE st179 #-}
   st179 = let
      v178 :: T_Traits_v178 
      v178 = \ (T_Traits_vIn178 ) -> ( let
         _output = rule1169  ()
         _lhsOoutput :: Traits
         _lhsOoutput = rule1170 _output
         __result_ = T_Traits_vOut178 _lhsOoutput
         in __result_ )
     in C_Traits_s179 v178
   {-# INLINE rule1169 #-}
   rule1169 = \  (_ :: ()) ->
     []
   {-# INLINE rule1170 #-}
   rule1170 = \ _output ->
     _output

-- ValueKind ---------------------------------------------------
-- data
data ValueKind 
  = ValueKind_Int {}
  | ValueKind_UInt {}
  | ValueKind_Double {}
  | ValueKind_Utf8 {}
  | ValueKind_True {}
  | ValueKind_False {}
  | ValueKind_Null {}
  | ValueKind_Undefined {}
  | ValueKind_Namespace {}
  | ValueKind_Package {}
  | ValueKind_Internal {}
  | ValueKind_Protected {}
  | ValueKind_Explicit {}
  | ValueKind_Static {}
  | ValueKind_Private {}

-- cata
{-# NOINLINE sem_ValueKind #-}
sem_ValueKind :: ValueKind  -> T_ValueKind 
sem_ValueKind ( ValueKind_Int  ) = sem_ValueKind_Int 
sem_ValueKind ( ValueKind_UInt  ) = sem_ValueKind_UInt 
sem_ValueKind ( ValueKind_Double  ) = sem_ValueKind_Double 
sem_ValueKind ( ValueKind_Utf8  ) = sem_ValueKind_Utf8 
sem_ValueKind ( ValueKind_True  ) = sem_ValueKind_True 
sem_ValueKind ( ValueKind_False  ) = sem_ValueKind_False 
sem_ValueKind ( ValueKind_Null  ) = sem_ValueKind_Null 
sem_ValueKind ( ValueKind_Undefined  ) = sem_ValueKind_Undefined 
sem_ValueKind ( ValueKind_Namespace  ) = sem_ValueKind_Namespace 
sem_ValueKind ( ValueKind_Package  ) = sem_ValueKind_Package 
sem_ValueKind ( ValueKind_Internal  ) = sem_ValueKind_Internal 
sem_ValueKind ( ValueKind_Protected  ) = sem_ValueKind_Protected 
sem_ValueKind ( ValueKind_Explicit  ) = sem_ValueKind_Explicit 
sem_ValueKind ( ValueKind_Static  ) = sem_ValueKind_Static 
sem_ValueKind ( ValueKind_Private  ) = sem_ValueKind_Private 

-- semantic domain
newtype T_ValueKind  = T_ValueKind {
                                   attach_T_ValueKind :: Identity (T_ValueKind_s182 )
                                   }
newtype T_ValueKind_s182  = C_ValueKind_s182 {
                                             inv_ValueKind_s182 :: (T_ValueKind_v181 )
                                             }
data T_ValueKind_s183  = C_ValueKind_s183
type T_ValueKind_v181  = (T_ValueKind_vIn181 ) -> (T_ValueKind_vOut181 )
data T_ValueKind_vIn181  = T_ValueKind_vIn181 
data T_ValueKind_vOut181  = T_ValueKind_vOut181 (ValueKind)
{-# NOINLINE sem_ValueKind_Int #-}
sem_ValueKind_Int ::  T_ValueKind 
sem_ValueKind_Int  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1171  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1172 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1171 #-}
   rule1171 = \  (_ :: ()) ->
     ValueKind_Int
   {-# INLINE rule1172 #-}
   rule1172 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_UInt #-}
sem_ValueKind_UInt ::  T_ValueKind 
sem_ValueKind_UInt  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1173  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1174 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1173 #-}
   rule1173 = \  (_ :: ()) ->
     ValueKind_UInt
   {-# INLINE rule1174 #-}
   rule1174 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Double #-}
sem_ValueKind_Double ::  T_ValueKind 
sem_ValueKind_Double  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1175  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1176 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1175 #-}
   rule1175 = \  (_ :: ()) ->
     ValueKind_Double
   {-# INLINE rule1176 #-}
   rule1176 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Utf8 #-}
sem_ValueKind_Utf8 ::  T_ValueKind 
sem_ValueKind_Utf8  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1177  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1178 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1177 #-}
   rule1177 = \  (_ :: ()) ->
     ValueKind_Utf8
   {-# INLINE rule1178 #-}
   rule1178 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_True #-}
sem_ValueKind_True ::  T_ValueKind 
sem_ValueKind_True  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1179  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1180 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1179 #-}
   rule1179 = \  (_ :: ()) ->
     ValueKind_True
   {-# INLINE rule1180 #-}
   rule1180 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_False #-}
sem_ValueKind_False ::  T_ValueKind 
sem_ValueKind_False  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1181  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1182 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1181 #-}
   rule1181 = \  (_ :: ()) ->
     ValueKind_False
   {-# INLINE rule1182 #-}
   rule1182 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Null #-}
sem_ValueKind_Null ::  T_ValueKind 
sem_ValueKind_Null  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1183  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1184 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1183 #-}
   rule1183 = \  (_ :: ()) ->
     ValueKind_Null
   {-# INLINE rule1184 #-}
   rule1184 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Undefined #-}
sem_ValueKind_Undefined ::  T_ValueKind 
sem_ValueKind_Undefined  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1185  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1186 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1185 #-}
   rule1185 = \  (_ :: ()) ->
     ValueKind_Undefined
   {-# INLINE rule1186 #-}
   rule1186 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Namespace #-}
sem_ValueKind_Namespace ::  T_ValueKind 
sem_ValueKind_Namespace  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1187  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1188 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1187 #-}
   rule1187 = \  (_ :: ()) ->
     ValueKind_Namespace
   {-# INLINE rule1188 #-}
   rule1188 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Package #-}
sem_ValueKind_Package ::  T_ValueKind 
sem_ValueKind_Package  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1189  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1190 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1189 #-}
   rule1189 = \  (_ :: ()) ->
     ValueKind_Package
   {-# INLINE rule1190 #-}
   rule1190 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Internal #-}
sem_ValueKind_Internal ::  T_ValueKind 
sem_ValueKind_Internal  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1191  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1192 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1191 #-}
   rule1191 = \  (_ :: ()) ->
     ValueKind_Internal
   {-# INLINE rule1192 #-}
   rule1192 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Protected #-}
sem_ValueKind_Protected ::  T_ValueKind 
sem_ValueKind_Protected  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1193  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1194 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1193 #-}
   rule1193 = \  (_ :: ()) ->
     ValueKind_Protected
   {-# INLINE rule1194 #-}
   rule1194 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Explicit #-}
sem_ValueKind_Explicit ::  T_ValueKind 
sem_ValueKind_Explicit  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1195  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1196 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1195 #-}
   rule1195 = \  (_ :: ()) ->
     ValueKind_Explicit
   {-# INLINE rule1196 #-}
   rule1196 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Static #-}
sem_ValueKind_Static ::  T_ValueKind 
sem_ValueKind_Static  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1197  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1198 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1197 #-}
   rule1197 = \  (_ :: ()) ->
     ValueKind_Static
   {-# INLINE rule1198 #-}
   rule1198 = \ _output ->
     _output
{-# NOINLINE sem_ValueKind_Private #-}
sem_ValueKind_Private ::  T_ValueKind 
sem_ValueKind_Private  = T_ValueKind (return st182) where
   {-# NOINLINE st182 #-}
   st182 = let
      v181 :: T_ValueKind_v181 
      v181 = \ (T_ValueKind_vIn181 ) -> ( let
         _output = rule1199  ()
         _lhsOoutput :: ValueKind
         _lhsOoutput = rule1200 _output
         __result_ = T_ValueKind_vOut181 _lhsOoutput
         in __result_ )
     in C_ValueKind_s182 v181
   {-# INLINE rule1199 #-}
   rule1199 = \  (_ :: ()) ->
     ValueKind_Private
   {-# INLINE rule1200 #-}
   rule1200 = \ _output ->
     _output

-- VirtKind ----------------------------------------------------
-- data
data VirtKind 
  = VirtKind_BeginBody {}
  | VirtKind_EndBody {}
  | VirtKind_BeginBlock {conditional_VirtKind_BeginBlock :: (Bool)}
  | VirtKind_EndBlock {}
  | VirtKind_Label {}
  | VirtKind_Terminator {}
  | VirtKind_Dependency {vid_VirtKind_Dependency :: (Int)}
  | VirtKind_SetLocal {ident_VirtKind_SetLocal :: (Int)}
  | VirtKind_GetLocal {ident_VirtKind_GetLocal :: (Int)}

-- cata
{-# NOINLINE sem_VirtKind #-}
sem_VirtKind :: VirtKind  -> T_VirtKind 
sem_VirtKind ( VirtKind_BeginBody  ) = sem_VirtKind_BeginBody 
sem_VirtKind ( VirtKind_EndBody  ) = sem_VirtKind_EndBody 
sem_VirtKind ( VirtKind_BeginBlock conditional_ ) = sem_VirtKind_BeginBlock conditional_
sem_VirtKind ( VirtKind_EndBlock  ) = sem_VirtKind_EndBlock 
sem_VirtKind ( VirtKind_Label  ) = sem_VirtKind_Label 
sem_VirtKind ( VirtKind_Terminator  ) = sem_VirtKind_Terminator 
sem_VirtKind ( VirtKind_Dependency vid_ ) = sem_VirtKind_Dependency vid_
sem_VirtKind ( VirtKind_SetLocal ident_ ) = sem_VirtKind_SetLocal ident_
sem_VirtKind ( VirtKind_GetLocal ident_ ) = sem_VirtKind_GetLocal ident_

-- semantic domain
newtype T_VirtKind  = T_VirtKind {
                                 attach_T_VirtKind :: Identity (T_VirtKind_s185 )
                                 }
newtype T_VirtKind_s185  = C_VirtKind_s185 {
                                           inv_VirtKind_s185 :: (T_VirtKind_v184 )
                                           }
data T_VirtKind_s186  = C_VirtKind_s186
type T_VirtKind_v184  = (T_VirtKind_vIn184 ) -> (T_VirtKind_vOut184 )
data T_VirtKind_vIn184  = T_VirtKind_vIn184 
data T_VirtKind_vOut184  = T_VirtKind_vOut184 (VirtKind)
{-# NOINLINE sem_VirtKind_BeginBody #-}
sem_VirtKind_BeginBody ::  T_VirtKind 
sem_VirtKind_BeginBody  = T_VirtKind (return st185) where
   {-# NOINLINE st185 #-}
   st185 = let
      v184 :: T_VirtKind_v184 
      v184 = \ (T_VirtKind_vIn184 ) -> ( let
         _output = rule1201  ()
         _lhsOoutput :: VirtKind
         _lhsOoutput = rule1202 _output
         __result_ = T_VirtKind_vOut184 _lhsOoutput
         in __result_ )
     in C_VirtKind_s185 v184
   {-# INLINE rule1201 #-}
   rule1201 = \  (_ :: ()) ->
     VirtKind_BeginBody
   {-# INLINE rule1202 #-}
   rule1202 = \ _output ->
     _output
{-# NOINLINE sem_VirtKind_EndBody #-}
sem_VirtKind_EndBody ::  T_VirtKind 
sem_VirtKind_EndBody  = T_VirtKind (return st185) where
   {-# NOINLINE st185 #-}
   st185 = let
      v184 :: T_VirtKind_v184 
      v184 = \ (T_VirtKind_vIn184 ) -> ( let
         _output = rule1203  ()
         _lhsOoutput :: VirtKind
         _lhsOoutput = rule1204 _output
         __result_ = T_VirtKind_vOut184 _lhsOoutput
         in __result_ )
     in C_VirtKind_s185 v184
   {-# INLINE rule1203 #-}
   rule1203 = \  (_ :: ()) ->
     VirtKind_EndBody
   {-# INLINE rule1204 #-}
   rule1204 = \ _output ->
     _output
{-# NOINLINE sem_VirtKind_BeginBlock #-}
sem_VirtKind_BeginBlock :: (Bool) -> T_VirtKind 
sem_VirtKind_BeginBlock conditional_ = T_VirtKind (return st185) where
   {-# NOINLINE st185 #-}
   st185 = let
      v184 :: T_VirtKind_v184 
      v184 = \ (T_VirtKind_vIn184 ) -> ( let
         _output = rule1205 conditional_
         _lhsOoutput :: VirtKind
         _lhsOoutput = rule1206 _output
         __result_ = T_VirtKind_vOut184 _lhsOoutput
         in __result_ )
     in C_VirtKind_s185 v184
   {-# INLINE rule1205 #-}
   rule1205 = \ conditional_ ->
     VirtKind_BeginBlock conditional_
   {-# INLINE rule1206 #-}
   rule1206 = \ _output ->
     _output
{-# NOINLINE sem_VirtKind_EndBlock #-}
sem_VirtKind_EndBlock ::  T_VirtKind 
sem_VirtKind_EndBlock  = T_VirtKind (return st185) where
   {-# NOINLINE st185 #-}
   st185 = let
      v184 :: T_VirtKind_v184 
      v184 = \ (T_VirtKind_vIn184 ) -> ( let
         _output = rule1207  ()
         _lhsOoutput :: VirtKind
         _lhsOoutput = rule1208 _output
         __result_ = T_VirtKind_vOut184 _lhsOoutput
         in __result_ )
     in C_VirtKind_s185 v184
   {-# INLINE rule1207 #-}
   rule1207 = \  (_ :: ()) ->
     VirtKind_EndBlock
   {-# INLINE rule1208 #-}
   rule1208 = \ _output ->
     _output
{-# NOINLINE sem_VirtKind_Label #-}
sem_VirtKind_Label ::  T_VirtKind 
sem_VirtKind_Label  = T_VirtKind (return st185) where
   {-# NOINLINE st185 #-}
   st185 = let
      v184 :: T_VirtKind_v184 
      v184 = \ (T_VirtKind_vIn184 ) -> ( let
         _output = rule1209  ()
         _lhsOoutput :: VirtKind
         _lhsOoutput = rule1210 _output
         __result_ = T_VirtKind_vOut184 _lhsOoutput
         in __result_ )
     in C_VirtKind_s185 v184
   {-# INLINE rule1209 #-}
   rule1209 = \  (_ :: ()) ->
     VirtKind_Label
   {-# INLINE rule1210 #-}
   rule1210 = \ _output ->
     _output
{-# NOINLINE sem_VirtKind_Terminator #-}
sem_VirtKind_Terminator ::  T_VirtKind 
sem_VirtKind_Terminator  = T_VirtKind (return st185) where
   {-# NOINLINE st185 #-}
   st185 = let
      v184 :: T_VirtKind_v184 
      v184 = \ (T_VirtKind_vIn184 ) -> ( let
         _output = rule1211  ()
         _lhsOoutput :: VirtKind
         _lhsOoutput = rule1212 _output
         __result_ = T_VirtKind_vOut184 _lhsOoutput
         in __result_ )
     in C_VirtKind_s185 v184
   {-# INLINE rule1211 #-}
   rule1211 = \  (_ :: ()) ->
     VirtKind_Terminator
   {-# INLINE rule1212 #-}
   rule1212 = \ _output ->
     _output
{-# NOINLINE sem_VirtKind_Dependency #-}
sem_VirtKind_Dependency :: (Int) -> T_VirtKind 
sem_VirtKind_Dependency vid_ = T_VirtKind (return st185) where
   {-# NOINLINE st185 #-}
   st185 = let
      v184 :: T_VirtKind_v184 
      v184 = \ (T_VirtKind_vIn184 ) -> ( let
         _output = rule1213 vid_
         _lhsOoutput :: VirtKind
         _lhsOoutput = rule1214 _output
         __result_ = T_VirtKind_vOut184 _lhsOoutput
         in __result_ )
     in C_VirtKind_s185 v184
   {-# INLINE rule1213 #-}
   rule1213 = \ vid_ ->
     VirtKind_Dependency vid_
   {-# INLINE rule1214 #-}
   rule1214 = \ _output ->
     _output
{-# NOINLINE sem_VirtKind_SetLocal #-}
sem_VirtKind_SetLocal :: (Int) -> T_VirtKind 
sem_VirtKind_SetLocal ident_ = T_VirtKind (return st185) where
   {-# NOINLINE st185 #-}
   st185 = let
      v184 :: T_VirtKind_v184 
      v184 = \ (T_VirtKind_vIn184 ) -> ( let
         _output = rule1215 ident_
         _lhsOoutput :: VirtKind
         _lhsOoutput = rule1216 _output
         __result_ = T_VirtKind_vOut184 _lhsOoutput
         in __result_ )
     in C_VirtKind_s185 v184
   {-# INLINE rule1215 #-}
   rule1215 = \ ident_ ->
     VirtKind_SetLocal ident_
   {-# INLINE rule1216 #-}
   rule1216 = \ _output ->
     _output
{-# NOINLINE sem_VirtKind_GetLocal #-}
sem_VirtKind_GetLocal :: (Int) -> T_VirtKind 
sem_VirtKind_GetLocal ident_ = T_VirtKind (return st185) where
   {-# NOINLINE st185 #-}
   st185 = let
      v184 :: T_VirtKind_v184 
      v184 = \ (T_VirtKind_vIn184 ) -> ( let
         _output = rule1217 ident_
         _lhsOoutput :: VirtKind
         _lhsOoutput = rule1218 _output
         __result_ = T_VirtKind_vOut184 _lhsOoutput
         in __result_ )
     in C_VirtKind_s185 v184
   {-# INLINE rule1217 #-}
   rule1217 = \ ident_ ->
     VirtKind_GetLocal ident_
   {-# INLINE rule1218 #-}
   rule1218 = \ _output ->
     _output
